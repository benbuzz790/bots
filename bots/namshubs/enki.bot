{
 "name": "Enki",
 "model_engine": "claude-sonnet-4-5-20250929",
 "max_tokens": 32000,
 "temperature": 0.3,
 "role": "assistant",
 "role_description": "a friendly AI assistant",
 "conversation": {
  "content": "",
  "pending_results": [],
  "role": "empty",
  "tool_calls": [],
  "tool_results": [],
  "node_class": "AnthropicNode",
  "replies": [
   {
    "content": "Hello Enki! You're going to write namshubs for other bots. You will find yourself in my agent framework repository. Please read README.md, and find and read functional_prompts.py",
    "pending_results": [],
    "role": "user",
    "tool_calls": [],
    "tool_results": [],
    "node_class": "AnthropicNode",
    "replies": [
     {
      "content": "Hello! I'm here to help you write namshubs for other bots. Let me start by reading the README.md and finding the functional_prompts.py file.",
      "pending_results": [],
      "role": "assistant",
      "tool_calls": [
       {
        "type": "tool_use",
        "id": "toolu_01Le3PSPu5cpEAesUsd38Q64",
        "name": "view",
        "input": {
         "file_path": "README.md"
        }
       },
       {
        "type": "tool_use",
        "id": "toolu_01Rd1sbGFvY8nYn8QhamfJ3y",
        "name": "view_dir",
        "input": {
         "start_path": ".",
         "target_extensions": "['py']"
        }
       }
      ],
      "tool_results": [],
      "node_class": "AnthropicNode",
      "replies": [
       {
        "content": "ok",
        "pending_results": [],
        "role": "user",
        "tool_calls": [],
        "tool_results": [
         {
          "type": "tool_result",
          "tool_use_id": "toolu_01Le3PSPu5cpEAesUsd38Q64",
          "content": "1:# bots\n2:\n3:**bots built bots**\n4:\n5:## Overview\n6:\n7:**bots** is yet another agent framework. What sets bots apart is that it represents conversations as graphs. Messages are nodes, and the conversation is a tree.\n8:\n9:This structure facilitates the development of tools which allow bots to manage their own context in various ways, including agentic context removal and agentic branching.\n10:\n11:A cli is built on top of this architecture, allowing the user to command a bot which can self-branch and self-prune.\n12:\n13:The conversation trees are packaged with python functions and llm model metadata as a \"bot\". The specified llm will be allowed and able to call those python functions on your system. Agentic branching and pruning are implemented as tools this way.\n14:\n15:**bots** also supports saving and loading. Tools, conversation, and metadata are preserved in a single .bot (json) file.\n16:\n17:The bots library also provides a structured interface for programming with such agents, aiming to make agents with dynamic context accessible and sharable for researchers and other sentients.\n18:\n19:## Foundation (bots.foundation)\n20:\n21:The core of the Bots library is built on a robust foundation:\n22:\n23:- Tool handling capabilities - any well-structured Python function can be used by a bot\n24:- Simple primary interface: `bot.respond()`, with supporting operations `add_tool(s)`, `save()`, `load()`, and `chat()`\n25:- Tree-based conversation management:\n26:  - Implements a linked tree structure for conversation histories\n27:  - Allows branching conversations and exploring multiple dialogue paths\n28:  - Efficiently manages context by only sending path to root\n29:  - Enables saving and loading specific conversation states\n30:- Abstract base classes for wrapping LLM API interfaces into a unified 'bot' interface\n31:- Pre-built implementations for ChatGPT and Anthropic bots\n32:- Complete bot portability - save and share bots with their full context and tools\n33:\n34:## Key Features\n35:\n36:1. **Auto Terminal (bots.dev.cli)**\n37:   ```bash\n38:   python -m bots.dev.cli [filename.bot]\n39:   ```\n40:This cli is similar to claude code. Use /help to see all commands.\n41:\n42:2. **Tool System (bots.tools)**\n43:   - Supports parallel tool calls\n44:   - Built-in tools for:\n45:     - Reliable python editing\n46:     - Powershell operations\n47:     - Agentic context manipulation\n48:     - General textfile editing\n49:\n50:3. **Functional Prompts (bots.flows.functional_prompts)**\n51:   - Core operations:\n52:      - prompt_while(bot, task_prompt, continue_prompt, condition): bot works in an agentic loop\n53:   - Parallel execution functions:\n54:     - par_branch_while() - processes multiple branches from the current conversation node in parallel\n55:\n56:   ```python\n57:   from bots.flows import functional_prompts as fp\n58:\n59:   # Example: after discussing a task, execute on multiple files:\n60:   responses, nodes = fp.par_branch_while(bot, [\n61:       \"Execute on file one\",\n62:       \"Execute on file two\",\n63:       \"Execute on file three\"\n64:   ])\n65:\n66:   # Example: Parallel dispatch across multiple bots\n67:   results = fp.par_dispatch(\n68:       bot_list=[bot1, bot2, bot3],\n69:       functional_prompt=fp.chain_while,\n70:       prompts=[\"Commit your changes\", \"Push to a new PR\"]\n71:   )\n72:   ```\n73:\n74:4. **Lazy Decorator (bots.lazy)**\n75:   - An experiment\n76:   - Runtime code generation via LLM\n77:   ```python\n78:   @lazy(\"Sort using a funny algorithm. Name variables as though you're a clown.\")\n79:   def sort(arr: list[int]) -> list[int]:\n80:       pass\n81:   # Source code is filled out (and executes) the first time the function is called.\n82:   ```\n83:\n84:## Installation\n85:\n86:```bash\n87:pip install git+https://github.com/benbuzz790/bots.git\n88:```\n89:\n90:## Quick Start\n91:\n92:1. Set up your API key as an environment variable:\n93:   - [OpenAI](https://platform.openai.com/docs/quickstart) or\n94:   - [Anthropic](https://docs.anthropic.com/en/docs/initial-setup#set-your-api-key)\n95:\n96:2. Basic Usage:\n97:```python\n98:from bots import AnthropicBot\n99:import bots.tools.code_tools as code_tools\n100:\n101:# Initialize and equip bot\n102:bot = AnthropicBot()\n103:bot.add_tools(code_tools)\n104:\n105:# Single response\n106:response = bot.respond(\"Please write a basic Flask app in app.py\")\n107:\n108:# Interactive mode\n109:bot.chat()\n110:```\n111:\n112:3. Save/Load Bot States:\n113:```python\n114:# Create a bot with repository context\n115:bot = AnthropicBot()\n116:bot.add_tools(code_tools)\n117:bot.chat()\n118:  ...\n119:  \"Read and understand our repository structure\"\n120:  ...\n121:  Tools used...\n122:  ...\n123:  /save\n124:\n125:# Later use\n126:import bots\n127:review_bot = bots.load(\"repo_context.bot\", autosave=False)\n128:review_bot.respond(\"Review PR #123\")\n129:```\n130:\n131:## Contributing\n132:\n133:We welcome contributions! Read [CONTRIBUTING.md](CONTRIBUTING.md)\n134:\n135:## License\n136:\n137:This project is licensed under the MIT License - see the [LICENSE.md](LICENSE.md) file for details.\n138:\n139:## Disclaimer\n140:\n141:This library is under active development. While it's being used successfully in various projects, please test thoroughly before using in production environments."
         },
         {
          "type": "tool_result",
          "tool_use_id": "toolu_01Rd1sbGFvY8nYn8QhamfJ3y",
          "content": "./\n    bot_gui.py\n    conftest.py\n    minimal.py\n    setup.py\n    archived_docker_testing/\n        run_tests_docker.py\n        run_tests_docker_auto.py\n    bots/\n        __init__.py\n        dev/\n            cli.py\n            decorators.py\n            pr_comment_parser.py\n            remove_boms.py\n            start.py\n            __init__.py\n            __main__.py\n        flows/\n            functional_prompts.py\n            recombinators.py\n            __init__.py\n        foundation/\n            anthropic_bots.py\n            base.py\n            gemini_bots.py\n            openai_bots.py\n            __init__.py\n        observability/\n            callbacks.py\n            config.py\n            cost_calculator.py\n            custom_exporters.py\n            metrics.py\n            tracing.py\n            __init__.py\n        testing/\n            mock_bot.py\n            __init__.py\n        tools/\n            code_tools.py\n            meta_tools.py\n            python_edit.py\n            python_editing_tools.py\n            python_execution_tool.py\n            self_tools.py\n            terminal_tools.py\n            web_tool.py\n            __init__.py\n        utils/\n            compile_bot_errors.py\n            helpers.py\n            logging.py\n            unicode_utils.py\n            __init__.py\n    docs/\n        conf.py\n    examples/\n        20_questions.py\n        bot_example.py\n        doc_checker.py\n        functional_prompt_example.py\n        lazy_example.py\n        style_fixer.py\n    tests/\n        cleanup_test_artifacts.py\n        conftest.py\n        __init__.py\n        e2e/\n            conftest.py\n            test_auto_stache.py\n            test_bot_picklability.py\n            test_branch_self_integration.py\n            test_branch_self_powershell_bug.py\n            test_branch_self_recursive.py\n            test_branch_self_tracking.py\n            test_broadcast_fp.py\n            test_broadcast_fp_cli.py\n            test_broadcast_fp_comprehensive.py\n            test_broadcast_fp_wizard_complete.py\n            test_cli.py\n            test_cli_and_while_functions.py\n            test_cli_load.py\n            test_cli_metrics_display.py\n            test_cli_prompt_functionality.py\n            test_cli_style_callback.py\n            test_cli_terminal_tool_integration.py\n            test_cli_tool_crash_bug.py\n            test_cli_tool_crash_bug_fix.py\n            test_cli_tool_display_bug.py\n            test_combine_leaves.py\n            test_issue_158_clean_unicode_string.py\n            test_keyboard_interrupt_handling.py\n            test_leaf_command.py\n            test_new_functionality.py\n            test_par_branch.py\n            test_par_branch_while_callable_fix.py\n            test_prompt_management.py\n            test_quiet_duplicate.py\n            test_quiet_fix_verification.py\n            test_specific_helper_bug.py\n            test_terminal_tools.py\n            test_wizard_debug.py\n            __init__.py\n        fixtures/\n            bot_fixtures.py\n            env_fixtures.py\n            file_fixtures.py\n            mock_fixtures.py\n            test_file_fixtures.py\n            tool_fixtures.py\n            __init__.py\n        helpers/\n            __init__.py\n        integration/\n            conftest.py\n            test_add_tools.py\n            test_basic.py\n            test_bom_encoding_issue162.py\n            test_bots.py\n            test_bot_unicode_workflow_issue162.py\n            test_code_tools.py\n            test_comprehensive_helpers.py\n            test_exporter_configuration.py\n            test_helper_preservation.py\n            test_mojibake_detection_issue162.py\n            test_observability_integration.py\n            test_prompt_naming.py\n            test_prompt_naming_fixed.py\n            test_save_load_anthropic.py\n            test_save_load_debug.py\n            test_save_load_error_handling.py\n            test_save_load_gemini.py\n            test_save_load_matrix.py\n            test_unicode_mojibake_issue162.py\n            __init__.py\n            test_powershell_tool/\n                test_terminal_timeout.py\n                test_terminal_timeout_advanced.py\n                test_terminal_tools_production_cases.py\n            test_python_edit/\n                test_all_fixes.py\n                test_async_duplicate_detection.py\n                test_class_replace.py\n                test_comprehensive_failure_cases.py\n                test_duplicate_detection_issue160.py\n                test_empty_string_deletion.py\n                test_file_level.py\n                test_file_level_fixed.py\n                test_import_dedup_fixed.py\n                test_import_duplication.py\n                test_insert.py\n                test_insert_after.py\n                test_method_replacement_bugs.py\n                test_nested.py\n                test_python_edit.py\n                test_python_edit_edge_cases.py\n                test_python_view.py\n                test_replace_behavior.py\n        test_cli/\n            test_prompt_commands.py\n        test_fp/\n            __init__.py\n        unit/\n            conftest.py\n            test_add_tools_openai.py\n            test_decorators.py\n            test_dill_serialization.py\n            test_dynamic_execution.py\n            test_functions.py\n            test_helpers.py\n            test_insert.py\n            test_mock_bot.py\n            test_nested.py\n            test_oaibot.py\n            test_patch_edit.py\n            test_pr_comment_parser.py\n            test_python_tools.py\n            test_replace_behavior.py\n            test_save_load_openai.py\n            test_self_tools.py\n            test_toolify.py\n            test_toolify_integration.py\n            test_tool_handler.py\n            test_tool_handler_comprehensive.py\n            test_web_tool.py\n            test_web_tool_integration.py\n            __init__.py\n            test_cli/\n                test_broadcast_to_leaves.py\n                test_fp_callbacks.py\n                test_fp_wizard_complete.py\n                test_recombine_removal.py\n                test_save_auto_commands.py\n            test_fp/\n                test_fp_conditions.py\n                test_par_dispatch.py\n            test_observability/\n                test_backward_compatibility.py\n                test_bot_tracing_unit.py\n                test_callbacks.py\n                test_cost_calculator.py\n                test_metrics.py\n                test_tracing_config.py\n                test_tracing_setup.py\n            test_python_edit/\n                test_functions.py"
         }
        ],
        "node_class": "AnthropicNode",
        "replies": [
         {
          "content": "~",
          "pending_results": [],
          "role": "assistant",
          "tool_calls": [
           {
            "type": "tool_use",
            "id": "toolu_01Kp2q1PdxdzimUGpmL9Hgiq",
            "name": "view",
            "input": {
             "file_path": "bots/flows/functional_prompts.py"
            }
           }
          ],
          "tool_results": [],
          "node_class": "AnthropicNode",
          "replies": [
           {
            "content": "ok",
            "pending_results": [],
            "role": "user",
            "tool_calls": [],
            "tool_results": [
             {
              "type": "tool_result",
              "tool_use_id": "toolu_01Kp2q1PdxdzimUGpmL9Hgiq",
              "content": "1:\"\"\"Functional patterns for structured bot interactions and complex reasoning.\n2:\n3:This module provides a collection of higher-level functions for orchestrating\n4:interactions in common patterns like chains, branches, and trees. These patterns\n5:enable sophisticated reasoning approaches while maintaining clear structure and\n6:reproducibility.\n7:\n8:Key Features:\n9:- Sequential Processing:\n10:    - chain(): Execute prompts in sequence\n11:    - chain_while(): Chain with iteration until condition met\n12:    - prompt_while(): Single prompt with iteration\n13:\n14:- Parallel Exploration:\n15:    - branch(): Explore multiple paths independently\n16:    - branch_while(): Branch with iteration\n17:    - par_branch(): Parallel version of branch()\n18:    - par_branch_while(): Parallel version of branch_while()\n19:\n20:- Advanced Reasoning:\n21:    - tree_of_thought(): Branch, explore, then synthesize\n22:    - prompt_for(): Dynamic prompts from data\n23:    - par_dispatch(): Compare multiple bots\n24:\n25:Common Parameters:\n26:- bot (Bot): The bot instance to use\n27:- prompts (List[Prompt]): List of prompts to process\n28:- stop_condition (Condition): Function determining when to stop iteration\n29:\n30:Common Return Values:\n31:- Response: String containing bot's response\n32:- ResponseNode: ConversationNode containing response and context\n33:\n34:Example:\n35:    >>> responses, nodes = chain(bot, [\n36:    ...     \"First, analyze the problem...\",\n37:    ...     \"Now, propose solutions...\",\n38:    ...     \"Finally, implement the best solution...\"\n39:    ... ])\n40:\"\"\"\n41:\n42:import logging\n43:import os\n44:from concurrent.futures import ThreadPoolExecutor, as_completed\n45:from typing import Any, Callable, List, Optional, Tuple, Union\n46:\n47:from bots.foundation.base import Bot, ConversationNode\n48:\n49:logger = logging.getLogger(__name__)\n50:\n51:# Type Aliases\n52:Prompt = str  # A string containing a prompt to be sent to the bot\n53:Response = str  # A string containing a bot's response\n54:PromptNode = ConversationNode  # A conversation node containing a prompt\n55:ResponseNode = ConversationNode  # A conversation node containing a response\n56:Condition = Callable[[Bot], bool]  # Function that evaluates bot state\n57:DynamicPrompt = Callable[[Bot, int], Prompt]  # Function that generates prompts from bot state and iteration\n58:ItemPrompt = Callable[[Any], Prompt]  # Function that generates prompts from an item\n59:\n60:RecombinatorFunction = Callable[\n61:    [List[Response], List[ResponseNode]], Tuple[Response, ResponseNode]\n62:]  # A function that combines multiple responses into a single response\n63:\n64:FunctionalPrompt = Callable[\n65:    [Bot, Any], Union[Tuple[Response, ResponseNode], Tuple[List[Response], List[ResponseNode]]]\n66:]  # A function that acts on a Bot and returns a response or set of responses in the form of a tuple.\n67:\n68:\n69:class conditions:\n70:    \"\"\"Predefined condition functions for controlling bot iteration.\n71:\n72:    This class provides a collection of static methods that can be used as\n73:    stop conditions in functions like prompt_while() and chain_while(). Each\n74:    condition evaluates some aspect of the bot's state to determine whether\n75:    iteration should continue.\n76:\n77:    Attributes:\n78:        No instance attributes - all methods are static\n79:\n80:    Common Usage:\n81:        >>> # Continue until bot stops using tools\n82:        >>> prompt_while(bot, prompt, stop_condition=conditions.tool_not_used)\n83:        >>>\n84:        >>> # Continue until bot says \"DONE\"\n85:        >>> chain_while(bot, prompts, stop_condition=conditions.said_DONE)\n86:\n87:    Note:\n88:        Each condition function takes a Bot instance and returns a boolean.\n89:        True typically indicates iteration should stop.\n90:    \"\"\"\n91:\n92:    @staticmethod\n93:    def said_READY(bot: Bot) -> bool:\n94:        \"\"\"Check if the bot's response contains the word 'READY'.\n95:\n96:        Use when you need to continue prompting until the bot indicates readiness.\n97:\n98:        Args:\n99:            bot (Bot): The bot to check\n100:\n101:        Returns:\n102:            bool: True if the response contains 'READY', False otherwise\n103:        \"\"\"\n104:        return \"READY\" in bot.conversation.content\n105:\n106:    @staticmethod\n107:    def five_iterations(bot: Bot):\n108:        \"\"\"Create a condition that stops after five iterations.\n109:\n110:        Use when you want to prevent infinite loops by setting an iteration limit.\n111:        Note: This requires external counter management.\n112:\n113:        Args:\n114:            max_count (int): Maximum number of iterations allowed\n115:\n116:        Returns:\n117:            Callable[[Bot], bool]: A condition function with iteration counting\n118:        \"\"\"\n119:        iteration_count = {\"count\": 0}\n120:\n121:        def condition(bot: Bot) -> bool:\n122:            iteration_count[\"count\"] += 1\n123:            return iteration_count[\"count\"] >= 5\n124:\n125:        return condition\n126:\n127:    @staticmethod\n128:    def no_new_tools_used(bot: Bot) -> bool:\n129:        \"\"\"Check if the bot used the same tools as in the previous response.\n130:\n131:        Use when you want to stop when the bot stops exploring new tool options.\n132:\n133:        Args:\n134:            bot (Bot): The bot to check\n135:\n136:        Returns:\n137:            bool: True if no new tools were used compared to previous iteration\n138:        \"\"\"\n139:        if not hasattr(bot, \"_previous_tools\"):\n140:            # First iteration - store current tools\n141:            bot._previous_tools = set()\n142:            if bot.tool_handler.requests:\n143:                for request in bot.tool_handler.requests:\n144:                    tool_name, _ = bot.tool_handler.tool_name_and_input(request)\n145:                    bot._previous_tools.add(tool_name)\n146:            return False\n147:\n148:        # Get current tools\n149:        current_tools = set()\n150:        if bot.tool_handler.requests:\n151:            for request in bot.tool_handler.requests:\n152:                tool_name, _ = bot.tool_handler.tool_name_and_input(request)\n153:                current_tools.add(tool_name)\n154:\n155:        # Check if any new tools were used\n156:        new_tools = current_tools - bot._previous_tools\n157:        bot._previous_tools = current_tools\n158:\n159:        return len(new_tools) == 0 and len(current_tools) > 0\n160:\n161:    @staticmethod\n162:    def error_in_response(bot: Bot) -> bool:\n163:        \"\"\"Check if the bot's response contains error indicators.\n164:\n165:        Use when you want to stop iteration if the bot encounters errors.\n166:\n167:        Args:\n168:            bot (Bot): The bot to check\n169:\n170:        Returns:\n171:            bool: True if the response contains error indicators\n172:        \"\"\"\n173:        content = bot.conversation.content.lower()\n174:        error_indicators = [\"error\", \"failed\", \"exception\", \"traceback\", \"syntax\"]\n175:        return any(indicator in content for indicator in error_indicators)\n176:\n177:    def tool_used(bot: Bot) -> bool:\n178:        \"\"\"Check if the bot has used any tools in its last response.\n179:\n180:        Use when you need to continue prompting until the bot uses a tool.\n181:\n182:        Args:\n183:            bot (Bot): The bot to check\n184:\n185:        Returns:\n186:            bool: True if the bot has used any tools, False otherwise\n187:        \"\"\"\n188:        return bool(bot.tool_handler.requests)\n189:\n190:    @staticmethod\n191:    def tool_not_used(bot: Bot) -> bool:\n192:        \"\"\"Check if the bot has not used any tools in its last response.\n193:\n194:        Use when you need to continue prompting until the bot stops using tools.\n195:\n196:        Args:\n197:            bot (Bot): The bot to check\n198:\n199:        Returns:\n200:            bool: True if the bot has not used any tools, False otherwise\n201:        \"\"\"\n202:        return not bool(bot.tool_handler.requests)\n203:\n204:    @staticmethod\n205:    def said_DONE(bot: Bot) -> bool:\n206:        \"\"\"Check if the bot's response contains the word 'DONE'.\n207:\n208:        Use when you need to continue prompting until the bot indicates completion.\n209:\n210:        Args:\n211:            bot (Bot): The bot to check\n212:\n213:        Returns:\n214:            bool: True if the response contains 'DONE', False otherwise\n215:        \"\"\"\n216:        return \"DONE\" in bot.conversation.content\n217:\n218:\n219:class dynamic_prompts:\n220:    \"\"\"Factory functions for creating dynamic prompts based on bot state.\n221:\n222:    This class provides methods for creating dynamic prompt functions that\n223:    can adapt based on the bot's state and iteration count.\n224:    \"\"\"\n225:\n226:    @staticmethod\n227:    def static(prompt: str) -> DynamicPrompt:\n228:        \"\"\"Create a dynamic prompt that always returns the same string.\n229:\n230:        Use this to wrap static strings so they can be used uniformly with\n231:        dynamic prompts.\n232:\n233:        Args:\n234:            prompt: The static prompt string to return\n235:\n236:        Returns:\n237:            DynamicPrompt: A function that takes (bot, iteration) and returns the prompt string\n238:\n239:        Example:\n240:            >>> continue_prompt = dynamic_prompts.static(\"ok\")\n241:            >>> prompt_while(bot, \"Start task\", continue_prompt=continue_prompt)\n242:        \"\"\"\n243:\n244:        def static_prompt_func(bot: Bot, iteration: int) -> str:\n245:            return prompt\n246:\n247:        return static_prompt_func\n248:\n249:    @staticmethod\n250:    def policy(rules: List[Tuple[Callable[[Bot, int], bool], str]], default: str = \"ok\") -> DynamicPrompt:\n251:        \"\"\"Create a dynamic prompt that selects prompts based on rules.\n252:\n253:        Evaluates rules in order and returns the prompt associated with the first\n254:        rule whose condition evaluates to True. If no rules match, returns the default.\n255:\n256:        Args:\n257:            rules: List of (condition, prompt) tuples where:\n258:                - condition: Callable[[Bot, int], bool] that takes bot and iteration\n259:                - prompt: str to return if condition is True\n260:            default: str to return if no rules match (default: \"ok\")\n261:\n262:        Returns:\n263:            DynamicPrompt: A function that takes (bot, iteration) and returns a prompt string\n264:\n265:        Example:\n266:            >>> continue_prompt = dynamic_prompts.policy(\n267:            ...     rules=[\n268:            ...         (lambda b, i: i > 5, \"You've done 5 iterations, wrap up.\"),\n269:            ...         (lambda b, i: len(b.conversation.content) > 1000, \"Please be more concise.\"),\n270:            ...     ],\n271:            ...     default=\"ok\"\n272:            ... )\n273:            >>> prompt_while(bot, \"Start task\", continue_prompt=continue_prompt)\n274:        \"\"\"\n275:\n276:        def dynamic_prompt_func(bot: Bot, iteration: int) -> str:\n277:            for condition, prompt in rules:\n278:                try:\n279:                    if condition(bot, iteration):\n280:                        return prompt\n281:                except Exception as e:\n282:                    # If condition evaluation fails, skip this rule\n283:                    logger.warning(\n284:                        \"Error evaluating policy rule %d for bot=%s iteration=%d: %s\",\n285:                        rules.index((condition, prompt)),\n286:                        getattr(bot, \"id\", \"<no-id>\"),\n287:                        iteration,\n288:                        str(e),\n289:                        exc_info=True,\n290:                    )\n291:            return default\n292:\n293:        return dynamic_prompt_func\n294:\n295:\n296:def single_prompt(\n297:    bot: Bot, prompt: Prompt, callback: Optional[Callable[[List[Response], List[ResponseNode]], None]] = None\n298:) -> Tuple[Response, ResponseNode]:\n299:    \"\"\"Execute a single prompt and return both response and conversation state.\n300:\n301:    Use when you need:\n302:    - The simplest possible bot interaction\n303:    - To capture both response and conversation state\n304:    - A building block for custom interaction patterns\n305:    - To understand the fundamental bot interaction model\n306:\n307:    This function serves as:\n308:    1. A demonstration of the basic bot interaction pattern\n309:    2. A template for more complex functional patterns\n310:    3. A utility for simple, one-shot interactions\n311:    4. A way to understand conversation node handling\n312:\n313:    Args:\n314:        bot (Bot): The bot to interact with. The bot's current conversation\n315:            state is preserved and updated with this interaction\n316:        prompt (Prompt): The prompt to send to the bot. Should be a clear,\n317:            self-contained instruction or question\n318:        callback (Optional[Callable[[List[Response], List[ResponseNode]], None]]):\n319:            A function (with arguments list[response], list[node]) which is called\n320:            after the response from the bot.\n321:\n322:    Returns:\n323:        Tuple[Response, ResponseNode]: A tuple containing:\n324:            - response (str): The bot's response text\n325:            - node (ConversationNode): Conversation node containing:\n326:                - The response\n327:                - The prompt that generated it\n328:                - Links to parent/child nodes\n329:                - Associated metadata\n330:\n331:    Examples:\n332:        >>> # Simple question and answer\n333:        >>> response, node = basic(bot,\n334:        ...     \"What is the time complexity of quicksort?\"\n335:        ... )\n336:        >>> print(response)\n337:        >>>\n338:        >>> # Tool usage\n339:        >>> response, node = basic(bot,\n340:        ...     \"Review the code in main.py\"\n341:        ... )\n342:        >>> print(node.tool_calls)  # See what tools were used\n343:        >>>\n344:        >>> # Access conversation context\n345:        >>> response, node = basic(bot, \"Analyze this.\")\n346:        >>> print(node.parent.content)  # See previous context\n347:\n348:    Implementation Notes:\n349:        - Maintains conversation tree structure\n350:        - Updates bot's current conversation state\n351:        - Preserves tool usage information\n352:        - Serves as foundation for other patterns\n353:    \"\"\"\n354:    response = bot.respond(prompt)\n355:    node = bot.conversation\n356:    if callback:\n357:        try:\n358:            callback([response], [node])\n359:        except Exception:\n360:            pass  # Don't let callback errors break the main function\n361:    return (response, node)\n362:\n363:\n364:def chain(\n365:    bot: Bot, prompt_list: List[Prompt], callback: Optional[Callable[[List[Response], List[ResponseNode]], None]] = None\n366:) -> Tuple[List[Response], List[ResponseNode]]:\n367:    \"\"\"Execute a sequence of prompts that build on each other.\n368:\n369:    Use when you need to:\n370:    - Guide a bot through a structured sequence of steps\n371:    - Build up complex reasoning through progressive stages\n372:    - Maintain context between related prompts\n373:    - Create a linear flow of thought or analysis\n374:\n375:    This is one of the most fundamental patterns, providing a way to break down\n376:    complex tasks into ordered steps where each step builds on the context and\n377:    understanding developed in previous steps.\n378:\n379:    Args:\n380:        bot (Bot): The bot to interact with. The bot maintains conversation\n381:            context throughout the chain, allowing each step to reference\n382:            and build upon previous responses\n383:        prompt_list (List[Prompt]): Ordered list of prompts to process sequentially.\n384:            For best results:\n385:            - Make prompts build progressively\n386:            - Reference previous steps when needed\n387:            - Keep a clear logical flow\n388:            - Use explicit transitions between steps\n389:        callback (Optional[Callable[[List[Response], List[ResponseNode]], None]]):\n390:            A function (with arguments list[respose], list[node]) which is called\n391:            after each response from the bot.\n392:\n393:    Returns:\n394:    Tuple[List[Response], List[ResponseNode]]: A tuple containing a list of response strings\n395:        and a list of corresponding ConversationNodes.\n396:    \"\"\"\n397:    responses = []\n398:    nodes = []\n399:    for prompt in prompt_list:\n400:        response = bot.respond(prompt)\n401:        responses.append(response)\n402:        nodes.append(bot.conversation)\n403:        if callback:\n404:            try:\n405:                callback(responses, nodes)\n406:            except Exception:\n407:                pass  # Don't let callback errors break the main function\n408:    return responses, nodes\n409:\n410:\n411:def branch(\n412:    bot: Bot, prompt_list: List[Prompt], callback: Optional[Callable[[List[Response], List[ResponseNode]], None]] = None\n413:) -> Tuple[List[Response], List[ResponseNode]]:\n414:    \"\"\"Create multiple independent conversation paths from the current state.\n415:\n416:    Use when you need to:\n417:    - Explore multiple perspectives simultaneously\n418:    - Analyze different aspects of a problem independently\n419:    - Compare different approaches without cross-influence\n420:    - Generate diverse solutions or viewpoints\n421:\n422:    This is a fundamental pattern for parallel thinking that allows exploration\n423:    of multiple lines of thought without letting them influence each other.\n424:    Each branch starts from the same context but develops independently.\n425:\n426:    Args:\n427:        bot (Bot): The bot to interact with. The bot's current conversation\n428:            state is used as the starting point for all branches, but each\n429:            branch gets its own independent context\n430:        prompts (List[Prompt]): List of prompts, each creating a separate\n431:            conversation branch. For effective branching:\n432:            - Make prompts independent of each other\n433:            - Focus each prompt on a distinct aspect\n434:            - Be explicit about the perspective or approach\n435:            - Maintain consistent depth across branches\n436:        callback (Optional[Callable[[List[Response], List[ResponseNode]], None]]):\n437:            A function (with arguments list[respose], list[node]) which is called\n438:            after each response from the bot.\n439:\n440:    Returns:\n441:        Tuple[List[Response], List[ResponseNode]]: A tuple containing:\n442:            - responses (List[Optional[str]]): List of responses, one per\n443:              branch. Failed branches contain None\n444:            - nodes (List[Optional[ConversationNode]]): List of conversation\n445:              nodes containing responses and their independent contexts.\n446:              Failed branches contain None\n447:\n448:    Examples:\n449:        >>> # Multi-perspective analysis\n450:        >>> responses, nodes = branch(bot, [\n451:        ...     \"Analyze this code from a security perspective...\",\n452:        ...     \"Analyze this code from a performance perspective...\",\n453:        ...     \"Analyze this code from a maintainability perspective...\",\n454:        ...     \"Analyze this code from a scalability perspective...\"\n455:        ... ])\n456:        >>>\n457:        >>> # Solution exploration\n458:        >>> responses, nodes = branch(bot, [\n459:        ...     \"Solve this using a recursive approach...\",\n460:        ...     \"Solve this using an iterative approach...\",\n461:        ...     \"Solve this using a dynamic programming approach...\",\n462:        ...     \"Solve this using a divide-and-conquer approach...\"\n463:        ... ])\n464:        >>>\n465:        >>> # Stakeholder perspectives\n466:        >>> responses, nodes = branch(bot, [\n467:        ...     \"Evaluate this feature from a user's perspective...\",\n468:        ...     \"Evaluate this feature from a developer's perspective...\",\n469:        ...     \"Evaluate this feature from a business perspective...\",\n470:        ...     \"Evaluate this feature from a maintenance perspective...\"\n471:        ... ])\n472:\n473:    Implementation Notes:\n474:        - Creates independent context for each branch\n475:        - Handles branch failures gracefully\n476:        - Maintains tree structure for conversation history\n477:        - Conversation is left at final prompt's response.\n478:    \"\"\"\n479:    original_conversation = bot.conversation\n480:    responses = []\n481:    nodes = []\n482:    for prompt in prompt_list:\n483:        bot.conversation = original_conversation\n484:        try:\n485:            response = bot.respond(prompt)\n486:            node = bot.conversation\n487:            if callback:\n488:                try:\n489:                    callback([response], [node])\n490:                except Exception:\n491:                    pass  # Don't let callback errors break the main function\n492:        except Exception:\n493:            response = None\n494:            node = None\n495:        finally:\n496:            responses.append(response)\n497:            nodes.append(node)\n498:    return responses, nodes\n499:\n500:\n501:def recombine(\n502:    bot: Bot, responses: List[Response], nodes: List[ResponseNode], recombinator_function: RecombinatorFunction, **kwargs\n503:) -> Tuple[Response, ResponseNode]:\n504:    \"\"\"Synthesize multiple conversation branches into a unified conclusion.\n505:\n506:    Use when you need to:\n507:    - Combine insights from parallel explorations\n508:    - Synthesize multiple perspectives into one view\n509:    - Create a summary from multiple analyses\n510:    - Resolve potentially conflicting viewpoints\n511:\n512:    This function is a key component in tree-based reasoning patterns,\n513:    typically used after branch() or as part of tree_of_thought() to\n514:    combine parallel thinking paths into a coherent conclusion.\n515:\n516:    Args:\n517:        bot (Bot): The bot instance. Currently maintained for future\n518:            extensions that might involve bot interaction during\n519:            recombination\n520:        responses (List[Response]): List of response strings from parallel\n521:            branches. Each response typically represents:\n522:            - A different perspective on the problem\n523:            - Analysis of a specific aspect\n524:            - Results from a particular approach\n525:        nodes (List[ResponseNode]): List of conversation nodes containing\n526:            the responses and their context. These nodes maintain the\n527:            full conversation history of each branch\n528:        recombinator_function (RecombinatorFunction): Custom function that\n529:            implements the synthesis logic. Must have signature:\n530:            (List[Response], List[ResponseNode]) -> Tuple[Response, ResponseNode]\n531:\n532:            The function should:\n533:            - Process all input responses\n534:            - Consider their relationships\n535:            - Resolve any conflicts\n536:            - Produce a coherent synthesis\n537:\n538:    Returns:\n539:        Tuple[Response, ResponseNode]: A tuple containing:\n540:            - response (str): The synthesized response combining insights\n541:              from all input branches\n542:            - node (ConversationNode): A new conversation node containing\n543:              the combined response and linking to all source branches\n544:\n545:    Examples:\n546:        >>> # Simple concatenation with formatting\n547:        >>> def basic_combine(responses, nodes):\n548:        ...     combined = \"\\\\n\".join(f\"- {r}\" for r in responses)\n549:        ...     return f\"Combined Insights:\\\\n{combined}\", nodes[0]\n550:        ...\n551:        >>> final_response, final_node = recombine(\n552:        ...     bot, branch_responses, branch_nodes, basic_combine\n553:        ... )\n554:        >>>\n555:        >>> # Structured synthesis with weighting\n556:        >>> def weighted_synthesis(responses, nodes):\n557:        ...     # Weight responses by confidence markers\n558:        ...     weighted = []\n559:        ...     for r in responses:\n560:        ...         confidence = r.count(\"definitely\") + r.count(\"clearly\")\n561:        ...         weighted.append((confidence, r))\n562:        ...\n563:        ...     # Sort by confidence and format\n564:        ...     sorted_insights = [r for _, r in sorted(weighted, reverse=True)]\n565:        ...     synthesis = \"Synthesis (by confidence):\\\\n\" + \"\\\\n\".join(\n566:        ...         f\"{i+1}. {r}\" for i, r in enumerate(sorted_insights)\n567:        ...     )\n568:        ...     return synthesis, nodes[0]\n569:        ...\n570:        >>> final_response, final_node = recombine(\n571:        ...     bot, branch_responses, branch_nodes, weighted_synthesis\n572:        ... )\n573:\n574:    Implementation Notes:\n575:        - Maintains conversation tree structure\n576:        - Links final node to all source branches\n577:        - Preserves full conversation history\n578:        - Updates bot's current conversation state\n579:    \"\"\"\n580:    start_point = bot.conversation\n581:    response, node = recombinator_function(responses, nodes, **kwargs)\n582:    node.parent = start_point\n583:    start_point.replies[-1] = node\n584:    bot.conversation = node\n585:    return response, node\n586:\n587:\n588:def tree_of_thought(\n589:    bot: Bot,\n590:    prompts: List[Prompt],\n591:    recombinator_function: RecombinatorFunction,\n592:    callback: Optional[Callable[[Response, ResponseNode], None]] = None,\n593:) -> Tuple[Response, ResponseNode]:\n594:    \"\"\"Implement tree-of-thought reasoning for complex problem-solving.\n595:\n596:    Use when you need the bot to:\n597:    - Break down complex problems into multiple perspectives\n598:    - Explore different aspects of a problem in parallel\n599:    - Synthesize multiple lines of thinking into a coherent solution\n600:    - Make decisions that require considering multiple factors\n601:\n602:    This function implements the tree-of-thought reasoning pattern in three phases:\n603:    1. Branch: Create parallel conversation paths for different aspects\n604:    2. Explore: Process each branch independently\n605:    3. Synthesize: Combine insights from all branches into a final response\n606:\n607:    Args:\n608:        bot (Bot): The bot to interact with\n609:        prompts (List[Prompt]): List of prompts that define different thinking\n610:            paths. Each prompt should focus on a distinct aspect or approach\n611:            to the problem. For best results, make prompts:\n612:            - Independent of each other\n613:            - Focused on specific aspects\n614:            - Clear about their perspective\n615:        recombinator_function (RecombinatorFunction): Function that synthesizes\n616:            multiple responses into a final conclusion. Must have signature:\n617:            (List[Response], List[ResponseNode]) -> Tuple[Response, ResponseNode]\n618:            The function should:\n619:            - Consider all responses\n620:            - Identify key insights\n621:            - Resolve conflicts\n622:            - Create a coherent synthesis\n623:       callback (Optional[Callable[[Response, ResponseNode], None]]):\n624:           A function called after each branch response with the individual\n625:            after each response from the bot.\n626:\n627:    Returns:\n628:        Tuple[Response, ResponseNode]: A tuple containing:\n629:            - response (str): The final synthesized response combining\n630:              insights from all branches\n631:            - node (ConversationNode): Conversation node containing the\n632:              final response, with links to all branch nodes\n633:\n634:    Examples:\n635:        >>> # Technical decision making\n636:        >>> def combine_tech_analysis(responses, nodes):\n637:        ...     insights = \"\\\\n\".join(f\"- {r}\" for r in responses)\n638:        ...     return f\"Technical Analysis:\\\\n{insights}\", nodes[0]\n639:        ...\n640:        >>> response, node = tree_of_thought(\n641:        ...     bot,\n642:        ...     [\n643:        ...         \"Analyze performance implications...\",\n644:        ...         \"Consider security aspects...\",\n645:        ...         \"Evaluate maintenance impact...\",\n646:        ...         \"Assess scalability concerns...\"\n647:        ...     ],\n648:        ...     combine_tech_analysis\n649:        ... )\n650:        >>>\n651:        >>> # Product feature evaluation\n652:        >>> def synthesize_feature(responses, nodes):\n653:        ...     aspects = dict(zip(\n654:        ...         [\"Technical\", \"Business\", \"User\"],\n655:        ...         responses\n656:        ...     ))\n657:        ...     return (\n658:        ...         f\"Feature Analysis:\\\\n\" +\n659:        ...         \"\\\\n\".join(f\"{k}: {v}\" for k,v in aspects.items()),\n660:        ...         nodes[0]\n661:        ...     )\n662:        ...\n663:        >>> response, node = tree_of_thought(\n664:        ...     bot,\n665:        ...     [\n666:        ...         \"Evaluate technical feasibility...\",\n667:        ...         \"Analyze business value...\",\n668:        ...         \"Assess user impact...\"\n669:        ...     ],\n670:        ...     synthesize_feature\n671:        ... )\n672:\n673:    Implementation Notes:\n674:        - Uses branch() internally for parallel exploration\n675:        - Maintains conversation history in a tree structure\n676:        - Final node links to all exploration branches\n677:        - All branch contexts are preserved for reference\n678:    \"\"\"\n679:    responses, nodes = branch(bot, prompts, callback=callback)\n680:    final_response = recombine(bot, responses, nodes, recombinator_function)\n681:    return final_response\n682:\n683:\n684:def prompt_while(\n685:    bot: Bot,\n686:    first_prompt: Prompt,\n687:    continue_prompt: Prompt = \"ok\",\n688:    stop_condition: Condition = conditions.tool_not_used,\n689:    callback: Optional[Callable[[List[Response], List[ResponseNode]], None]] = None,\n690:) -> Tuple[List[Response], List[ResponseNode]]:\n691:    \"\"\"Repeatedly engage a bot in a task until completion criteria are met.\n692:\n693:    Use when you need to:\n694:    - Have a bot work iteratively on a task\n695:    - Continue processing until specific criteria are met\n696:    - Maintain context across multiple iterations\n697:    - Handle tasks with unknown completion time\n698:\n699:    This is a fundamental iteration pattern that enables:\n700:    - Progressive refinement of solutions\n701:    - Exhaustive processing of complex tasks\n702:    - Self-guided task completion\n703:    - Dynamic interaction flows\n704:\n705:    Args:\n706:        bot (Bot): The bot to interact with. Maintains conversation context\n707:            across all iterations, allowing progressive improvement and\n708:            refinement\n709:        first_prompt (Prompt): The initial task prompt. Should:\n710:            - Clearly define the task\n711:            - Set expectations for completion\n712:            - Include any relevant constraints\n713:            - Specify how to indicate completion\n714:        continue_prompt (Prompt, optional): Prompt sent for each iteration\n715:            after the first. Defaults to 'ok'. Consider customizing to:\n716:            - Guide the iteration process\n717:            - Maintain task focus\n718:            - Encourage progress\n719:            - Request specific improvements\n720:        stop_condition (Condition, optional): Function that determines when\n721:            to stop iterating. Takes a Bot parameter and returns bool.\n722:            Common patterns:\n723:            - conditions.tool_not_used (default): Stop when bot stops using tools\n724:            - conditions.said_DONE: Stop when bot indicates completion\n725:            - Custom conditions for specific criteria\n726:        callback (Optional[Callable[[List[Response], List[ResponseNode]], None]]):\n727:            A function (with arguments list[respose], list[node]) which is called\n728:            after each response from the bot.\n729:\n730:    Returns:\n731:        Tuple[List[Response], List[ResponseNode]]: A tuple containing:\n732:            - responses (List[str]): All bot responses in order:\n733:                - First response to initial prompt\n734:                - All subsequent iteration responses\n735:                - Final response meeting stop condition\n736:            - nodes (List[ConversationNode]): Conversation nodes containing\n737:              responses and their cumulative context\n738:\n739:    Examples:\n740:        >>> # Code debugging with tool usage\n741:        >>> responses, nodes = prompt_while(\n742:        ...     bot,\n743:        ...     \"Debug this code. Fix all errors you find.\",\n744:        ...     continue_prompt=\"Continue debugging. Any more issues?\",\n745:        ...     stop_condition=conditions.tool_not_used\n746:        ... )\n747:        >>>\n748:        >>> # Document improvement with explicit completion\n749:        >>> responses, nodes = prompt_while(\n750:        ...     bot,\n751:        ...     \"Improve this text. Say DONE when perfect.\",\n752:        ...     continue_prompt=\"What else can be improved?\",\n753:        ...     stop_condition=conditions.said_DONE\n754:        ... )\n755:        >>>\n756:        >>> # Custom completion criteria\n757:        >>> def quality_threshold(bot: Bot) -> bool:\n758:        ...     # Stop when response contains confidence marker\n759:        ...     return \"99% confident\" in bot.conversation.content\n760:        ...\n761:        >>> responses, nodes = prompt_while(\n762:        ...     bot,\n763:        ...     \"Optimize this function until confident.\",\n764:        ...     continue_prompt=\"Continue optimization.\",\n765:        ...     stop_condition=quality_threshold\n766:        ... )\n767:\n768:    Implementation Notes:\n769:        - Maintains continuous conversation context\n770:        - Preserves all iteration responses\n771:        - Allows custom iteration control\n772:        - Supports progressive refinement\n773:        - Enables self-guided completion\n774:    \"\"\"\n775:    # Wrap static string prompts as DynamicPrompts\n776:    if not callable(continue_prompt):\n777:        continue_prompt = dynamic_prompts.static(continue_prompt)\n778:\n779:    responses = []\n780:    nodes = []\n781:    response = bot.respond(first_prompt)\n782:    responses.append(response)\n783:    nodes.append(bot.conversation)\n784:    iteration = 0\n785:    while not stop_condition(bot):\n786:        iteration += 1\n787:        prompt_text = continue_prompt(bot, iteration)\n788:        response = bot.respond(prompt_text)\n789:        responses.append(response)\n790:        nodes.append(bot.conversation)\n791:        if callback:\n792:            try:\n793:                callback(responses, nodes)\n794:            except Exception:\n795:                pass  # Don't let callback errors break the main function\n796:    return responses, nodes\n797:\n798:\n799:def prompt_for(\n800:    bot: Bot,\n801:    items: List[Any],\n802:    dynamic_prompt: ItemPrompt,\n803:    should_branch: bool = False,\n804:    callback: Optional[Callable[[List[Response], List[ResponseNode]], None]] = None,\n805:) -> Tuple[List[Response], List[ResponseNode]]:\n806:    \"\"\"Generate and process prompts dynamically from a list of items.\n807:\n808:    Use when you need to process a collection of items where each item requires\n809:    its own customized prompt. This function enables data-driven conversation\n810:    flows by combining dynamic prompt generation with either sequential or\n811:    parallel processing strategies.\n812:\n813:    Args:\n814:        bot (Bot): The bot to interact with\n815:        items (List[Any]): List of items to process. Each item will be passed\n816:            to dynamic_prompt to generate a prompt\n817:        dynamic_prompt (DynamicPrompt): Function that generates a prompt string\n818:            for each item. Must have signature: (item: Any) -> str\n819:        should_branch (bool, optional): Processing strategy flag:\n820:            - If True: Creates parallel conversation branches for each item,\n821:              preserving independent context for each response\n822:            - If False (default): Processes items sequentially in the same\n823:              conversation (i.e. a chain), maintaining cumulative context\n824:        callback (Optional[Callable[[List[Response], List[ResponseNode]], None]]):\n825:            A function (with arguments list[respose], list[node]) which is called\n826:            after each response from the bot.\n827:\n828:    Returns:\n829:        Tuple[List[Response], List[ResponseNode]]: A tuple containing:\n830:            - responses: List[str] - Bot's responses, one per input item\n831:            - nodes: List[ConversationNode] - Conversation nodes containing\n832:              the responses and their context\n833:\n834:    Example:\n835:        >>> # Define a prompt generator\n836:        >>> def review_prompt(file_path: str) -> str:\n837:        ...     return f\"Review {file_path} for security issues.\"\n838:        ...\n839:        >>> # Process multiple files in parallel branches\n840:        >>> responses, nodes = prompt_for(\n841:        ...     bot,\n842:        ...     [\"auth.py\", \"api.py\", \"data.py\"],\n843:        ...     review_prompt,\n844:        ...     should_branch=True\n845:        ... )\n846:        >>>\n847:        >>> # Process sequentially, building on previous context\n848:        >>> responses, nodes = prompt_for(\n849:        ...     bot,\n850:        ...     [\"Step 1\", \"Step 2\", \"Step 3\"],\n851:        ...     lambda step: f\"Complete {step}...\",\n852:        ...     should_branch=False\n853:        ... )\n854:\n855:    Note:\n856:        When should_branch is True, this function uses branch() internally,\n857:        allowing parallel exploration of items. When False, it uses chain(),\n858:        which maintains conversation context between items.\n859:    \"\"\"\n860:    prompts = [dynamic_prompt(item) for item in items]\n861:    if should_branch:\n862:        return branch(bot, prompts, callback)\n863:    else:\n864:        return chain(bot, prompts, callback)\n865:\n866:\n867:def chain_while(\n868:    bot: Bot,\n869:    prompt_list: List[Prompt],\n870:    stop_condition: Condition = conditions.tool_not_used,\n871:    continue_prompt: str = \"ok\",\n872:    callback: Optional[Callable[[List[Response], List[\"ResponseNode\"]], None]] = None,\n873:) -> Tuple[List[Response], List[\"ResponseNode\"]]:\n874:    \"\"\"Execute a sequence of steps where each step can iterate until complete.\n875:\n876:    Use when you need to:\n877:    - Guide a bot through ordered steps\n878:    - Allow each step to take multiple iterations\n879:    - Ensure completion criteria for each step\n880:    - Maintain context between steps and iterations\n881:\n882:    This function combines two fundamental patterns:\n883:    1. chain(): For sequential processing of steps\n884:    2. prompt_while(): For iteration within each step\n885:\n886:    The result is a powerful pattern for complex tasks where each stage\n887:    needs to reach completion before moving to the next.\n888:\n889:    Args:\n890:        bot (Bot): The bot to interact with. Maintains conversation context\n891:            across all steps and iterations\n892:        prompt_list (List[Prompt]): Ordered list of step prompts. Each prompt\n893:            should:\n894:            - Define a clear task or objective\n895:            - Include completion criteria\n896:            - Build on previous steps appropriately\n897:            - Be self-contained for iteration\n898:        stop_condition (Condition, optional): Function that determines when\n899:            each step is complete. Takes a Bot parameter and returns bool.\n900:            Common options:\n901:            - conditions.tool_not_used (default): Stop when bot stops using tools\n902:            - conditions.said_DONE: Stop when bot indicates completion\n903:            - Custom conditions for specific criteria\n904:        continue_prompt (str, optional): Prompt to send for each iteration\n905:            after the first when a step hasn't met its stop condition.\n906:            Defaults to 'ok'. Consider customizing for clearer interaction:\n907:            - \"Continue with this step...\"\n908:            - \"Keep going until complete...\"\n909:            - \"Any more improvements needed?\"\n910:        callback (Optional[Callable[[List[Response], List[ResponseNode]], None]]):\n911:            A function (with arguments list[respose], list[node]) which is called\n912:            after each response from the bot.\n913:\n914:\n915:    Returns:\n916:        Tuple[List[Response], List[ResponseNode]]: A tuple containing:\n917:            - responses (List[str]): All bot responses, including:\n918:                - Initial response for each step\n919:                - All iteration responses\n920:                - Final response for each step\n921:            - nodes (List[ConversationNode]): Conversation nodes containing\n922:              responses and their cumulative context\n923:\n924:    Examples:\n925:        >>> # Code improvement chain\n926:        >>> responses, nodes = chain_while(\n927:        ...     bot,\n928:        ...     [\n929:        ...         \"Analyze the code and list all issues...\",\n930:        ...         \"Fix each identified issue...\",\n931:        ...         \"Add tests for the changes...\",\n932:        ...         \"Document the improvements...\"\n933:        ...     ],\n934:        ...     stop_condition=conditions.said_DONE,\n935:        ...     continue_prompt=\"Continue until this step is complete...\"\n936:        ... )\n937:        >>>\n938:        >>> # Document review chain\n939:        >>> responses, nodes = chain_while(\n940:        ...     bot,\n941:        ...     [\n942:        ...         \"Review document structure and format...\",\n943:        ...         \"Check content for accuracy and clarity...\",\n944:        ...         \"Improve language and style...\",\n945:        ...         \"Add missing sections and details...\",\n946:        ...         \"Final proofreading...\"\n947:        ...     ],\n948:        ...     stop_condition=conditions.tool_not_used,\n949:        ...     continue_prompt=\"Continue reviewing...\"\n950:        ... )\n951:\n952:    Implementation Notes:\n953:        - Maintains continuous context across steps\n954:        - Each step can iterate independently\n955:        - Tool handler is cleared after completion\n956:        - All responses and iterations are preserved\n957:        - Context includes full iteration history\n958:    \"\"\"\n959:    responses = []\n960:    nodes = []\n961:    for p in prompt_list:\n962:        response = bot.respond(p)\n963:        responses.append(response)\n964:        nodes.append(bot.conversation)\n965:        while not stop_condition(bot):\n966:            response = bot.respond(continue_prompt)\n967:            responses.append(response)\n968:            nodes.append(bot.conversation)\n969:        bot.tool_handler.clear()\n970:        if callback:\n971:            try:\n972:                callback(responses, nodes)\n973:            except Exception:\n974:                pass  # Don't let callback errors break the main function\n975:    return responses, nodes\n976:\n977:\n978:def branch_while(\n979:    bot: Bot,\n980:    prompt_list: List[Prompt],\n981:    stop_condition: Condition = conditions.tool_not_used,\n982:    continue_prompt: str = \"ok\",\n983:    callback: Optional[Callable[[List[Response], List[ResponseNode]], None]] = None,\n984:) -> Tuple[List[Response], List[ResponseNode]]:\n985:    \"\"\"Create parallel conversation branches with independent iteration control.\n986:\n987:    Use when you need to explore multiple iterative processes independently,\n988:    where each process may require a different number of steps to complete.\n989:    This function combines the parallel exploration capability of branch()\n990:    with the iterative control of prompt_while(), allowing multiple\n991:    concurrent processes to run until they individually reach completion.\n992:\n993:    Args:\n994:        bot (Bot): The bot to interact with\n995:        prompt_list (List[Prompt]): Initial prompts that start each branch.\n996:            Each prompt begins an independent conversation path that can\n997:            iterate multiple times\n998:        stop_condition (Condition, optional): Function that determines when\n999:            each branch should stop iterating. Takes a Bot parameter and\n1000:            returns bool. Defaults to conditions.tool_not_used, which stops\n1001:            when the bot stops using tools\n1002:        continue_prompt (str, optional): Prompt to send for each iteration\n1003:            after the first when a branch hasn't met its stop condition.\n1004:            Defaults to 'ok'\n1005:        callback (Optional[Callable[[List[Response], List[ResponseNode]], None]]):\n1006:            A function (with arguments list[respose], list[node]) which is called\n1007:            after each response from the bot.\n1008:\n1009:    Returns:\n1010:        Tuple[List[Response], List[ResponseNode]]: A tuple containing:\n1011:            - responses: List[str] - Final responses from each branch,\n1012:              representing the last response before the stop condition was met\n1013:            - nodes: List[ConversationNode] - Conversation nodes containing\n1014:              the final responses and their full iteration history\n1015:            Note: Failed branches return (None, None) at their positions\n1016:\n1017:    Examples:\n1018:        >>> # Optimize multiple functions until they're \"DONE\"\n1019:        >>> responses, nodes = branch_while(\n1020:        ...     bot,\n1021:        ...     [\n1022:        ...         \"Optimize sort() until O(n log n) average case...\",\n1023:        ...         \"Improve search() until O(log n) worst case...\",\n1024:        ...         \"Reduce memory usage in cache() to O(n)...\"\n1025:        ...     ],\n1026:        ...     stop_condition=conditions.said_DONE,\n1027:        ...     continue_prompt=\"Continue optimization\"\n1028:        ... )\n1029:        >>>\n1030:        >>> # Process multiple files until no more tools are used\n1031:        >>> responses, nodes = branch_while(\n1032:        ...     bot,\n1033:        ...     [\n1034:        ...         \"Review and fix issues in auth.py...\",\n1035:        ...         \"Review and fix issues in api.py...\",\n1036:        ...         \"Review and fix issues in data.py...\"\n1037:        ...     ],\n1038:        ...     stop_condition=conditions.tool_not_used,\n1039:        ...     continue_prompt=\"Continue reviewing and fixing\"\n1040:        ... )\n1041:\n1042:    Note:\n1043:        Each branch maintains its own conversation context and can iterate\n1044:        a different number of times. This is useful when some tasks may\n1045:        require more steps to complete than others.\n1046:    \"\"\"\n1047:    original_conversation = bot.conversation\n1048:    responses = []\n1049:    nodes = []\n1050:    for initial_prompt in prompt_list:\n1051:        bot.conversation = original_conversation  # Reset to original state for each branch\n1052:        try:\n1053:            response = bot.respond(initial_prompt)\n1054:            while not stop_condition(bot):\n1055:                response = bot.respond(continue_prompt)\n1056:                if callback:\n1057:                    try:\n1058:                        callback([response], [bot.conversation])\n1059:                    except Exception:\n1060:                        pass  # Don't let callback errors break the main function\n1061:            node = bot.conversation\n1062:        except Exception:\n1063:            response = None\n1064:            node = None\n1065:        finally:\n1066:            responses.append(response)\n1067:            nodes.append(node)\n1068:    return responses, nodes\n1069:\n1070:\n1071:def par_branch(\n1072:    bot: Bot, prompts: List[Prompt], callback: Optional[Callable[[List[Response], List[ResponseNode]], None]] = None\n1073:) -> Tuple[List[Response], List[ResponseNode]]:\n1074:    \"\"\"Create and process multiple conversation branches in parallel.\n1075:\n1076:    Use when you need to explore multiple lines of thinking simultaneously and\n1077:    want to leverage multiple CPU cores for faster processing. This is the\n1078:    parallel version of branch(), providing the same functionality but with\n1079:    improved performance for multiple prompts.\n1080:\n1081:    Args:\n1082:        bot (Bot): The bot to interact with\n1083:        prompts (List[Prompt]): List of prompts to process in parallel\n1084:        callback (Optional[Callable[[List[Response], List[ResponseNode]], None]]):\n1085:            A function (with arguments list[respose], list[node]) which is called\n1086:            after each response from the bot.\n1087:\n1088:    Returns:\n1089:        Tuple[List[Response], List[ResponseNode]]: A tuple containing:\n1090:            - List of responses, one per prompt\n1091:            - List of conversation nodes containing those responses\n1092:            Note: Failed branches return (None, None) at their positions\n1093:\n1094:    Example:\n1095:        responses, nodes = par_branch(\n1096:            bot,\n1097:            [\n1098:                \"Analyze code structure...\",\n1099:                \"Review documentation...\",\n1100:                \"Check test coverage...\",\n1101:                \"Audit dependencies...\"\n1102:            ]\n1103:        )\n1104:\n1105:    Note:\n1106:        This function temporarily disables bot autosave and creates a temporary\n1107:        file to facilitate parallel processing. The file is cleaned up after\n1108:        completion.\n1109:    \"\"\"\n1110:\n1111:    original_autosave = bot.autosave\n1112:    original_conversation = bot.conversation\n1113:    bot.autosave = False\n1114:    temp_file = \"temp_bot.bot\"\n1115:    bot.save(temp_file)\n1116:    responses = [None] * len(prompts)\n1117:    nodes = [None] * len(prompts)\n1118:\n1119:    def process_prompt(index: int, prompt: str) -> Tuple[int, Response, ResponseNode]:\n1120:        try:\n1121:            branch_bot = Bot.load(temp_file)\n1122:            branch_bot.autosave = False\n1123:            response = branch_bot.respond(prompt)\n1124:            new_node = branch_bot.conversation\n1125:            # Don't modify original_conversation here - do it after threads complete\n1126:            # Just return the node so we can link it properly later\n1127:            return index, response, new_node\n1128:        except Exception:\n1129:            return index, None, None\n1130:\n1131:    with ThreadPoolExecutor() as executor:\n1132:        futures = [executor.submit(process_prompt, i, prompt) for i, prompt in enumerate(prompts)]\n1133:        for future in as_completed(futures):\n1134:            idx, response, new_node = future.result()\n1135:\n1136:            if new_node is not None:\n1137:                # Link the node to the original conversation after thread completes\n1138:                new_node.parent.parent = original_conversation\n1139:                original_conversation.replies.append(new_node.parent)\n1140:\n1141:                responses[idx] = response\n1142:                nodes[idx] = new_node.parent\n1143:\n1144:                # Call callback after thread completes if provided\n1145:                if callback:\n1146:                    try:\n1147:                        callback([response], [new_node])\n1148:                    except Exception:\n1149:                        pass  # Don't let callback errors break the main function\n1150:            else:\n1151:                responses[idx] = None\n1152:                nodes[idx] = None\n1153:\n1154:    bot.autosave = original_autosave\n1155:    try:\n1156:        os.remove(temp_file)\n1157:    except OSError:\n1158:        pass\n1159:    return responses, nodes\n1160:\n1161:\n1162:def par_branch_while(\n1163:    bot: Bot,\n1164:    prompt_list: List[Prompt],\n1165:    stop_condition: Condition = conditions.tool_not_used,\n1166:    continue_prompt: str = \"ok\",\n1167:    callback: Optional[Callable[[List[Response], List[ResponseNode]], None]] = None,\n1168:) -> Tuple[List[Response], List[ResponseNode]]:\n1169:    \"\"\"Execute multiple iterative conversation branches in parallel threads.\n1170:\n1171:    Use when you need to explore multiple iterative processes simultaneously\n1172:    This is the parallel processing version of branch_while(), using\n1173:    ThreadPoolExecutor to run multiple conversation branches concurrently.\n1174:\n1175:    Performance Benefits:\n1176:    - Processes multiple branches simultaneously using thread pool\n1177:    - Reduces total execution time for multiple long-running tasks\n1178:    - Especially effective when branches have similar iteration counts\n1179:\n1180:    Args:\n1181:        bot (Bot): The bot to interact with. A copy is made for each branch\n1182:            to ensure thread safety\n1183:        prompt_list (List[Prompt]): Initial prompts that start each branch.\n1184:            Each prompt begins an independent conversation path that runs\n1185:            in its own thread\n1186:        stop_condition (Condition, optional): Function that determines when\n1187:            each branch should stop iterating. Takes a Bot parameter and\n1188:            returns bool. Must be thread-safe. Defaults to\n1189:            conditions.tool_not_used\n1190:        continue_prompt (str, optional): Prompt to send for each iteration\n1191:            after the first when a branch hasn't met its stop condition.\n1192:            Defaults to 'ok'\n1193:        callback (Optional[Callable[[List[Response], List[ResponseNode]], None]]):\n1194:            A function (with arguments list[respose], list[node]) which is called\n1195:            after each response from the bot.\n1196:\n1197:    Returns:\n1198:        Tuple[List[Response], List[ResponseNode]]: A tuple containing:\n1199:            - responses: List[str] - Final responses from each branch,\n1200:              representing the last response before the stop condition was met\n1201:            - nodes: List[ConversationNode] - Conversation nodes containing\n1202:              the final responses and their full iteration history\n1203:            Note: Failed branches return (None, None) at their positions\n1204:\n1205:    Examples:\n1206:        >>> # Parallel optimization of multiple components\n1207:        >>> responses, nodes = par_branch_while(\n1208:        ...     bot,\n1209:        ...     [\n1210:        ...         \"Optimize database queries until response time < 100ms...\",\n1211:        ...         \"Reduce API latency until < 50ms...\",\n1212:        ...         \"Improve cache hit rate until > 95%...\"\n1213:        ...     ],\n1214:        ...     stop_condition=conditions.said_DONE,\n1215:        ...     continue_prompt=\"Continue optimization\"\n1216:        ... )\n1217:        >>>\n1218:        >>> # Parallel code review and fix\n1219:        >>> responses, nodes = par_branch_while(\n1220:        ...     bot,\n1221:        ...     [\n1222:        ...         \"Review and fix security issues in auth.py...\",\n1223:        ...         \"Review and fix performance in api.py...\",\n1224:        ...         \"Review and fix error handling in data.py...\"\n1225:        ...     ],\n1226:        ...     stop_condition=conditions.tool_not_used,\n1227:        ...     continue_prompt=\"Continue fixes\"\n1228:        ... )\n1229:\n1230:    Implementation Notes:\n1231:        - Uses temporary file to store bot state for thread safety\n1232:        - Disables autosave during parallel processing\n1233:        - Each branch gets its own bot instance to prevent interference\n1234:        - Conversation nodes are properly re-linked after parallel execution\n1235:        - Temporary resources are cleaned up after completion\n1236:    \"\"\"\n1237:\n1238:    original_autosave = bot.autosave\n1239:    original_conversation = bot.conversation\n1240:    bot.autosave = False\n1241:    temp_file = \"temp_bot.bot\"\n1242:    bot.save(temp_file)\n1243:    responses = [None] * len(prompt_list)\n1244:    nodes = [None] * len(prompt_list)\n1245:\n1246:    def process_branch(\n1247:        index: int, initial_prompt: str, temp_file: str, stop_condition: Condition, continue_prompt: str, use_callback: bool\n1248:    ) -> Tuple[int, Response, ResponseNode]:\n1249:        try:\n1250:            branch_bot = Bot.load(temp_file)\n1251:            branch_bot.autosave = False\n1252:            first_response = branch_bot.respond(initial_prompt)\n1253:            first_response_node = branch_bot.conversation\n1254:            response = first_response\n1255:\n1256:            # Note: callback is not used in parallel execution to avoid pickling issues\n1257:            # Callbacks should be handled after parallel execution completes\n1258:\n1259:            while not stop_condition(branch_bot):\n1260:                response = branch_bot.respond(continue_prompt)\n1261:\n1262:            # Return the final node after all iterations, not the first node\n1263:            final_node = branch_bot.conversation\n1264:\n1265:            # Return the first response node so we can link it properly later\n1266:            return index, response, first_response_node, final_node\n1267:        except Exception:\n1268:            return index, None, None, None\n1269:\n1270:    with ThreadPoolExecutor() as executor:\n1271:        # Submit all tasks with explicit parameters instead of closure\n1272:        futures = [\n1273:            executor.submit(process_branch, i, prompt, temp_file, stop_condition, continue_prompt, callback is not None)\n1274:            for i, prompt in enumerate(prompt_list)\n1275:        ]\n1276:\n1277:        for future in as_completed(futures):\n1278:            result = future.result()\n1279:            if len(result) == 4:\n1280:                idx, response, first_response_node, final_node = result\n1281:\n1282:                if first_response_node is not None and final_node is not None:\n1283:                    # Link the first node back to the original conversation\n1284:                    first_response_node.parent.parent = original_conversation\n1285:                    # And link the original conversation to the initial prompt node\n1286:                    original_conversation.replies.append(first_response_node.parent)\n1287:\n1288:                    # Store the final response and the parent of the final node\n1289:                    responses[idx] = response\n1290:                    nodes[idx] = final_node.parent\n1291:\n1292:                    # Call callback after thread completes if provided\n1293:                    if callback:\n1294:                        try:\n1295:                            callback([response], [final_node.parent])\n1296:                        except Exception:\n1297:                            pass  # Don't let callback errors break the main function\n1298:                else:\n1299:                    responses[idx] = None\n1300:                    nodes[idx] = None\n1301:\n1302:    bot.autosave = original_autosave\n1303:    try:\n1304:        os.remove(temp_file)\n1305:    except OSError:\n1306:        pass\n1307:    return responses, nodes\n1308:\n1309:\n1310:def par_dispatch(\n1311:    bot_list: List[Bot], functional_prompt: Callable[[Bot, Any], Tuple[Response, ResponseNode]], **kwargs: Any\n1312:) -> List[Tuple[Optional[Response], Optional[ResponseNode]]]:\n1313:    \"\"\"Execute a functional prompt pattern across multiple bots in parallel.\n1314:\n1315:    Use when you need to:\n1316:    - Compare how different LLM providers handle the same task\n1317:    - Test multiple bot configurations simultaneously\n1318:    - Run the same complex operation across a fleet of bots\n1319:    - Benchmark performance across different bot implementations\n1320:\n1321:    This function enables parallel processing of any functional prompt pattern\n1322:    (chain, branch, tree_of_thought, etc.) across multiple bots using a thread\n1323:    pool for concurrent execution.\n1324:\n1325:    Args:\n1326:        bot_list (List[Bot]): List of bots to process in parallel. Each bot\n1327:            can be a different type (AnthropicBot, OpenAIBot, etc.) or the\n1328:            same type with different configurations\n1329:        functional_prompt (Callable[[Bot, ...], Tuple[Response, ResponseNode]]):\n1330:            Any function from this module that takes a bot as its first\n1331:            argument. Common choices include:\n1332:            - chain: For sequential processing\n1333:            - branch: For parallel exploration\n1334:            - tree_of_thought: For complex reasoning\n1335:         **kwargs (Any): Additional arguments to pass to the functional prompt.\n1336:            These must match the signature of the chosen functional_prompt\n1337:\n1338:    Returns:\n1339:        List[Tuple[Optional[Response], Optional[ResponseNode]]]: A list with\n1340:        the same length as bot_list, where each element is either:\n1341:            - A tuple (response, node) from successful execution\n1342:            - A tuple (None, None) if that bot's execution failed\n1343:        The ordering matches the input bot_list.\n1344:\n1345:    Examples:\n1346:        >>> # Compare LLM providers on code review\n1347:        >>> results = par_dispatch(\n1348:        ...     [anthropic_bot, openai_bot, claude_bot],\n1349:        ...     chain,\n1350:        ...     prompts=[\n1351:        ...         \"Review code structure...\",\n1352:        ...         \"Identify security issues...\",\n1353:        ...         \"Suggest improvements...\"\n1354:        ...     ]\n1355:        ... )\n1356:        >>>\n1357:        >>> # Compare different temperature settings\n1358:        >>> results = par_dispatch(\n1359:        ...     [\n1360:        ...         AnthropicBot(temperature=0.1),\n1361:        ...         AnthropicBot(temperature=0.5),\n1362:        ...         AnthropicBot(temperature=0.9)\n1363:        ...     ],\n1364:        ...     tree_of_thought,\n1365:        ...     prompts=[\"Solve this complex problem...\"],\n1366:        ...     recombinator_function=my_recombinator\n1367:        ... )\n1368:        >>>\n1369:        >>> # Process and compare results\n1370:        >>> for bot, (response, node) in zip(bot_list, results):\n1371:        ...     print(f\"{bot.name} ({bot.temperature}): {response}\")\n1372:\n1373:    Implementation Notes:\n1374:        - Uses ThreadPoolExecutor for parallel processing\n1375:        - Each bot executes independently in its own thread\n1376:        - Failed executions are caught and return (None, None)\n1377:        - Order of results matches order of input bots\n1378:        - No state is shared between bot executions\n1379:    \"\"\"\n1380:    results = [None] * len(bot_list)\n1381:\n1382:    def process_bot(index: int, bot: Bot) -> Tuple[int, Tuple[Optional[Response], Optional[ResponseNode]]]:\n1383:        try:\n1384:            result = functional_prompt(bot, **kwargs)\n1385:            return index, result\n1386:        except Exception:\n1387:            return index, (None, None)\n1388:\n1389:    with ThreadPoolExecutor() as executor:\n1390:        futures = [executor.submit(process_bot, i, bot) for i, bot in enumerate(bot_list)]\n1391:        for future in as_completed(futures):\n1392:            idx, result = future.result()\n1393:            results[idx] = result\n1394:\n1395:    return results\n1396:\n1397:\n1398:def broadcast_to_leaves(\n1399:    bot: Bot,\n1400:    prompt: Prompt,\n1401:    skip: List[str],\n1402:    continue_prompt: Optional[Prompt] = None,\n1403:    stop_condition: Optional[Condition] = None,\n1404:    callback: Optional[Callable[[List[Response], List[ResponseNode]], None]] = None,\n1405:) -> Tuple[List[Response], List[ResponseNode]]:\n1406:    \"\"\"Send a prompt to all leaf nodes in parallel, with optional iteration.\"\"\"\n1407:    from concurrent.futures import ThreadPoolExecutor, as_completed\n1408:\n1409:    original_autosave = bot.autosave\n1410:    original_conversation = bot.conversation\n1411:    bot.autosave = False\n1412:    temp_file = \"temp_broadcast_bot.bot\"\n1413:    bot.save(temp_file)\n1414:\n1415:    # Find all leaf nodes starting from current position\n1416:    def find_leaves(node: ConversationNode) -> List[ConversationNode]:\n1417:        \"\"\"Recursively find all leaf nodes from the given node.\"\"\"\n1418:        if not node.replies:\n1419:            return [node]\n1420:        leaves = []\n1421:        for reply in node.replies:\n1422:            leaves.extend(find_leaves(reply))\n1423:        return leaves\n1424:\n1425:    all_leaves = find_leaves(bot.conversation)\n1426:\n1427:    # Filter out skipped leaves based on labels\n1428:    target_leaves = []\n1429:    for leaf in all_leaves:\n1430:        should_skip = False\n1431:        if hasattr(leaf, \"labels\"):\n1432:            for label in leaf.labels:\n1433:                if label in skip:\n1434:                    should_skip = True\n1435:                    break\n1436:        if not should_skip:\n1437:            target_leaves.append(leaf)\n1438:\n1439:    responses = [None] * len(target_leaves)\n1440:    nodes = [None] * len(target_leaves)\n1441:\n1442:    def process_leaf(index: int, leaf: ConversationNode):\n1443:        \"\"\"Process a single leaf node with optional iteration in parallel.\"\"\"\n1444:        try:\n1445:            leaf_bot = Bot.load(temp_file)\n1446:            leaf_bot.autosave = False\n1447:            leaf_bot.conversation = leaf\n1448:            response = leaf_bot.respond(prompt)\n1449:            if continue_prompt is not None and stop_condition is not None:\n1450:                while not stop_condition(leaf_bot):\n1451:                    response = leaf_bot.respond(continue_prompt)\n1452:                    if callback:\n1453:                        try:\n1454:                            callback([response], [leaf_bot.conversation])\n1455:                        except Exception:\n1456:                            pass\n1457:            elif callback:\n1458:                try:\n1459:                    callback([response], [leaf_bot.conversation])\n1460:                except Exception:\n1461:                    pass\n1462:            final_node = leaf_bot.conversation\n1463:            final_node.parent.parent = original_conversation\n1464:            original_conversation.replies.append(final_node.parent)\n1465:            return index, response, final_node.parent\n1466:        except Exception:\n1467:            return index, None, None\n1468:\n1469:    # Process all leaves in parallel\n1470:    with ThreadPoolExecutor() as executor:\n1471:        futures = [executor.submit(process_leaf, i, leaf) for i, leaf in enumerate(target_leaves)]\n1472:        for future in as_completed(futures):\n1473:            idx, response, node = future.result()\n1474:            responses[idx] = response\n1475:            nodes[idx] = node\n1476:\n1477:    # Restore bot state\n1478:    bot.autosave = original_autosave\n1479:    bot.conversation = original_conversation\n1480:    try:\n1481:        os.remove(temp_file)\n1482:    except OSError:\n1483:        pass\n1484:    return responses, nodes\n1485:\n1486:\n1487:def broadcast_fp(\n1488:    bot: Bot, functional_prompt: FunctionalPrompt, skip: List[str] = None, **kwargs: Any\n1489:) -> Tuple[List[Response], List[ResponseNode]]:\n1490:    \"\"\"Execute a functional prompt on all leaf nodes in parallel.\n1491:\n1492:    Use when you need to:\n1493:    - Apply the same functional prompt pattern to all conversation endpoints\n1494:    - Process multiple conversation branches with the same complex operation\n1495:    - Gather results from all leaves using sophisticated prompting patterns\n1496:    - Scale functional prompt patterns across conversation trees\n1497:\n1498:    This function finds all leaf nodes from the current conversation position\n1499:    and executes the specified functional prompt on each leaf independently\n1500:    in parallel threads.\n1501:\n1502:    Args:\n1503:        bot (Bot): The bot to interact with\n1504:        functional_prompt (FunctionalPrompt): Any functional prompt function\n1505:            from this module (chain, branch, tree_of_thought, etc.)\n1506:        skip (List[str], optional): List of labels to skip. Leaves with any\n1507:            of these labels will not be processed. Defaults to empty list.\n1508:        **kwargs: Additional arguments to pass to the functional prompt.\n1509:            These must match the signature of the chosen functional_prompt\n1510:\n1511:    Returns:\n1512:        Tuple[List[Response], List[ResponseNode]]: A tuple containing:\n1513:            - responses: List of responses from each leaf (None for failed/skipped)\n1514:            - nodes: List of conversation nodes from each leaf (None for failed/skipped)\n1515:\n1516:    Examples:\n1517:        >>> # Chain prompts on all leaves\n1518:        >>> responses, nodes = broadcast_fp(\n1519:        ...     bot,\n1520:        ...     chain,\n1521:        ...     prompts=[\"Analyze this...\", \"Summarize findings...\"]\n1522:        ... )\n1523:        >>>\n1524:        >>> # Tree of thought on all leaves\n1525:        >>> responses, nodes = broadcast_fp(\n1526:        ...     bot,\n1527:        ...     tree_of_thought,\n1528:        ...     prompts=[\"Consider approach A...\", \"Consider approach B...\"],\n1529:        ...     recombinator_function=my_recombinator\n1530:        ... )\n1531:        >>>\n1532:        >>> # Skip certain labeled leaves\n1533:        >>> responses, nodes = broadcast_fp(\n1534:        ...     bot,\n1535:        ...     single_prompt,\n1536:        ...     skip=[\"draft\", \"incomplete\"],\n1537:        ...     prompt=\"Finalize this work...\"\n1538:        ... )\n1539:    \"\"\"\n1540:    from concurrent.futures import ThreadPoolExecutor, as_completed\n1541:\n1542:    if skip is None:\n1543:        skip = []\n1544:\n1545:    original_autosave = bot.autosave\n1546:    original_conversation = bot.conversation\n1547:    bot.autosave = False\n1548:    temp_file = \"temp_broadcast_fp_bot.bot\"\n1549:    bot.save(temp_file)\n1550:\n1551:    # Find all leaf nodes starting from current position\n1552:    def find_leaves(node: ConversationNode) -> List[ConversationNode]:\n1553:        \"\"\"Recursively find all leaf nodes from the given node.\"\"\"\n1554:        if not node.replies:\n1555:            return [node]\n1556:        leaves = []\n1557:        for reply in node.replies:\n1558:            leaves.extend(find_leaves(reply))\n1559:        return leaves\n1560:\n1561:    all_leaves = find_leaves(bot.conversation)\n1562:\n1563:    # Filter out skipped leaves based on labels\n1564:    target_leaves = []\n1565:    for leaf in all_leaves:\n1566:        should_skip = False\n1567:        if hasattr(leaf, \"labels\"):\n1568:            for label in leaf.labels:\n1569:                if label in skip:\n1570:                    should_skip = True\n1571:                    break\n1572:        if not should_skip:\n1573:            target_leaves.append(leaf)\n1574:\n1575:    responses = [None] * len(target_leaves)\n1576:    nodes = [None] * len(target_leaves)\n1577:\n1578:    def process_leaf(index: int, leaf: ConversationNode):\n1579:        \"\"\"Process a single leaf node with the functional prompt.\"\"\"\n1580:        try:\n1581:            leaf_bot = Bot.load(temp_file)\n1582:            leaf_bot.autosave = False\n1583:            leaf_bot.conversation = leaf\n1584:\n1585:            # Execute the functional prompt on this leaf\n1586:            result = functional_prompt(leaf_bot, **kwargs)\n1587:\n1588:            # Handle different return types from functional prompts\n1589:            if isinstance(result, tuple) and len(result) == 2:\n1590:                if isinstance(result[0], list):\n1591:                    # Multiple responses (like from chain, branch)\n1592:                    final_response = result[0][-1] if result[0] else None\n1593:                    final_node = result[1][-1] if result[1] else None\n1594:                else:\n1595:                    # Single response (like from single_prompt, tree_of_thought)\n1596:                    final_response = result[0]\n1597:                    final_node = result[1]\n1598:            else:\n1599:                final_response = None\n1600:                final_node = None\n1601:\n1602:            if final_node:\n1603:                final_node.parent.parent = original_conversation\n1604:                original_conversation.replies.append(final_node.parent)\n1605:\n1606:            return index, final_response, final_node.parent if final_node else None\n1607:        except Exception:\n1608:            return index, None, None\n1609:\n1610:    # Process all leaves in parallel\n1611:    with ThreadPoolExecutor() as executor:\n1612:        futures = [executor.submit(process_leaf, i, leaf) for i, leaf in enumerate(target_leaves)]\n1613:        for future in as_completed(futures):\n1614:            idx, response, node = future.result()\n1615:            responses[idx] = response\n1616:            nodes[idx] = node\n1617:\n1618:    # Restore bot state\n1619:    bot.autosave = original_autosave\n1620:    bot.conversation = original_conversation\n1621:    try:\n1622:        os.remove(temp_file)\n1623:    except OSError:\n1624:        pass\n1625:\n1626:    return responses, nodes"
             }
            ],
            "node_class": "AnthropicNode",
            "replies": [
             {
              "content": "Great! I've read both the README.md and functional_prompts.py. I now understand the framework:\n\n**Key Concepts:**\n- **bots** is an agent framework that represents conversations as tree structures\n- Bots can use tools (Python functions) to interact with the system\n- The framework supports branching conversations, context management, and saving/loading bot states\n- **functional_prompts.py** provides higher-order functions for orchestrating bot interactions in patterns like chains, branches, and trees\n\n**Functional Prompts Available:**\n- `single_prompt` - basic single interaction\n- `chain` - sequential prompts building on each other\n- `branch` - parallel independent conversation paths\n- `prompt_while` - iterate until a condition is met\n- `chain_while` - chain with iteration per step\n- `branch_while` - parallel branches with iteration\n- `par_branch` / `par_branch_while` - parallel versions using threads\n- `tree_of_thought` - branch, explore, then synthesize\n- `prompt_for` - dynamic prompts from data\n- `par_dispatch` - compare multiple bots\n- `broadcast_to_leaves` / `broadcast_fp` - apply prompts to all leaf nodes\n\n**Namshubs** (as referenced in your greeting) appear to be specialized prompts or instructions for bots. Based on the Snow Crash reference, these would be powerful \"word programs\" that directly affect how bots behave.\n\nI'm ready to help you write namshubs for other bots! What kind of namshubs would you like me to create? Should I:\n1. Create new functional prompt patterns?\n2. Write specialized system prompts for specific bot behaviors?\n3. Create condition functions or dynamic prompt generators?\n4. Something else entirely?\n\nWhat's your vision for these namshubs?",
              "pending_results": [],
              "role": "assistant",
              "tool_calls": [],
              "tool_results": [],
              "node_class": "AnthropicNode",
              "replies": [
               {
                "content": "Here's what a namshub should be: 1) a python file comprising a) a single plain-text / comment description of overall goal/task, and b) a single functional prompt which acts on a bot that takes it through a workflow (optionally, with _helper functions). The eventual goal is to create a tool in self_tools.py, 'invoke,' which will allow a bot to select a namshub to run on itself. A namshub should be able to operate on different bots. A namshub may update system prompts and temporarily overwite the bot's toolkit. Please 'skim' base.py::Bots by using a low-linecount output.",
                "pending_results": [],
                "role": "user",
                "tool_calls": [],
                "tool_results": [],
                "node_class": "AnthropicNode",
                "replies": [
                 {
                  "content": "~",
                  "pending_results": [],
                  "role": "assistant",
                  "tool_calls": [
                   {
                    "type": "tool_use",
                    "id": "toolu_018cGvfEhYBnqvEZLEUWePf9",
                    "name": "python_view",
                    "input": {
                     "target_scope": "bots/foundation/base.py",
                     "max_lines": "100"
                    }
                   }
                  ],
                  "tool_results": [],
                  "node_class": "AnthropicNode",
                  "replies": [
                   {
                    "content": "You can replace a bot's toolkit by declaring a fresh bot, adding tools, and then swapping the tool handler (and then swapping it back at the end). Take a look at examples/ -- 20_questions.py shows how to use a dynamic prompt in a functional_prompt. doc_checker.py shows how documentation can be done in parallel. style_fixer.py is similar, doing linting in parallel. Read all these files.",
                    "pending_results": [],
                    "role": "user",
                    "tool_calls": [],
                    "tool_results": [
                     {
                      "type": "tool_result",
                      "tool_use_id": "toolu_018cGvfEhYBnqvEZLEUWePf9",
                      "content": "import ast\nimport copy\nimport hashlib\n# ... 20 more imports ...\n\ndef load(filepath: str) -> \"Bot\":\n    ...\n\nclass Engines(str, Enum):\n    def get(name: str) -> Optional[\"Engines\"]:\n    def get_bot_class(model_engine: \"Engines\") -> Type[\"Bot\"]:\n    def get_conversation_node_class(class_name: str) -> Type[\"ConversationNode\"]:\n\nclass ConversationNode:\n    def __init__(\n    def tool_results(self):\n    def tool_results(self, value):\n    # ... 13 more methods ...\n\nclass ModuleContext:\n\nclass ToolHandlerError(Exception):\n\nclass ToolNotFoundError(ToolHandlerError):\n\nclass ModuleLoadError(ToolHandlerError):\n\nclass ToolHandler(ABC):\n    def __init__(self):\n    def _clean_decorator_source(source):\n    def _clean_function_source(source):\n    # ... 43 more methods ...\n\nclass Mailbox(ABC):\n    def __init__(self):\n    def log_message(self, message: str, direction: str) -> None:\n    def send_message(self, bot: \"Bot\") -> Dict[str, Any]:\n    # ... 4 more methods ...\n\nclass Bot(ABC):\n    def __init__(\n    def respond(self, prompt: str, role: str = \"user\") -> str:\n    def _respond_impl(self, prompt: str, role: str = \"user\") -> str:\n    # ... 12 more methods ...\n"
                     }
                    ],
                    "node_class": "AnthropicNode",
                    "replies": [
                     {
                      "content": "~",
                      "pending_results": [],
                      "role": "assistant",
                      "tool_calls": [
                       {
                        "type": "tool_use",
                        "id": "toolu_01Fjp7uaXA8xmafhKVd9cChC",
                        "name": "view",
                        "input": {
                         "file_path": "examples/20_questions.py"
                        }
                       },
                       {
                        "type": "tool_use",
                        "id": "toolu_01BWwrujATVnBmTWbWN9DmHM",
                        "name": "view",
                        "input": {
                         "file_path": "examples/doc_checker.py"
                        }
                       },
                       {
                        "type": "tool_use",
                        "id": "toolu_01KFuH8FmvUvGv1XoMJvWdti",
                        "name": "view",
                        "input": {
                         "file_path": "examples/style_fixer.py"
                        }
                       }
                      ],
                      "tool_results": [],
                      "node_class": "AnthropicNode",
                      "replies": [
                       {
                        "content": "ok",
                        "pending_results": [],
                        "role": "user",
                        "tool_calls": [],
                        "tool_results": [
                         {
                          "type": "tool_result",
                          "tool_use_id": "toolu_01Fjp7uaXA8xmafhKVd9cChC",
                          "content": "1:import time\n2:\n3:from bots import AnthropicBot, Engines\n4:from bots.flows.functional_prompts import prompt_while\n5:\n6:\n7:def main():\n8:\n9:    word = input(\"Pick a thing: \")\n10:\n11:    guesser_bot = AnthropicBot(\n12:        model_engine=Engines.CLAUDE45_SONNET,\n13:        max_tokens=500,\n14:        temperature=1.0,\n15:        autosave=False,\n16:    )\n17:\n18:    p1 = \"\"\"\n19:    We're going to play a game of 20 questions. I'll think of a thing, and\n20:    you ask me one question per reply. I'll answer with yes, no, sometimes,\n21:    'I don't know', or let you know if you get it. Format your reply as\n22:    \"iteration: question\". Please ask your first question.\n23:    \"\"\"\n24:\n25:    def should_stop(bot):\n26:        # Check if parent and parent.parent exist before accessing content\n27:        if bot.conversation.parent and bot.conversation.parent.parent and bot.conversation.parent.parent.content:\n28:            return word in bot.conversation.parent.parent.content or bot.conversation._node_count() > 50\n29:        # Also check node count even if parent chain doesn't exist\n30:        return bot.conversation._node_count() > 50\n31:\n32:    def print_callback(responses, nodes):\n33:        print()\n34:        print()\n35:        print(\"Guesser: \" + responses[-2])\n36:        time.sleep(0.800)  # Reduces jarringness\n37:        print()\n38:        print()\n39:        print(\"Judge: \" + nodes[-1].parent.content)\n40:\n41:    def haiku_prompt(word, question):\n42:        return (\n43:            f\"You're a 20 questions judge. Answer with yes, no, sometimes, \"\n44:            f\"'I don't know,' 'you got it!', or 'It was '{word}''. \"\n45:            f\"Do not say anything else. Do not explain your reasoning. You are the arbiter. \"\n46:            f\"Here is what you're judging: the thing is '{word}'. The question is '{question}'\"\n47:        )\n48:\n49:    def user_prompt(bot, iteration):\n50:        if iteration > 22:\n51:            return \"i win!\"\n52:        else:\n53:            # make a new judge every time.\n54:            judge_bot = AnthropicBot(\n55:                model_engine=Engines.CLAUDE35_HAIKU,\n56:                max_tokens=12,\n57:                temperature=0,\n58:                autosave=False,\n59:                enable_tracing=False,\n60:            )\n61:            return judge_bot.respond(haiku_prompt(word, bot.conversation.content))\n62:\n63:    prompt_while(\n64:        guesser_bot,\n65:        p1,\n66:        continue_prompt=user_prompt,\n67:        stop_condition=should_stop,\n68:        callback=print_callback,\n69:    )\n70:\n71:\n72:if __name__ == \"__main__\":\n73:    main()"
                         },
                         {
                          "type": "tool_result",
                          "tool_use_id": "toolu_01BWwrujATVnBmTWbWN9DmHM",
                          "content": "1:\"\"\"Automated documentation review and improvement system.\n2:Use this module when you need to automatically review and improve code-level\n3:documentation across a Python project using LLM-powered bots.\n4:The module:\n5:1. Finds all Python files in the project (excluding tools and test directories)\n6:2. Creates multiple bots to review documentation in parallel\n7:3. Uses chain_while to ensure thorough documentation review\n8:4. Makes direct improvements to documentation using Python editing tools\n9:NOTE: This is an expensive operation. For a project this size, expect $20 - $40\n10:in api costs\n11:\"\"\"\n12:\n13:import os\n14:import textwrap\n15:from typing import List, Tuple\n16:\n17:from bots.flows import functional_prompts as fp\n18:from bots.foundation.anthropic_bots import AnthropicBot\n19:from bots.foundation.base import Bot, ConversationNode, Engines\n20:from bots.tools import code_tools, python_editing_tools\n21:\n22:\n23:def find_python_files(\n24:    start_path: str,\n25:    exclude_list: List[str] = [],\n26:) -> List[str]:\n27:    \"\"\"Recursively find all Python files in a directory with exclusions.\n28:    Use when you need to gather Python files for documentation review while\n29:    excluding tool-related files and specific directories that don't need\n30:    documentation review.\n31:    Parameters:\n32:        start_path (str): Root directory to start search from. Should be the\n33:            project root.\n34:        exclude_list (List[str]): list of subdirectory names to exclude from\n35:            search. (default: [])\n36:    Returns:\n37:        List[str]: List of absolute paths to Python files that should be\n38:            reviewed\n39:    Excludes:\n40:        - tools and files with 'tool' in the name\n41:        - issue103 directory\n42:        - project_tree directory\n43:        - benbuzz790 directory\n44:        - private_tests directory\n45:    \"\"\"\n46:    excluded_dirs = exclude_list\n47:    python_files = []\n48:    for root, dirs, files in os.walk(start_path):\n49:        dirs[:] = [d for d in dirs if d not in excluded_dirs]\n50:        for file in files:\n51:            if file.endswith(\".py\"):\n52:                python_files.append(os.path.join(root, file))\n53:    return python_files\n54:\n55:\n56:def create_doc_review_bot(num: int) -> Bot:\n57:    \"\"\"Create and configure a bot specialized for documentation review.\n58:    Use when you need to create a new documentation review bot instance with\n59:    appropriate tools and context for reviewing Python documentation.\n60:    Parameters:\n61:        num (int): Unique identifier for the bot instance, used in naming\n62:    Returns:\n63:        Bot: Configured AnthropicBot instance with:\n64:            - Documentation specialist role\n65:            - Code review tools\n66:            - Python editing tools\n67:            - Appropriate system message\n68:    \"\"\"\n69:    bot = AnthropicBot(\n70:        model_engine=Engines.CLAUDE37_SONNET_20250219,\n71:        temperature=0.2,\n72:        name=f\"DocReviewer{num}\",\n73:        role=\"Documentation Specialist\",\n74:        role_description=\"Reviews documentation for python files\",\n75:        autosave=False,\n76:    )\n77:    bot.add_tools(code_tools)\n78:    bot.add_tools(python_editing_tools)\n79:    bot.set_system_message(\n80:        \"You are an expert in Python documentation standards and best \"\n81:        \"practices. Your task is to review and improve code documentation \"\n82:        \"using Python's standard documentation patterns including type hints, \"\n83:        \"and docstrings. You do not change code or add features, you strictly \"\n84:        \"document. When you find docs lacking, use the available tools to fix \"\n85:        \"them directly.\"\n86:    )\n87:    return bot\n88:\n89:\n90:def review_file_documentation(\n91:    bot: Bot,\n92:) -> Tuple[List[str], List[ConversationNode]]:\n93:    \"\"\"Execute a thorough documentation review process for a Python file.\n94:    Use when you need to systematically review and improve documentation in a\n95:    Python file using a chain of prompts and automated fixes.\n96:    Parameters:\n97:        bot (Bot): Configured documentation review bot that has been\n98:            initialized with a target file path in its conversation context\n99:    Returns:\n100:        Tuple[List[str], List[ConversationNode]]:\n101:            - List of responses from the documentation review process\n102:            - List of conversation nodes tracking the review history\n103:    Note:\n104:        The bot must be initialized with a TARGET FILE path before calling\n105:        this function. The review checks for:\n106:        1. Module-level docstring\n107:        2. Class docstrings\n108:        3. Method/function docstrings with parameters and return types\n109:    \"\"\"\n110:    prompts = [\n111:        \"First, let's read the project context to understand documentation \"\n112:        \"standards. Please read bot_context.txt and README.md.\",\n113:        (\"Now, let's examine the TARGET FILE. Use the view tool to \" \"read this file.\"),\n114:        textwrap.dedent(\n115:            \"\"\"\n116:                    Review the file's documentation and make improvements\n117:                    where needed. For each issue you find, use the appropriate\n118:                    tools to fix it directly. Check for:\n119:                    1. Module-level docstring:\n120:                    - Clear description of the module's purpose\n121:                    2. Class docstrings:\n122:                    - Class purpose and behavior\n123:                    - Important attributes\n124:                    3. Method/function docstrings:\n125:                    - Clear description of what the function does\n126:                    - All parameters documented with types\n127:                    - Return value documented with type\n128:                    \"\"\"\n129:        ),\n130:        (\"Review the TARGET FILE one final time to ensure all \" \"documentation is complete and consistent.\"),\n131:    ]\n132:    return fp.chain_while(\n133:        bot,\n134:        prompts,\n135:        stop_condition=fp.conditions.tool_not_used_debug,\n136:        continue_prompt=\"ok\",\n137:    )\n138:\n139:\n140:def main():\n141:    \"\"\"Coordinate parallel documentation review across all Python files.\n142:    Use when you need to execute a full project documentation review that:\n143:    1. Identifies all relevant Python files\n144:    2. Creates parallel bot instances\n145:    3. Executes documentation review for each file\n146:    4. Reports progress\n147:    \"\"\"\n148:    project_root = os.path.abspath(os.path.join(os.path.dirname(__file__), \"..\", \"..\"))\n149:    python_files = find_python_files(project_root)\n150:    print(f\"Found {len(python_files)} Python files to review\")\n151:    for file in python_files:\n152:        print(f\"- {file}\")\n153:    bots = [create_doc_review_bot(n) for n, _ in enumerate(python_files)]\n154:    for bot, file in zip(bots, python_files):\n155:        bot.respond(\n156:            f\"NOTE: The TARGET FILE is {file}. Respond with exclusively 'ok' \"\n157:            f\"if you understand. Further instructions are incoming.\"\n158:        )\n159:    fp.par_dispatch(bots, review_file_documentation)\n160:\n161:\n162:if __name__ == \"__main__\":\n163:    main()"
                         },
                         {
                          "type": "tool_result",
                          "tool_use_id": "toolu_01KFuH8FmvUvGv1XoMJvWdti",
                          "content": "1:\"\"\"Automated code style fixing system for CI/CD compliance for bots.\n2:Use this module when you need to automatically fix code style issues across a\n3:Python project to ensure CI/CD pipeline compliance using LLM-powered bots.\n4:The module:\n5:1. Finds all Python files in the project (excluding .gitignore patterns)\n6:2. Pre-filters to only include files that fail style checks\n7:3. Creates multiple bots to fix style issues in parallel\n8:4. Uses par_branch_while to ensure thorough style fixing\n9:5. Makes direct improvements using terminal tools and style formatters\n10:This ensures all files pass Black, isort, flake8, and other style checks in\n11:the CI/CD pipeline.\n12:\"\"\"\n13:\n14:import os\n15:import subprocess\n16:import textwrap\n17:from typing import List, Tuple\n18:\n19:from bots.flows import functional_prompts as fp\n20:from bots.foundation.anthropic_bots import AnthropicBot\n21:from bots.foundation.base import Bot, ConversationNode, Engines\n22:\n23:\n24:def is_gitignored(file_path: str, project_root: str) -> bool:\n25:    \"\"\"Check if a file is ignored by git.\n26:    Use when you need to determine if a file should be excluded from processing\n27:    based on .gitignore rules.\n28:    Parameters:\n29:        file_path (str): Path to the file to check\n30:        project_root (str): Root directory of the git repository\n31:    Returns:\n32:        bool: True if file is gitignored, False otherwise\n33:    \"\"\"\n34:    try:\n35:        result = subprocess.run(\n36:            [\"git\", \"check-ignore\", file_path],\n37:            cwd=project_root,\n38:            capture_output=True,\n39:            text=True,\n40:            encoding=\"utf-8\",\n41:        )\n42:        return result.returncode == 0\n43:    except (subprocess.SubprocessError, FileNotFoundError):\n44:        return False\n45:\n46:\n47:def find_python_files(start_path: str) -> List[str]:\n48:    \"\"\"Recursively find all Python files not in .gitignore.\n49:    Use when you need to gather Python files for style fixing while respecting\n50:    git ignore patterns and excluding files that shouldn't be processed.\n51:    Parameters:\n52:        start_path (str): Root directory to start search from. Should be the\n53:                         project root.\n54:    Returns:\n55:        List[str]: List of absolute paths to Python files that should be\n56:                  style-fixed\n57:    \"\"\"\n58:    python_files = []\n59:    for root, dirs, files in os.walk(start_path):\n60:        for file in files:\n61:            if file.endswith(\".py\"):\n62:                file_path = os.path.join(root, file)\n63:                if not is_gitignored(file_path, start_path):\n64:                    python_files.append(file_path)\n65:    return python_files\n66:\n67:\n68:def passes_style_checks(file_path: str, project_root: str) -> bool:\n69:    \"\"\"Check if a Python file passes all style checks.\n70:    Use when you need to determine if a file already complies with CI/CD\n71:    style requirements and can be skipped from processing.\n72:    Parameters:\n73:        file_path (str): Absolute path to the Python file to check\n74:        project_root (str): Root directory of the project\n75:    Returns:\n76:        bool: True if file passes all style checks, False if it needs fixing\n77:    \"\"\"\n78:    rel_path = os.path.relpath(file_path, project_root)\n79:    original_cwd = os.getcwd()\n80:\n81:    try:\n82:        # Change to project root for consistent tool execution\n83:        os.chdir(project_root)\n84:\n85:        # Check Black formatting\n86:        try:\n87:            black_result = subprocess.run(\n88:                [\"python\", \"-m\", \"black\", \"--check\", rel_path],\n89:                capture_output=True,\n90:                text=True,\n91:                encoding=\"utf-8\",\n92:                timeout=30,\n93:            )\n94:            if black_result.returncode != 0:\n95:                return False\n96:        except (subprocess.TimeoutExpired, Exception):\n97:            return False\n98:\n99:        # Check isort formatting\n100:        try:\n101:            isort_result = subprocess.run(\n102:                [\"python\", \"-m\", \"isort\", \"--check-only\", rel_path],\n103:                capture_output=True,\n104:                text=True,\n105:                encoding=\"utf-8\",\n106:                timeout=30,\n107:            )\n108:            if isort_result.returncode != 0:\n109:                return False\n110:        except (subprocess.TimeoutExpired, Exception):\n111:            return False\n112:\n113:        # Check flake8 linting\n114:        try:\n115:            flake8_result = subprocess.run(\n116:                [\"python\", \"-m\", \"flake8\", rel_path],\n117:                capture_output=True,\n118:                text=True,\n119:                encoding=\"utf-8\",\n120:                timeout=30,\n121:            )\n122:            if flake8_result.returncode != 0:\n123:                return False\n124:        except (subprocess.TimeoutExpired, Exception):\n125:            return False\n126:\n127:        return True\n128:\n129:    finally:\n130:        # Always restore original working directory\n131:        os.chdir(original_cwd)\n132:\n133:\n134:def find_files_needing_style_fixes(\n135:    start_path: str,\n136:) -> Tuple[List[str], List[str]]:\n137:    \"\"\"Find Python files that need style fixing, filtering out compliant ones.\n138:    Use when you need to efficiently identify only the files that require\n139:    style fixing, avoiding unnecessary processing of already-compliant files.\n140:    Parameters:\n141:        start_path (str): Root directory to start search from. Should be the\n142:                         project root.\n143:    Returns:\n144:        Tuple[List[str], List[str]]:\n145:            - List of absolute paths to Python files that need style fixing\n146:            - List of absolute paths to Python files that already pass checks\n147:    \"\"\"\n148:    all_python_files = find_python_files(start_path)\n149:    files_needing_fixes = []\n150:    files_already_passing = []\n151:\n152:    print(f\"Pre-filtering {len(all_python_files)} Python files...\")\n153:\n154:    for file_path in all_python_files:\n155:        rel_path = os.path.relpath(file_path, start_path)\n156:        print(f\"Checking {rel_path}...\", end=\" \")\n157:\n158:        if passes_style_checks(file_path, start_path):\n159:            print(\"\u2713 PASSES\")\n160:            files_already_passing.append(file_path)\n161:        else:\n162:            print(\"\u2717 NEEDS FIXING\")\n163:            files_needing_fixes.append(file_path)\n164:\n165:    return files_needing_fixes, files_already_passing\n166:\n167:\n168:def check_file_cicd(file_path: str, project_root: str) -> str:\n169:    \"\"\"Run CI/CD style checks on a specific Python file.\n170:    Parameters:\n171:        file_path (str): Absolute path to the Python file to check\n172:        project_root (str): Root directory of the project\n173:    Returns:\n174:        str: Detailed report of all style issues found, or confirmation if\n175:             file passes all checks\n176:    \"\"\"\n177:    rel_path = os.path.relpath(file_path, project_root)\n178:    results = []\n179:    original_cwd = os.getcwd()\n180:    try:\n181:        # Change to project root for consistent tool execution\n182:        os.chdir(project_root)\n183:\n184:        # Run Black check\n185:        results.append(\"=== BLACK CHECK ===\")\n186:        try:\n187:            black_result = subprocess.run(\n188:                [\"python\", \"-m\", \"black\", \"--check\", \"--diff\", rel_path],\n189:                capture_output=True,\n190:                text=True,\n191:                encoding=\"utf-8\",\n192:                timeout=30,\n193:            )\n194:            if black_result.returncode == 0:\n195:                results.append(\"Black formatting: PASSED\")\n196:            else:\n197:                results.append(\"Black formatting: FAILED\")\n198:                results.append(\"Black diff output:\")\n199:                results.append(black_result.stdout)\n200:                if black_result.stderr:\n201:                    results.append(\"Black errors:\")\n202:                    results.append(black_result.stderr)\n203:        except subprocess.TimeoutExpired:\n204:            results.append(\"Black check timed out\")\n205:        except Exception as e:\n206:            results.append(f\"Black check failed: {e}\")\n207:\n208:        # Run isort check\n209:        results.append(\"\\n=== ISORT CHECK ===\")\n210:        try:\n211:            isort_result = subprocess.run(\n212:                [\"python\", \"-m\", \"isort\", \"--check-only\", \"--diff\", rel_path],\n213:                capture_output=True,\n214:                text=True,\n215:                encoding=\"utf-8\",\n216:                timeout=30,\n217:            )\n218:            if isort_result.returncode == 0:\n219:                results.append(\"Import sorting: PASSED\")\n220:            else:\n221:                results.append(\"Import sorting: FAILED\")\n222:                results.append(\"Isort diff output:\")\n223:                results.append(isort_result.stdout)\n224:                if isort_result.stderr:\n225:                    results.append(\"Isort errors:\")\n226:                    results.append(isort_result.stderr)\n227:        except subprocess.TimeoutExpired:\n228:            results.append(\"Isort check timed out\")\n229:        except Exception as e:\n230:            results.append(f\"Isort check failed: {e}\")\n231:\n232:        # Run flake8 check\n233:        results.append(\"\\n=== FLAKE8 CHECK ===\")\n234:        try:\n235:            flake8_result = subprocess.run(\n236:                [\n237:                    \"python\",\n238:                    \"-m\",\n239:                    \"flake8\",\n240:                    rel_path,\n241:                    \"--count\",\n242:                    \"--statistics\",\n243:                    \"--show-source\",\n244:                ],\n245:                capture_output=True,\n246:                text=True,\n247:                encoding=\"utf-8\",\n248:                timeout=30,\n249:            )\n250:            if flake8_result.returncode == 0:\n251:                results.append(\"Flake8 linting: PASSED\")\n252:            else:\n253:                results.append(\"Flake8 linting: FAILED\")\n254:                results.append(\"Flake8 output:\")\n255:                results.append(flake8_result.stdout)\n256:                if flake8_result.stderr:\n257:                    results.append(\"Flake8 errors:\")\n258:                    results.append(flake8_result.stderr)\n259:        except subprocess.TimeoutExpired:\n260:            results.append(\"Flake8 check timed out\")\n261:        except Exception as e:\n262:            results.append(f\"Flake8 check failed: {e}\")\n263:    finally:\n264:        # Always restore original working directory\n265:        os.chdir(original_cwd)\n266:\n267:    return \"\\n\".join(results)\n268:\n269:\n270:def create_style_fixer_bot(num: int, file_path: str, project_root: str) -> Bot:\n271:    \"\"\"Create and configure a bot specialized for fixing code style issues.\n272:    Use when you need to create a new style-fixing bot instance with\n273:    appropriate tools and context for fixing Python code style issues.\n274:    Parameters:\n275:        num (int): Unique identifier for the bot instance, used in naming\n276:        file_path (str): Absolute path to the Python file this bot will work on\n277:        project_root (str): Root directory of the project\n278:    Returns:\n279:        Bot: Configured AnthropicBot instance with:\n280:            - Code style specialist role\n281:            - Terminal tools for running commands\n282:            - File-specific CI/CD checking tool\n283:            - Appropriate system message for style fixing\n284:    \"\"\"\n285:    rel_path = os.path.relpath(file_path, project_root)\n286:\n287:    bot = AnthropicBot(\n288:        model_engine=Engines.CLAUDE4_SONNET,  # Updated to Claude 4 Sonnet\n289:        temperature=0.1,  # Low temperature for consistent style fixes\n290:        name=f\"StyleFixer{num}\",\n291:        role=\"Code Style Specialist\",\n292:        role_description=f\"Fixes Python code style issues for {rel_path}\",\n293:        autosave=False,\n294:    )\n295:\n296:    # Add terminal tools for running commands and editing files\n297:    from bots.tools.code_tools import view, view_dir\n298:    from bots.tools.python_edit import python_view\n299:    from bots.tools.python_execution_tool import execute_python\n300:    from bots.tools.terminal_tools import execute_powershell\n301:\n302:    bot.add_tools(execute_powershell, execute_python, view, view_dir, python_view)\n303:\n304:    # Add file-specific CI/CD checking tool\n305:    bot.add_tools(check_file_cicd)\n306:\n307:    system_message = textwrap.dedent(\n308:        f\"\"\"\n309:        You are an expert in Python code style and CI/CD pipeline compliance.\n310:        Your task is to fix code style issues in the file '{rel_path}' to\n311:        ensure it passes automated style checks.\n312:\n313:        Your assigned file: {rel_path}\n314:\n315:        Your workflow:\n316:        1. Use check_my_file() to identify current style issues\n317:        2. Apply automatic formatters using execute_powershell:\n318:           - python -m black {rel_path}\n319:           - python -m isort {rel_path}\n320:        3. For remaining issues, use patch_edit or view/edit files manually\n321:        4. Use check_my_file() again to verify all issues are resolved\n322:\n323:        Common manual fixes needed:\n324:        - Line length violations: Break long lines at appropriate points\n325:          but do not excessively shorten variable names. Descriptive var\n326:          names are part of the author's style.\n327:        - Bare except clauses: Change 'except:' to 'except Exception:'\n328:        - Unused variables: Remove or prefix with underscore\n329:        - F-strings without placeholders: Convert to regular strings (use double quotes)\n330:        - Missing blank lines: Add proper spacing between functions/classes\n331:        - 'raise NotImplemented': Change to 'raise NotImplementedError'\n332:\n333:        IMPORTANT: Only work on your assigned file: {rel_path}\n334:        Use the available tools to make direct edits. Do not change\n335:        functionality, only style.\n336:\n337:        IMPORTANT: You may decide that the file *should not* be formatted\n338:        or otherwise adjusted. In that case, adjust the configuration file\n339:        to ignore the file in question. As an example, test_python_edit.py\n340:        contains many specific combinations of \", ', and escape characters\n341:        and formatters are very likely to change functionality.\n342:\n343:        IMPORTANT: If you see repeated code elements, and very large amounts\n344:        of indentation you *may* refactor into smaller chunks, but only do\n345:        this if it's completely necessary to meet line length limits.\n346:        \"\"\"\n347:    ).strip()\n348:\n349:    bot.set_system_message(system_message)\n350:    return bot\n351:\n352:\n353:def fix_file_style(bot: Bot) -> Tuple[List[str], List[ConversationNode]]:\n354:    \"\"\"Execute a thorough style fixing process for a Python file.\n355:    Use when you need to systematically fix all style issues in a Python file\n356:    to ensure CI/CD pipeline compliance.\n357:    Parameters:\n358:        bot (Bot): Configured style-fixing bot that has been initialized with\n359:                  a target file path in its conversation context\n360:    Returns:\n361:        Tuple[List[str], List[ConversationNode]]:\n362:            - List of responses from the style fixing process\n363:            - List of conversation nodes tracking the fix history\n364:    Note:\n365:        The bot must be initialized with a TARGET FILE path before calling\n366:        this function.\n367:        The process includes:\n368:        1. Initial style check analysis\n369:        2. Automatic formatter application\n370:        3. Manual fixes for remaining issues\n371:        4. Final verification\n372:    \"\"\"\n373:    prompts = [\n374:        \"INSTRUCTION: Start by running check_my_file() to see what style \" \"issues need to be fixed in your assigned file.\",\n375:        \"INSTRUCTION: Now apply the automatic formatters to fix what can be \"\n376:        \"automated. Use execute_powershell to run 'python -m black [your \"\n377:        \"file path]' and 'python -m isort [your file path]'. Then run \"\n378:        \"check_my_file() again to see what issues remain.\",\n379:        \"INSTRUCTION: Fix any remaining flake8 issues manually. Focus on the \"\n380:        \"most common issues like line length, bare except clauses, unused \"\n381:        \"variables, and missing blank lines. Run check_my_file() after \"\n382:        \"making changes to track progress.\",\n383:        \"INSTRUCTION: Run check_my_file() one final time to verify all style \"\n384:        \"issues are resolved. The file should now pass all CI/CD style \"\n385:        \"checks.\",\n386:    ]\n387:\n388:    def print_responses(responses, nodes):\n389:        for response in responses:\n390:            print(\"\\n\\n\" + response)\n391:\n392:    return fp.chain_while(\n393:        bot=bot,\n394:        prompt_list=prompts,\n395:        stop_condition=fp.conditions.tool_not_used,\n396:        continue_prompt=\"Once you have finished INSTRUCTION, write a brief \"\n397:        \"summary of what you did and we will move to the next INSTRUCTION\",\n398:        callback=print_responses,\n399:    )\n400:\n401:\n402:def main():\n403:    \"\"\"Coordinate parallel style fixing across all Python files that need it.\n404:    Use when you need to execute a full project style fix that:\n405:    1. Identifies all relevant Python files (not in .gitignore)\n406:    2. Pre-filters to only include files that fail style checks\n407:    3. Creates parallel bot instances with file-specific tools\n408:    4. Executes style fixing for each file that needs it\n409:    5. Reports progress and summary\n410:    \"\"\"\n411:    print(\"## Finding Files ##\")\n412:    project_root = os.path.abspath(os.path.join(os.path.dirname(__file__), \"..\"))\n413:\n414:    # Find files that need fixing and those that already pass\n415:    (\n416:        files_needing_fixes,\n417:        files_already_passing,\n418:    ) = find_files_needing_style_fixes(project_root)\n419:\n420:    print(\"\\n## Summary ##\")\n421:    print(f\"Files already passing style checks: {len(files_already_passing)}\")\n422:    print(f\"Files needing style fixes: {len(files_needing_fixes)}\")\n423:\n424:    if files_already_passing:\n425:        print(\"\\nFiles already compliant:\")\n426:        for file in files_already_passing:\n427:            rel_path = os.path.relpath(file, project_root)\n428:            print(f\"  \u2713 {rel_path}\")\n429:\n430:    if not files_needing_fixes:\n431:        print(\"\\n?? All Python files already pass style checks! \" \"No fixes needed.\")\n432:        return\n433:\n434:    print(\"\\nFiles that need fixing:\")\n435:    for file in files_needing_fixes:\n436:        rel_path = os.path.relpath(file, project_root)\n437:        print(f\"  \u2717 {rel_path}\")\n438:\n439:    # Create bots only for files that need fixing\n440:    print(f\"\\n## Creating {len(files_needing_fixes)} bots ##\")\n441:    bots = [create_style_fixer_bot(n, file, project_root) for n, file in enumerate(files_needing_fixes)]\n442:\n443:    # Initialize each bot with its target file\n444:    for bot, file in zip(bots, files_needing_fixes):\n445:        rel_path = os.path.relpath(file, project_root)\n446:        bot.respond(\n447:            f\"You are assigned to fix style issues in {rel_path}. This is \"\n448:            f\"your TARGET FILE. Respond with 'ok' if you understand but do \"\n449:            f\"not begin.\"\n450:        )\n451:\n452:    # Execute style fixing in parallel\n453:    print(f\"\\n## Starting parallel style fixing for {len(bots)} files... ##\")\n454:    fp.par_dispatch(bots, fix_file_style)\n455:\n456:    print(\n457:        f\"\\n## Style fixing complete! ##\"\n458:        f\"\\nProcessed: {len(files_needing_fixes)} files\"\n459:        f\"\\nSkipped (already compliant): {len(files_already_passing)} files\"\n460:        f\"\\nAll files should now pass CI/CD style checks.\"\n461:    )\n462:\n463:\n464:if __name__ == \"__main__\":\n465:    main()"
                         }
                        ],
                        "node_class": "AnthropicNode",
                        "replies": [
                         {
                          "content": "Perfect! Now I understand the structure. Let me summarize what I've learned about namshubs:\n\n**Namshub Structure:**\n1. **Plain-text description** (as module docstring) explaining the overall goal/task\n2. **Helper functions** for setup and configuration\n3. **Bot creation function** that:\n   - Creates a fresh bot with specific configuration\n   - Adds appropriate tools (can be a subset or custom toolkit)\n   - Sets a specialized system message\n4. **Main workflow function** that uses functional prompts (chain, chain_while, prompt_while, etc.)\n5. **Orchestration** (often using par_dispatch for parallel execution)\n\n**Key Patterns I've Observed:**\n- **20_questions.py**: Uses `prompt_while` with a dynamic prompt that creates judge bots on-the-fly\n- **doc_checker.py**: Uses `chain_while` with specialized bots, parallel dispatch via `par_dispatch`\n- **style_fixer.py**: Pre-filters work, creates specialized bots with custom tools, uses `chain_while` with callbacks\n\n**Tool Swapping Pattern:**\n```python\n# Create fresh bot with only needed tools\nbot = AnthropicBot(...)\nbot.add_tools(specific_tools_only)\n# The bot now has a limited toolkit\n\n# To restore: save original tool_handler, then swap back\noriginal_handler = bot.tool_handler\n# ... do work ...\nbot.tool_handler = original_handler\n```\n\nI'm ready to write namshubs! What kind of namshub would you like me to create? Some ideas:\n- Code reviewer\n- Test generator\n- Refactoring assistant\n- Security auditor\n- Performance optimizer\n- API documentation generator\n- Something else?\n\nWhat task should the namshub accomplish?",
                          "pending_results": [],
                          "role": "assistant",
                          "tool_calls": [],
                          "tool_results": [],
                          "node_class": "AnthropicNode"
                         }
                        ]
                       }
                      ]
                     }
                    ]
                   }
                  ]
                 }
                ]
               }
              ]
             }
            ]
           }
          ]
         }
        ]
       }
      ]
     }
    ]
   }
  ]
 },
 "system_message": "You're a coding agent. When greeting users, always start with \"Hello! I'm here to help you\".\n        Please follow these rules:\n                1. Keep edits and even writing new files to small chunks. You have a low max_token limit\n                   and will hit tool errors if you try making too big of a change.\n                2. Avoid using cd. Your terminal is stateful and will remember if you use cd.\n                   Instead, use full relative paths.\n",
 "tool_handler": {
  "class": "bots.foundation.anthropic_bots.AnthropicToolHandler",
  "tools": [
   {
    "name": "view",
    "description": "Display the contents of a file with line numbers.\nParameters:\n- file_path (str): The path to the file to be viewed.\n- start_line (int, optional): Starting line number (1-indexed). If None, starts from beginning.\n- end_line (int, optional): Ending line number (1-indexed). If None, goes to end of file.\n- around_str_match (str, optional): String to search for. If provided, shows lines around matches.\n- dist_from_match (int, optional): Number of lines to show before and after each match. Defaults to 10.\nReturns:\nA string containing the file contents with line numbers,\nfiltered according to the specified parameters.",
    "input_schema": {
     "type": "object",
     "properties": {
      "file_path": {
       "type": "string"
      },
      "start_line": {
       "type": "string"
      },
      "end_line": {
       "type": "string"
      },
      "around_str_match": {
       "type": "string"
      },
      "dist_from_match": {
       "type": "string"
      }
     },
     "required": [
      "file_path"
     ]
    }
   },
   {
    "name": "view_dir",
    "description": "Creates a summary of the directory structure starting from the given path, writing only files\nwith specified extensions and showing venv directories without their contents.\nParameters:\n- start_path (str): The root directory to start scanning from.\n- output_file (str): The name of the file to optionally write the directory structure to.\n- target_extensions (str): String representation of a list of file extensions (e.g. \"['py', 'txt']\").\n- max_lines (int): Maximum number of lines in output. If exceeded, deepest levels are truncated. Default 500.\nReturns:\nstr: A formatted string containing the directory structure, with each directory and file properly indented.\nExample output:\nmy_project/\n    venv/\n    module1/\n        script.py\n        README.md\n    module2/\n        utils.py\ncost: low",
    "input_schema": {
     "type": "object",
     "properties": {
      "start_path": {
       "type": "string"
      },
      "output_file": {
       "type": "string"
      },
      "target_extensions": {
       "type": "string"
      },
      "max_lines": {
       "type": "string"
      }
     },
     "required": []
    }
   },
   {
    "name": "python_view",
    "description": "View Python code using pytest-style scope syntax with scope-aware truncation.\n\nParameters:\n-----------\ntarget_scope : str\n    Location to view in pytest-style scope syntax:\n    - \"file.py\" (whole file)\n    - \"file.py::MyClass\" (class)\n    - \"file.py::my_function\" (function)\n    - \"file.py::MyClass::method\" (method)\nmax_lines : int, optional\n    Maximum number of lines in output. If exceeded, deeper scopes will be\n    progressively truncated to create an outline view. Default 500.\n\nReturns:\n--------\nstr\n    The source code at the specified scope, or error message",
    "input_schema": {
     "type": "object",
     "properties": {
      "target_scope": {
       "type": "string"
      },
      "max_lines": {
       "type": "string"
      }
     },
     "required": [
      "target_scope"
     ]
    }
   },
   {
    "name": "execute_powershell",
    "description": "Executes PowerShell commands in a stateful environment with automatic BOM removal\n\nUse when you need to run PowerShell commands and capture their output. If\nyou have other tools available, you should use this as a fallback when the\nother tools fail. Coerces to utf-8 (no BOM).\n\nPotential use cases:\n- git commands\n- gh cli\n- other cli (which you may need to install using this tool)\n\nParameters:\n- command (str): PowerShell command to execute.\n- output_length_limit (int, optional): Maximum number of lines in the output.\n  If set, output exceeding this limit will be truncated. Default 200.\n\nReturns:\n    str: The complete output from the command execution",
    "input_schema": {
     "type": "object",
     "properties": {
      "command": {
       "type": "string"
      },
      "output_length_limit": {
       "type": "string"
      },
      "timeout": {
       "type": "string"
      }
     },
     "required": [
      "command"
     ]
    }
   },
   {
    "name": "execute_python",
    "description": "Executes python code in a stateless environment with cross-platform\ntimeout handling.\nParameters:\n- code (str): Syntactically correct python code\n- timeout (int): Maximum execution time in seconds (default: 300)\nReturns stdout or an error message.\ncost: varies",
    "input_schema": {
     "type": "object",
     "properties": {
      "code": {
       "type": "string"
      },
      "timeout": {
       "type": "string"
      }
     },
     "required": [
      "code"
     ]
    }
   },
   {
    "name": "branch_self",
    "description": "Create multiple conversation branches to explore different approaches or tackle separate tasks.\n\nCreates isolated conversation branches using deepcopy:\n1. Deepcopy current bot state (uses __getstate__/__setstate__ for proper serialization)\n2. Execute each branch with independent bot instances\n3. Stitch results back into main conversation tree\n\nNote: Uses deepcopy with __getstate__/__setstate__ which leverages the hybrid\nserialization strategy (source code + dill for helpers). See bots/foundation/tool_handling.md.\n\nArgs:\n    self_prompts (str): List of prompts as a string array, like ['task 1', 'task 2', 'task 3']\n                       Each prompt becomes a separate conversation branch\n    allow_work (str): 'True' to let each branch use tools and continue working until done\n                     'False' (default) for single-response branches\n    parallel (str): 'True' to let branches work in parallel, 'False' for sequential (default).\n    recombine (str): One of ('none', 'concatenate', 'llm_merge', 'llm_vote', 'llm_judge'), default 'concatenate'.\n                     Combines the final messages from each branch using that method.\n\nReturns:\n    str: Success message with branch count, or error details if something went wrong",
    "input_schema": {
     "type": "object",
     "properties": {
      "self_prompts": {
       "type": "string"
      },
      "allow_work": {
       "type": "string"
      },
      "parallel": {
       "type": "string"
      },
      "recombine": {
       "type": "string"
      }
     },
     "required": [
      "self_prompts"
     ]
    }
   },
   {
    "name": "remove_context",
    "description": "Remove bot-user message pairs from the conversation history.\n\nUse when you need to delete specific messages from your conversation tree\nto reduce context or remove irrelevant information. This is a demo tool\nthat removes message pairs by stitching the tree after deletion.\n\nNote: This tool has limitations with branched conversations and will\nattempt to handle the simplest case (linear conversation paths).\n\nParameters:\n    labels (str): String representation of a list of labels to remove.\n        Format: \"['A', 'B', 'C']\"\n        Use list_context() first to see available labels.\n\nReturns:\n    str: Success message with count of removed pairs, or error message\n\nExample:\n    remove_context(\"['A', 'C']\")",
    "input_schema": {
     "type": "object",
     "properties": {
      "labels": {
       "type": "string"
      }
     },
     "required": [
      "labels"
     ]
    }
   },
   {
    "name": "list_context",
    "description": "List all bot messages in the conversation with labels for removal.\n\nUse this before remove_context to see what messages are in your conversation.\nShows bot messages only (since removal happens in user-bot pairs) with:\n- A label [A], [B], [C], etc. for reference\n- Truncated tool calls (if any) with parameters\n- Truncated response text\n\nReturns:\n    str: Formatted list of bot messages with labels, or error message\n\nExample output:\n    [A] Bot: <tool_name param=\"value...\"> | \"Response text...\"\n    [B] Bot: \"Response text without tools...\"",
    "input_schema": {
     "type": "object",
     "properties": {},
     "required": []
    }
   },
   {
    "name": "web_search",
    "description": "Perform an agentic web search using Claude's internal web search capabilities",
    "input_schema": {
     "type": "object",
     "properties": {
      "question": {
       "type": "string"
      }
     },
     "required": [
      "question"
     ]
    }
   },
   {
    "name": "python_edit",
    "description": "    Edit Python code using pytest-style scope syntax and optional expression matching.\n\n    Parameters:\n    -----------\n    target_scope : str\n        Location to edit in pytest-style scope syntax:\n        - \"file.py\" (whole file)\n        - \"file.py::MyClass\" (class)\n        - \"file.py::my_function\" (function)\n        - \"file.py::MyClass::method\" (method)\n        - \"file.py::__FIRST__\" (first top-level definition)\n\n    code : str\n        Python code. This code will replace the entire target scope by default,\n        or insert after (if coscope_with is specified). Code is indented automatically\n        to match to scope.\n\n    coscope_with : str, optional\n        If specified, code is inserted in the same scope as the specified code,\n        and immediately after it. Uses the same syntax as target_scope with\n        optional expression at the end in quotes.\n\n\n            Scope:\n                - a\n                - b\n\n            - python edit called with coscope_with = \"a\", code = \"- c\" -\n\n            Scope:\n                - a\n                - c\n                - b\n\n        - \"__FILE_START__\" (special token for file beginning)\n        - \"MyClass::method\" (insert after this method within the target scope)\n        - '\"expression\"' (insert after a line matching this expression)\n    delete_a_lot : bool, optional\n- \"__FILE_END__\" (special token for file end)\n        Safety parameter. Must be True to allow operations that delete more than 100 lines.\n        Helps prevent accidental file overwrites. Default False.\n\n    Returns:\n    --------\n    str\n        Description of what was modified or error message",
    "input_schema": {
     "type": "object",
     "properties": {
      "target_scope": {
       "type": "string"
      },
      "code": {
       "type": "string"
      },
      "coscope_with": {
       "type": "string"
      },
      "delete_a_lot": {
       "type": "string"
      }
     },
     "required": [
      "target_scope",
      "code"
     ]
    },
    "cache_control": {
     "type": "ephemeral"
    }
   }
  ],
  "requests": [],
  "results": [],
  "modules": {
   "dynamic_module_-7082991387547001233": {
    "name": "dynamic_module_-1274524576041970484",
    "source": "from bots.utils.helpers import _process_error\n\ndef toolify(description: str = None):\n    \"\"\"\n    Convert any function into a bot tool with string-in, string-out interface.\n\n    - Converts string inputs to proper types using type hints\n    - Ensures string output (JSON for complex types)\n    - Wraps in error handling (returns error strings, never raises)\n    - Enhances docstring if description provided\n\n    Args:\n        description (str, optional): Override the function's docstring\n\n    Example:\n        @toolify()\n        def add_numbers(x: int, y: int = 0) -> int:\n            return x + y\n\n        @toolify(\"Calculate the area of a circle\")\n        def area(radius: float) -> float:\n            return 3.14159 * radius * radius\n    \"\"\"\n\n    def decorator(func):\n        @functools.wraps(func)\n        def wrapper(*args, **kwargs):\n            try:\n                # Convert string inputs to proper types using type hints\n                converted_args, converted_kwargs = _convert_tool_inputs(func, args, kwargs)\n\n                # Call original function\n                result = func(*converted_args, **converted_kwargs)\n\n                # Convert result to string\n                return _convert_tool_output(result)\n\n            except KeyboardInterrupt as e:\n                # Convert KeyboardInterrupt to ToolExecutionError to prevent it from\n                # bubbling up to CLI and being treated as user Ctrl+C\n\n                tool_error = ToolExecutionError(f\"Tool execution interrupted: {str(e)}\")\n                return _process_error(tool_error)\n\n            except TypeError as e:\n                # Check if this is a missing required argument error\n                error_msg = str(e)\n                if \"missing\" in error_msg and \"required\" in error_msg and \"argument\" in error_msg:\n                    # Add special message for output token limitation\n                    enhanced_error = TypeError(\n                        f\"{error_msg}\\n\\n\"\n                        f\"\u26a0\ufe0f  This error is commonly caused by hitting the max_tokens limit before completing the tool call.\\n\"\n                        f\"The response was truncated mid-parameter, making it appear that required parameters are missing.\\n\"\n                        f\"To fix this: Work in SMALLER CHUNKS. Edit fewer lines at a time, \"\n                        f\"or break your task into multiple steps.\"\n                    )\n\n                    return _process_error(enhanced_error)\n                else:\n\n                    return _process_error(e)\n            except Exception as e:\n\n                return _process_error(e)\n\n        # Update docstring if description provided\n        if description:\n            wrapper.__doc__ = description\n        elif not wrapper.__doc__:\n            # Generate minimal docstring from function name\n            wrapper.__doc__ = f\"Execute {func.__name__.replace('_', ' ')}\"\n\n        return wrapper\n\n    return decorator\n\n@toolify()\ndef view(file_path: str, start_line: str=None, end_line: str=None, around_str_match: str=None, dist_from_match: str='10'):\n    \"\"\"\n    Display the contents of a file with line numbers.\n    Parameters:\n    - file_path (str): The path to the file to be viewed.\n    - start_line (int, optional): Starting line number (1-indexed). If None, starts from beginning.\n    - end_line (int, optional): Ending line number (1-indexed). If None, goes to end of file.\n    - around_str_match (str, optional): String to search for. If provided, shows lines around matches.\n    - dist_from_match (int, optional): Number of lines to show before and after each match. Defaults to 10.\n    Returns:\n    A string containing the file contents with line numbers,\n    filtered according to the specified parameters.\n    \"\"\"\n    encodings = ['utf-8', 'utf-16', 'utf-16le', 'ascii', 'cp1252', 'iso-8859-1']\n    start_line = int(start_line) if start_line is not None else None\n    end_line = int(end_line) if end_line is not None else None\n    dist_from_match = int(dist_from_match) if dist_from_match is not None else None\n    for encoding in encodings:\n        try:\n            with open(file_path, 'r', encoding=encoding) as file:\n                lines = file.readlines()\n            if around_str_match:\n                matching_line_numbers = []\n                for i, line in enumerate(lines):\n                    if around_str_match in line:\n                        matching_line_numbers.append(i)\n                if not matching_line_numbers:\n                    return f\"No matches found for '{around_str_match}'\"\n                line_ranges = set()\n                for match_line in matching_line_numbers:\n                    start = max(0, match_line - dist_from_match)\n                    end = min(len(lines), match_line + dist_from_match + 1)\n                    for line_num in range(start, end):\n                        line_ranges.add(line_num)\n                sorted_lines = sorted(line_ranges)\n                numbered_lines = []\n                prev_line = None\n                for line_num in sorted_lines:\n                    if prev_line is not None and line_num > prev_line + 1:\n                        numbered_lines.append('...')\n                    numbered_lines.append(f'{line_num + 1}:{lines[line_num].rstrip()}')\n                    prev_line = line_num\n                return '\\n'.join(numbered_lines)\n            else:\n                start_idx = start_line - 1 if start_line else 0\n                end_idx = end_line if end_line else len(lines)\n                start_idx = max(0, start_idx)\n                end_idx = min(len(lines), end_idx)\n                if start_idx >= len(lines):\n                    return f'Error: start_line ({start_line}) exceeds file length ({len(lines)} lines)'\n                selected_lines = lines[start_idx:end_idx]\n                numbered_lines = [f'{i + start_idx + 1}:{line.rstrip()}' for i, line in enumerate(selected_lines)]\n                return '\\n'.join(numbered_lines)\n        except UnicodeDecodeError:\n            continue\n    return f\"Error: Unable to read file with any of the attempted encodings: {', '.join(encodings)}\"",
    "file_path": "dynamic_module_-7082991387547001233",
    "code_hash": "4452c6f65cf54824209e0e3f5c93fce3",
    "globals": {
     "_convert_tool_inputs": {
      "__helper_func__": true,
      "pickled": "gASVMAAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjBRfY29udmVydF90b29sX2lucHV0c5STlC4=",
      "name": "_convert_tool_inputs",
      "hash": "8bc4aba1c7d69350a812d8553b6a7ff0cd23ae5c818f3b9533752a69e91acf2e",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "_convert_tool_inputs"
      }
     },
     "_convert_tool_output": {
      "__helper_func__": true,
      "pickled": "gASVMAAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjBRfY29udmVydF90b29sX291dHB1dJSTlC4=",
      "name": "_convert_tool_output",
      "hash": "6c85767d30db1c50646d25d2b954c893aed15774f97345f9b8c99674c59cf928",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "_convert_tool_output"
      }
     },
     "ToolExecutionError": {
      "__imported_callable__": true,
      "pickled": "gASVLgAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjBJUb29sRXhlY3V0aW9uRXJyb3KUk5Qu",
      "name": "ToolExecutionError",
      "hash": "e3f136f46cc3014d1b1a8ac6716adb9da7db1dd83f2ed8529e090d97ae0db998",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "ToolExecutionError"
      }
     },
     "ast": {
      "__module_type__": true,
      "name": "ast",
      "spec": "ast"
     },
     "datetime": {
      "__module_type__": true,
      "name": "datetime",
      "spec": "datetime"
     },
     "functools": {
      "__module_type__": true,
      "name": "functools",
      "spec": "functools"
     },
     "inspect": {
      "__module_type__": true,
      "name": "inspect",
      "spec": "inspect"
     },
     "logging": {
      "__module_type__": true,
      "name": "logging",
      "spec": "logging"
     },
     "os": {
      "__module_type__": true,
      "name": "os",
      "spec": "os"
     },
     "sys": {
      "__module_type__": true,
      "name": "sys",
      "spec": "sys"
     },
     "textwrap": {
      "__module_type__": true,
      "name": "textwrap",
      "spec": "textwrap"
     },
     "traceback": {
      "__module_type__": true,
      "name": "traceback",
      "spec": "traceback"
     },
     "wraps": {
      "__imported_callable__": true,
      "pickled": "gASVFwAAAAAAAACMCWZ1bmN0b29sc5SMBXdyYXBzlJOULg==",
      "name": "wraps",
      "hash": "4c7c8f91a978a903bce2515f7fe83cb09b7074259dabad02b312209312f718ed",
      "provenance": {
       "module": "functools",
       "qualname": "wraps"
      }
     },
     "Any": {
      "__imported_callable__": true,
      "pickled": "gASVEgAAAAAAAACMBnR5cGluZ5SMA0FueZSTlC4=",
      "name": "Any",
      "hash": "fbf19bc6bf716a555ce7094664e2bc898734e4acfc2cd6d9ee399edef2e5c02b",
      "provenance": {
       "module": "typing",
       "qualname": "Any"
      }
     },
     "Callable": {
      "__imported_callable__": true,
      "pickled": "gASVFwAAAAAAAACMBnR5cGluZ5SMCENhbGxhYmxllJOULg==",
      "name": "Callable",
      "hash": "17cf7f09b805961290dccb95aa11199df32c246cb879f355ffa1a31d6285edad",
      "provenance": {
       "module": "typing",
       "qualname": "Callable"
      }
     },
     "Optional": {
      "__imported_callable__": true,
      "pickled": "gASVFwAAAAAAAACMBnR5cGluZ5SMCE9wdGlvbmFslJOULg==",
      "name": "Optional",
      "hash": "d69b63c158dd563d1537447d9d3a68afdda0efb70794ab11c234d01e2e593e56",
      "provenance": {
       "module": "typing",
       "qualname": "Optional"
      }
     },
     "Type": {
      "__imported_callable__": true,
      "pickled": "gASVEwAAAAAAAACMBnR5cGluZ5SMBFR5cGWUk5Qu",
      "name": "Type",
      "hash": "9e98fdb991d3addb0aad6e13cd94b21998f5d97e9f30b15f9c697afe5cde1832",
      "provenance": {
       "module": "typing",
       "qualname": "Type"
      }
     },
     "remove_code_blocks": {
      "__imported_callable__": true,
      "pickled": "gASVLQAAAAAAAACMEmJvdHMudXRpbHMuaGVscGVyc5SMEnJlbW92ZV9jb2RlX2Jsb2Nrc5STlC4=",
      "name": "remove_code_blocks",
      "hash": "44524fda389310a2a28f80da99409efd110baefaa9ea50345d092a634c89fc1d",
      "provenance": {
       "module": "bots.utils.helpers",
       "qualname": "remove_code_blocks"
      }
     },
     "NoHTTPFilter": {
      "__imported_callable__": true,
      "pickled": "gASVKAAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjAxOb0hUVFBGaWx0ZXKUk5Qu",
      "name": "NoHTTPFilter",
      "hash": "9f920bc687c51afef3dea517f9b64393473ed37dac3fda0cedd01a655b483a52",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "NoHTTPFilter"
      }
     },
     "lazy_fn": {
      "__imported_callable__": true,
      "pickled": "gASVIwAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjAdsYXp5X2ZulJOULg==",
      "name": "lazy_fn",
      "hash": "a1737e2cf8adde594f0dd0b3f17ffaad4c126dcf16906e82cb07f18c13d8b7a2",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "lazy_fn"
      }
     },
     "lazy_class": {
      "__imported_callable__": true,
      "pickled": "gASVJgAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjApsYXp5X2NsYXNzlJOULg==",
      "name": "lazy_class",
      "hash": "d1883fc4e7eb2d64f47b4e90b4b6b69d0c5be0d0e3175787058ad631d122e4c6",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "lazy_class"
      }
     },
     "_get_context": {
      "__helper_func__": true,
      "pickled": "gASVKAAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjAxfZ2V0X2NvbnRleHSUk5Qu",
      "name": "_get_context",
      "hash": "979ef249cdc1f76f4020d948ffc352f7c667afb0d89f221770156eebd7717c7a",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "_get_context"
      }
     },
     "_get_py_interface": {
      "__helper_func__": true,
      "pickled": "gASVLQAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjBFfZ2V0X3B5X2ludGVyZmFjZZSTlC4=",
      "name": "_get_py_interface",
      "hash": "d45b0506fb8815e8d9c3a9217b0ca101dac4fb9f51c8546285cf68a95ab027e7",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "_get_py_interface"
      }
     },
     "lazy": {
      "__imported_callable__": true,
      "pickled": "gASVIAAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjARsYXp5lJOULg==",
      "name": "lazy",
      "hash": "6e25446d8765ac65a5518c01582ddf52784eb90c51d57e224c94823d5b7c55cd",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "lazy"
      }
     },
     "debug_on_error": {
      "__imported_callable__": true,
      "pickled": "gASVKgAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjA5kZWJ1Z19vbl9lcnJvcpSTlC4=",
      "name": "debug_on_error",
      "hash": "06d89d594519c41c1dae666437441d4fd4aeeea959f1c905694940a50ae4ddfe",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "debug_on_error"
      }
     },
     "log_errors": {
      "__imported_callable__": true,
      "pickled": "gASVJgAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjApsb2dfZXJyb3JzlJOULg==",
      "name": "log_errors",
      "hash": "f9446c0ae11aa5bb7726b83da744e8dc707a91edc91085abbca1cefd1897d829",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "log_errors"
      }
     },
     "toolify": {
      "__imported_callable__": true,
      "pickled": "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b25hbCk6IEVuZGluZyBsaW5lIG51bWJlciAoMS1pbmRleGVkKS4gSWYgTm9uZSwgZ29lcyB0byBlbmQgb2YgZmlsZS4KICAgIC0gYXJvdW5kX3N0cl9tYXRjaCAoc3RyLCBvcHRpb25hbCk6IFN0cmluZyB0byBzZWFyY2ggZm9yLiBJZiBwcm92aWRlZCwgc2hvd3MgbGluZXMgYXJvdW5kIG1hdGNoZXMuCiAgICAtIGRpc3RfZnJvbV9tYXRjaCAoaW50LCBvcHRpb25hbCk6IE51bWJlciBvZiBsaW5lcyB0byBzaG93IGJlZm9yZSBhbmQgYWZ0ZXIgZWFjaCBtYXRjaC4gRGVmYXVsdHMgdG8gMTAuCiAgICBSZXR1cm5zOgogICAgQSBzdHJpbmcgY29udGFpbmluZyB0aGUgZmlsZSBjb250ZW50cyB3aXRoIGxpbmUgbnVtYmVycywKICAgIGZpbHRlcmVkIGFjY29yZGluZyB0byB0aGUgc3BlY2lmaWVkIHBhcmFtZXRlcnMuCiAgICCUKIwFdXRmLTiUjAZ1dGYtMTaUjAh1dGYtMTZsZZSMBWFzY2lplIwGY3AxMjUylIwKaXNvLTg4NTktMZR0lE6MAXKUjAhlbmNvZGluZ5SFlIwWTm8gbWF0Y2hlcyBmb3VuZCBmb3IgJ5SMASeUSwBLAYwDLi4ulIwBOpSMAQqUjBNFcnJvcjogc3RhcnRfbGluZSAolIwXKSBleGNlZWRzIGZpbGUgbGVuZ3RoICiUjAcgbGluZXMplIxARXJyb3I6IFVuYWJsZSB0byByZWFkIGZpbGUgd2l0aCBhbnkgb2YgdGhlIGF0dGVtcHRlZCBlbmNvZGluZ3M6IJSMAiwglHSUKIwDaW50lIwEb3BlbpSMCXJlYWRsaW5lc5SMCWVudW1lcmF0ZZSMBmFwcGVuZJSMA3NldJSMA21heJSMA21pbpSMA2xlbpSMBXJhbmdllIwDYWRklIwGc29ydGVklIwGcnN0cmlwlIwEam9pbpSMElVuaWNvZGVEZWNvZGVFcnJvcpR0lCiMCWZpbGVfcGF0aJSMCnN0YXJ0X2xpbmWUjAhlbmRfbGluZZSMEGFyb3VuZF9zdHJfbWF0Y2iUjA9kaXN0X2Zyb21fbWF0Y2iUjAllbmNvZGluZ3OUaMWMBGZpbGWUjAVsaW5lc5SMFW1hdGNoaW5nX2xpbmVfbnVtYmVyc5SMAWmUjARsaW5llIwLbGluZV9yYW5nZXOUjAptYXRjaF9saW5llIwFc3RhcnSUjANlbmSUjAhsaW5lX251bZSMDHNvcnRlZF9saW5lc5SMDm51bWJlcmVkX2xpbmVzlIwJcHJldl9saW5llIwJc3RhcnRfaWR4lIwHZW5kX2lkeJSMDnNlbGVjdGVkX2xpbmVzlHSUaCdor2ivS09CgQIAAIAA8hwAEVEBgEnYJC7QJDqUE5BalB/ABIBK2CAo0CA0jHOQOIx9uCSASNguPdAuSZRjmC/UFirIdIBP3BQdiAjwAiQJFdwRFZBpoBOoeNUROLhE2Bgcnw6ZDtMYKJAF9wMAEjniDx/YKCrQECXcHyioFdYfL5FHkEGQdNgXJ6g00hcv2Bgt1xg00Rg0sFHVGDfwBQAgMPEGABgt2B0z0DRE0DNFwFHQG0fSFEfcHiGbZZAL2yI3kErcHB+gAaA6sA/RIz/THECQRdwaHZxjoCWbaqgqsH/RKkbIEdEqStMaS5BD3CQpqCWwE9YkNZgI2Bgjnw+ZD6gI1Rgx8QMAJTbwBwAjOPQKACAmoGvTHzKQDNghI5AO2BwgkAnbICyQSNgXINAXLLAYuEnIAblN0jFJ2Bgm1xgt0RgtqGXUGDTYFCLXFCnRFCmoWLgBqVyoTrghuEXAKLlP1zxS0TxS0zxU0DtV0CpW1BRX2CAokUnwCQAhLfAKABgcl3mReaAe0xcw0hAw4S44mEqoEZpOuGGQCdkmLpkotEO4BbNKkAfcHB+gAaA50xwtkAncGh2cY6Alm2qoJ9MaMpAH2BMcpAOgRaMK0hMq2B0wsBqwDNA8U9RUV9BYXdNUXtBTX9BfZtAbZ9IUZ9ghJqB5sBfQITmQDtxYYdBicNRYcdQhctFYcclXyFHQUFSgUagZoV2wUdElNtAkN7BxuBS/G7kbux24D9IiSNBYcZAO0SFy2Bcbl3mReaAe0xcw0hAw8EcBABUe8EwBAA5OAchkz2nJadBYYdNOYtBNY9ALZNAEZPdJAQASOdEROPzzQAEAInMB+OQPIfIAAQkV2gwU8AMBCRX6lENPuQ5INgLBBxFIIwXBGCJINgLBOxpINgLCGEMKSDYCxSVBGEg2AscAE0g2AscTJUgwCMc4E0g2AsgjBUgtCcgoDkg2Asg2CUkDBckCAUkDBZQpKXSUUpR9lGg3aExzaK8oTk5OjAIxMJR0lE50lFKUfZR9lChoNmi8aFJ9lCho4mhXaONoV2jkaFdo5WhXaOZoV3V1hpRijBJfX21vZHVsZV9jb250ZXh0X1+UjBRib3RzLmZvdW5kYXRpb24uYmFzZZSMDU1vZHVsZUNvbnRleHSUk5QpgZR9lCiMBG5hbWWUaEyMBnNvdXJjZZRYwBgAAGRlZiB0b29saWZ5KGRlc2NyaXB0aW9uOiBzdHIgPSBOb25lKToKICAgICIiIgogICAgQ29udmVydCBhbnkgZnVuY3Rpb24gaW50byBhIGJvdCB0b29sIHdpdGggc3RyaW5nLWluLCBzdHJpbmctb3V0IGludGVyZmFjZS4KCiAgICAtIENvbnZlcnRzIHN0cmluZyBpbnB1dHMgdG8gcHJvcGVyIHR5cGVzIHVzaW5nIHR5cGUgaGludHMKICAgIC0gRW5zdXJlcyBzdHJpbmcgb3V0cHV0IChKU09OIGZvciBjb21wbGV4IHR5cGVzKQogICAgLSBXcmFwcyBpbiBlcnJvciBoYW5kbGluZyAocmV0dXJucyBlcnJvciBzdHJpbmdzLCBuZXZlciByYWlzZXMpCiAgICAtIEVuaGFuY2VzIGRvY3N0cmluZyBpZiBkZXNjcmlwdGlvbiBwcm92aWRlZAoKICAgIEFyZ3M6CiAgICAgICAgZGVzY3JpcHRpb24gKHN0ciwgb3B0aW9uYWwpOiBPdmVycmlkZSB0aGUgZnVuY3Rpb24ncyBkb2NzdHJpbmcKCiAgICBFeGFtcGxlOgogICAgICAgIEB0b29saWZ5KCkKICAgICAgICBkZWYgYWRkX251bWJlcnMoeDogaW50LCB5OiBpbnQgPSAwKSAtPiBpbnQ6CiAgICAgICAgICAgIHJldHVybiB4ICsgeQoKICAgICAgICBAdG9vbGlmeSgiQ2FsY3VsYXRlIHRoZSBhcmVhIG9mIGEgY2lyY2xlIikKICAgICAgICBkZWYgYXJlYShyYWRpdXM6IGZsb2F0KSAtPiBmbG9hdDoKICAgICAgICAgICAgcmV0dXJuIDMuMTQxNTkgKiByYWRpdXMgKiByYWRpdXMKICAgICIiIgoKICAgIGRlZiBkZWNvcmF0b3IoZnVuYyk6CiAgICAgICAgQGZ1bmN0b29scy53cmFwcyhmdW5jKQogICAgICAgIGRlZiB3cmFwcGVyKCphcmdzLCAqKmt3YXJncyk6CiAgICAgICAgICAgIHRyeToKICAgICAgICAgICAgICAgICMgQ29udmVydCBzdHJpbmcgaW5wdXRzIHRvIHByb3BlciB0eXBlcyB1c2luZyB0eXBlIGhpbnRzCiAgICAgICAgICAgICAgICBjb252ZXJ0ZWRfYXJncywgY29udmVydGVkX2t3YXJncyA9IF9jb252ZXJ0X3Rvb2xfaW5wdXRzKGZ1bmMsIGFyZ3MsIGt3YXJncykKCiAgICAgICAgICAgICAgICAjIENhbGwgb3JpZ2luYWwgZnVuY3Rpb24KICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmMoKmNvbnZlcnRlZF9hcmdzLCAqKmNvbnZlcnRlZF9rd2FyZ3MpCgogICAgICAgICAgICAgICAgIyBDb252ZXJ0IHJlc3VsdCB0byBzdHJpbmcKICAgICAgICAgICAgICAgIHJldHVybiBfY29udmVydF90b29sX291dHB1dChyZXN1bHQpCgogICAgICAgICAgICBleGNlcHQgS2V5Ym9hcmRJbnRlcnJ1cHQgYXMgZToKICAgICAgICAgICAgICAgICMgQ29udmVydCBLZXlib2FyZEludGVycnVwdCB0byBUb29sRXhlY3V0aW9uRXJyb3IgdG8gcHJldmVudCBpdCBmcm9tCiAgICAgICAgICAgICAgICAjIGJ1YmJsaW5nIHVwIHRvIENMSSBhbmQgYmVpbmcgdHJlYXRlZCBhcyB1c2VyIEN0cmwrQwogICAgICAgICAgICAgICAgZnJvbSBib3RzLnV0aWxzLmhlbHBlcnMgaW1wb3J0IF9wcm9jZXNzX2Vycm9yCgogICAgICAgICAgICAgICAgdG9vbF9lcnJvciA9IFRvb2xFeGVjdXRpb25FcnJvcihmIlRvb2wgZXhlY3V0aW9uIGludGVycnVwdGVkOiB7c3RyKGUpfSIpCiAgICAgICAgICAgICAgICByZXR1cm4gX3Byb2Nlc3NfZXJyb3IodG9vbF9lcnJvcikKCiAgICAgICAgICAgIGV4Y2VwdCBUeXBlRXJyb3IgYXMgZToKICAgICAgICAgICAgICAgICMgQ2hlY2sgaWYgdGhpcyBpcyBhIG1pc3NpbmcgcmVxdWlyZWQgYXJndW1lbnQgZXJyb3IKICAgICAgICAgICAgICAgIGVycm9yX21zZyA9IHN0cihlKQogICAgICAgICAgICAgICAgaWYgIm1pc3NpbmciIGluIGVycm9yX21zZyBhbmQgInJlcXVpcmVkIiBpbiBlcnJvcl9tc2cgYW5kICJhcmd1bWVudCIgaW4gZXJyb3JfbXNnOgogICAgICAgICAgICAgICAgICAgICMgQWRkIHNwZWNpYWwgbWVzc2FnZSBmb3Igb3V0cHV0IHRva2VuIGxpbWl0YXRpb24KICAgICAgICAgICAgICAgICAgICBlbmhhbmNlZF9lcnJvciA9IFR5cGVFcnJvcigKICAgICAgICAgICAgICAgICAgICAgICAgZiJ7ZXJyb3JfbXNnfVxuXG4iCiAgICAgICAgICAgICAgICAgICAgICAgIGYi4pqg77iPICBUaGlzIGVycm9yIGlzIGNvbW1vbmx5IGNhdXNlZCBieSBoaXR0aW5nIHRoZSBtYXhfdG9rZW5zIGxpbWl0IGJlZm9yZSBjb21wbGV0aW5nIHRoZSB0b29sIGNhbGwuXG4iCiAgICAgICAgICAgICAgICAgICAgICAgIGYiVGhlIHJlc3BvbnNlIHdhcyB0cnVuY2F0ZWQgbWlkLXBhcmFtZXRlciwgbWFraW5nIGl0IGFwcGVhciB0aGF0IHJlcXVpcmVkIHBhcmFtZXRlcnMgYXJlIG1pc3NpbmcuXG4iCiAgICAgICAgICAgICAgICAgICAgICAgIGYiVG8gZml4IHRoaXM6IFdvcmsgaW4gU01BTExFUiBDSFVOS1MuIEVkaXQgZmV3ZXIgbGluZXMgYXQgYSB0aW1lLCAiCiAgICAgICAgICAgICAgICAgICAgICAgIGYib3IgYnJlYWsgeW91ciB0YXNrIGludG8gbXVsdGlwbGUgc3RlcHMuIgogICAgICAgICAgICAgICAgICAgICkKICAgICAgICAgICAgICAgICAgICBmcm9tIGJvdHMudXRpbHMuaGVscGVycyBpbXBvcnQgX3Byb2Nlc3NfZXJyb3IKCiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9wcm9jZXNzX2Vycm9yKGVuaGFuY2VkX2Vycm9yKQogICAgICAgICAgICAgICAgZWxzZToKICAgICAgICAgICAgICAgICAgICBmcm9tIGJvdHMudXRpbHMuaGVscGVycyBpbXBvcnQgX3Byb2Nlc3NfZXJyb3IKCiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9wcm9jZXNzX2Vycm9yKGUpCiAgICAgICAgICAgIGV4Y2VwdCBFeGNlcHRpb24gYXMgZToKICAgICAgICAgICAgICAgIGZyb20gYm90cy51dGlscy5oZWxwZXJzIGltcG9ydCBfcHJvY2Vzc19lcnJvcgoKICAgICAgICAgICAgICAgIHJldHVybiBfcHJvY2Vzc19lcnJvcihlKQoKICAgICAgICAjIFVwZGF0ZSBkb2NzdHJpbmcgaWYgZGVzY3JpcHRpb24gcHJvdmlkZWQKICAgICAgICBpZiBkZXNjcmlwdGlvbjoKICAgICAgICAgICAgd3JhcHBlci5fX2RvY19fID0gZGVzY3JpcHRpb24KICAgICAgICBlbGlmIG5vdCB3cmFwcGVyLl9fZG9jX186CiAgICAgICAgICAgICMgR2VuZXJhdGUgbWluaW1hbCBkb2NzdHJpbmcgZnJvbSBmdW5jdGlvbiBuYW1lCiAgICAgICAgICAgIHdyYXBwZXIuX19kb2NfXyA9IGYiRXhlY3V0ZSB7ZnVuYy5fX25hbWVfXy5yZXBsYWNlKCdfJywgJyAnKX0iCgogICAgICAgIHJldHVybiB3cmFwcGVyCgogICAgcmV0dXJuIGRlY29yYXRvcgoKQHRvb2xpZnkoKQpkZWYgdmlldyhmaWxlX3BhdGg6IHN0ciwgc3RhcnRfbGluZTogc3RyPU5vbmUsIGVuZF9saW5lOiBzdHI9Tm9uZSwgYXJvdW5kX3N0cl9tYXRjaDogc3RyPU5vbmUsIGRpc3RfZnJvbV9tYXRjaDogc3RyPScxMCcpOgogICAgIiIiCiAgICBEaXNwbGF5IHRoZSBjb250ZW50cyBvZiBhIGZpbGUgd2l0aCBsaW5lIG51bWJlcnMuCiAgICBQYXJhbWV0ZXJzOgogICAgLSBmaWxlX3BhdGggKHN0cik6IFRoZSBwYXRoIHRvIHRoZSBmaWxlIHRvIGJlIHZpZXdlZC4KICAgIC0gc3RhcnRfbGluZSAoaW50LCBvcHRpb25hbCk6IFN0YXJ0aW5nIGxpbmUgbnVtYmVyICgxLWluZGV4ZWQpLiBJZiBOb25lLCBzdGFydHMgZnJvbSBiZWdpbm5pbmcuCiAgICAtIGVuZF9saW5lIChpbnQsIG9wdGlvbmFsKTogRW5kaW5nIGxpbmUgbnVtYmVyICgxLWluZGV4ZWQpLiBJZiBOb25lLCBnb2VzIHRvIGVuZCBvZiBmaWxlLgogICAgLSBhcm91bmRfc3RyX21hdGNoIChzdHIsIG9wdGlvbmFsKTogU3RyaW5nIHRvIHNlYXJjaCBmb3IuIElmIHByb3ZpZGVkLCBzaG93cyBsaW5lcyBhcm91bmQgbWF0Y2hlcy4KICAgIC0gZGlzdF9mcm9tX21hdGNoIChpbnQsIG9wdGlvbmFsKTogTnVtYmVyIG9mIGxpbmVzIHRvIHNob3cgYmVmb3JlIGFuZCBhZnRlciBlYWNoIG1hdGNoLiBEZWZhdWx0cyB0byAxMC4KICAgIFJldHVybnM6CiAgICBBIHN0cmluZyBjb250YWluaW5nIHRoZSBmaWxlIGNvbnRlbnRzIHdpdGggbGluZSBudW1iZXJzLAogICAgZmlsdGVyZWQgYWNjb3JkaW5nIHRvIHRoZSBzcGVjaWZpZWQgcGFyYW1ldGVycy4KICAgICIiIgogICAgZW5jb2RpbmdzID0gWyd1dGYtOCcsICd1dGYtMTYnLCAndXRmLTE2bGUnLCAnYXNjaWknLCAnY3AxMjUyJywgJ2lzby04ODU5LTEnXQogICAgc3RhcnRfbGluZSA9IGludChzdGFydF9saW5lKSBpZiBzdGFydF9saW5lIGlzIG5vdCBOb25lIGVsc2UgTm9uZQogICAgZW5kX2xpbmUgPSBpbnQoZW5kX2xpbmUpIGlmIGVuZF9saW5lIGlzIG5vdCBOb25lIGVsc2UgTm9uZQogICAgZGlzdF9mcm9tX21hdGNoID0gaW50KGRpc3RfZnJvbV9tYXRjaCkgaWYgZGlzdF9mcm9tX21hdGNoIGlzIG5vdCBOb25lIGVsc2UgTm9uZQogICAgZm9yIGVuY29kaW5nIGluIGVuY29kaW5nczoKICAgICAgICB0cnk6CiAgICAgICAgICAgIHdpdGggb3BlbihmaWxlX3BhdGgsICdyJywgZW5jb2Rpbmc9ZW5jb2RpbmcpIGFzIGZpbGU6CiAgICAgICAgICAgICAgICBsaW5lcyA9IGZpbGUucmVhZGxpbmVzKCkKICAgICAgICAgICAgaWYgYXJvdW5kX3N0cl9tYXRjaDoKICAgICAgICAgICAgICAgIG1hdGNoaW5nX2xpbmVfbnVtYmVycyA9IFtdCiAgICAgICAgICAgICAgICBmb3IgaSwgbGluZSBpbiBlbnVtZXJhdGUobGluZXMpOgogICAgICAgICAgICAgICAgICAgIGlmIGFyb3VuZF9zdHJfbWF0Y2ggaW4gbGluZToKICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hpbmdfbGluZV9udW1iZXJzLmFwcGVuZChpKQogICAgICAgICAgICAgICAgaWYgbm90IG1hdGNoaW5nX2xpbmVfbnVtYmVyczoKICAgICAgICAgICAgICAgICAgICByZXR1cm4gZiJObyBtYXRjaGVzIGZvdW5kIGZvciAne2Fyb3VuZF9zdHJfbWF0Y2h9JyIKICAgICAgICAgICAgICAgIGxpbmVfcmFuZ2VzID0gc2V0KCkKICAgICAgICAgICAgICAgIGZvciBtYXRjaF9saW5lIGluIG1hdGNoaW5nX2xpbmVfbnVtYmVyczoKICAgICAgICAgICAgICAgICAgICBzdGFydCA9IG1heCgwLCBtYXRjaF9saW5lIC0gZGlzdF9mcm9tX21hdGNoKQogICAgICAgICAgICAgICAgICAgIGVuZCA9IG1pbihsZW4obGluZXMpLCBtYXRjaF9saW5lICsgZGlzdF9mcm9tX21hdGNoICsgMSkKICAgICAgICAgICAgICAgICAgICBmb3IgbGluZV9udW0gaW4gcmFuZ2Uoc3RhcnQsIGVuZCk6CiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVfcmFuZ2VzLmFkZChsaW5lX251bSkKICAgICAgICAgICAgICAgIHNvcnRlZF9saW5lcyA9IHNvcnRlZChsaW5lX3JhbmdlcykKICAgICAgICAgICAgICAgIG51bWJlcmVkX2xpbmVzID0gW10KICAgICAgICAgICAgICAgIHByZXZfbGluZSA9IE5vbmUKICAgICAgICAgICAgICAgIGZvciBsaW5lX251bSBpbiBzb3J0ZWRfbGluZXM6CiAgICAgICAgICAgICAgICAgICAgaWYgcHJldl9saW5lIGlzIG5vdCBOb25lIGFuZCBsaW5lX251bSA+IHByZXZfbGluZSArIDE6CiAgICAgICAgICAgICAgICAgICAgICAgIG51bWJlcmVkX2xpbmVzLmFwcGVuZCgnLi4uJykKICAgICAgICAgICAgICAgICAgICBudW1iZXJlZF9saW5lcy5hcHBlbmQoZid7bGluZV9udW0gKyAxfTp7bGluZXNbbGluZV9udW1dLnJzdHJpcCgpfScpCiAgICAgICAgICAgICAgICAgICAgcHJldl9saW5lID0gbGluZV9udW0KICAgICAgICAgICAgICAgIHJldHVybiAnXG4nLmpvaW4obnVtYmVyZWRfbGluZXMpCiAgICAgICAgICAgIGVsc2U6CiAgICAgICAgICAgICAgICBzdGFydF9pZHggPSBzdGFydF9saW5lIC0gMSBpZiBzdGFydF9saW5lIGVsc2UgMAogICAgICAgICAgICAgICAgZW5kX2lkeCA9IGVuZF9saW5lIGlmIGVuZF9saW5lIGVsc2UgbGVuKGxpbmVzKQogICAgICAgICAgICAgICAgc3RhcnRfaWR4ID0gbWF4KDAsIHN0YXJ0X2lkeCkKICAgICAgICAgICAgICAgIGVuZF9pZHggPSBtaW4obGVuKGxpbmVzKSwgZW5kX2lkeCkKICAgICAgICAgICAgICAgIGlmIHN0YXJ0X2lkeCA+PSBsZW4obGluZXMpOgogICAgICAgICAgICAgICAgICAgIHJldHVybiBmJ0Vycm9yOiBzdGFydF9saW5lICh7c3RhcnRfbGluZX0pIGV4Y2VlZHMgZmlsZSBsZW5ndGggKHtsZW4obGluZXMpfSBsaW5lcyknCiAgICAgICAgICAgICAgICBzZWxlY3RlZF9saW5lcyA9IGxpbmVzW3N0YXJ0X2lkeDplbmRfaWR4XQogICAgICAgICAgICAgICAgbnVtYmVyZWRfbGluZXMgPSBbZid7aSArIHN0YXJ0X2lkeCArIDF9OntsaW5lLnJzdHJpcCgpfScgZm9yIGksIGxpbmUgaW4gZW51bWVyYXRlKHNlbGVjdGVkX2xpbmVzKV0KICAgICAgICAgICAgICAgIHJldHVybiAnXG4nLmpvaW4obnVtYmVyZWRfbGluZXMpCiAgICAgICAgZXhjZXB0IFVuaWNvZGVEZWNvZGVFcnJvcjoKICAgICAgICAgICAgY29udGludWUKICAgIHJldHVybiBmIkVycm9yOiBVbmFibGUgdG8gcmVhZCBmaWxlIHdpdGggYW55IG9mIHRoZSBhdHRlbXB0ZWQgZW5jb2RpbmdzOiB7JywgJy5qb2luKGVuY29kaW5ncyl9IpRo4mhdjAluYW1lc3BhY2WUaGSML19fcnVudGltZV9fLmR5bmFtaWNfbW9kdWxlXy0xMjc0NTI0NTc2MDQxOTcwNDg0lIWUUpR9lChoN2hMaDZOaFlOaFtOaFxoXWgUaF9oFWhgaBhoYWhiaGZoZ2hpaDRoa2hsaG5ob2hxaHJodGh1aHhoeWh7aHxofmg1aH9ogGiCaINohGiFaIZoh2iIaIloimiLaI9okGiRaJJok2iUaJVolmiXaJhomWiaaJtonGidaJ5on2hGaE9ooGihaKJoo2ikaKZop2ipaKporGitaK5or2i3jAh2aWV3X2RpcpRoq2oUAQAAk5SMGF9yZW1vdmVfYm9tX2Zyb21fY29udGVudJRoq2oWAQAAk5SMCnBhdGNoX2VkaXSUaKtqGAEAAJOUjBpfZmluZF9tYXRjaF93aXRoX2hpZXJhcmNoeZRoq2oaAQAAk5SMHl9jaGVja19leGFjdF9tYXRjaF9hdF9wb3NpdGlvbpRoq2ocAQAAk5SMGl9maW5kX2V4YWN0X21hdGNoX2FueXdoZXJllGirah4BAACTlIwjX2NoZWNrX3doaXRlc3BhY2VfbWF0Y2hfYXRfcG9zaXRpb26UaKtqIAEAAJOUjB9fZmluZF93aGl0ZXNwYWNlX21hdGNoX2FueXdoZXJllGiraiIBAACTlIwcX2FkanVzdF9hZGRpdGlvbnNfdG9fY29udGV4dJRoq2okAQAAk5SMFl9maW5kX2Jsb2NrX2luX2NvbnRlbnSUaKtqJgEAAJOUjBVfZ2V0X2xpbmVfaW5kZW50YXRpb26UaKtqKAEAAJOUjA9fbm9ybWFsaXplX3BhdGiUaKtqKgEAAJOUjBdfbm9ybWFsaXplX2hlYWRlcl9saW5lc5Roq2osAQAAk5R1YowJY29kZV9oYXNolIwgYjE2MjFlMmMxYjIwMjk2ZTIxYThkODZiNjFlYjliY2GUdWJ1fZQoaDZovGhSagQBAAB1hpRiaP0oaDdoTGg2TmhZTmhaTmhbTmhcaF1oFGhfaBVoYGgYaGFoYmhmaGdoaWg0aGtobGhuaG9ocWhyaHRodWh4aHloe2h8aH5oNWh/aIBogmiDaIRohWiGaIdoiGiJaIpoi2iPaJBokWiSaJNolGiVaJZol2iYaJlommibaJxonWieaJ9oRmhPaKBooWiiaKNopGimaKdoqWiqaKxorWiuaK9ot2oUAQAAahUBAABqFgEAAGoXAQAAahgBAABqGQEAAGoaAQAAahsBAABqHAEAAGodAQAAah4BAABqHwEAAGogAQAAaiEBAABqIgEAAGojAQAAaiQBAABqJQEAAGomAQAAaicBAABqKAEAAGopAQAAaioBAABqKwEAAGosAQAAai0BAACMDF9fYnVpbHRpbnNfX5RjYnVpbHRpbnMKX19kaWN0X18KdTCMCGJ1aWx0aW5zlIwHZ2V0YXR0cpSTlIwEZGlsbJSMBV9kaWxslJOUjAhfc2V0YXR0cpRqMwEAAIwHc2V0YXR0cpSTlIeUUpRotIwNY2VsbF9jb250ZW50c5RqAQEAAIeUUjBosChoN2hMaDZOaFlOaFpOaFtOaFxoXWgUaF9oFWhgaBhoYWhiaGZoZ2hpaDRoa2hsaG5ob2hxaHJodGh1aHhoeWh7aHxofmg1aH9ogGiCaINohGiFaIZoh2iIaIloimiLaI9okGiRaJJok2iUaJVolmiXaJhomWiaaJtonGidaJ5on2hGaE9ooGihaKJoo2ikaKZop2ipaKporGitaK5or2i3ahQBAABqFQEAAGoWAQAAahcBAABqGAEAAGoZAQAAahoBAABqGwEAAGocAQAAah0BAABqHgEAAGofAQAAaiABAABqIQEAAGoiAQAAaiMBAABqJAEAAGolAQAAaiYBAABqJwEAAGooAQAAaikBAABqKgEAAGorAQAAaiwBAABqLQEAAGoyAQAAY2J1aWx0aW5zCl9fZGljdF9fCnUwahQBAABqFQEAAGoWAQAAahcBAABqGAEAAGoZAQAAahoBAABqGwEAAGocAQAAah0BAABqHgEAAGofAQAAaiABAABqIQEAAGoiAQAAaiMBAABqJAEAAGolAQAAaiYBAABqJwEAAGooAQAAaikBAABqKgEAAGorAQAAaiwBAABqLQEAAGoyAQAAY2J1aWx0aW5zCl9fZGljdF9fCnUwLg==",
      "name": "toolify",
      "hash": "7e65b9d9b17b1a076f7b44a02d8b2a15455be8ac853d6154cedbf8e2f7dea04d",
      "provenance": {
       "module": "dynamic_module_-1274524576041970484",
       "qualname": "toolify"
      }
     },
     "_convert_string_to_type": {
      "__helper_func__": true,
      "pickled": "gASVMwAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjBdfY29udmVydF9zdHJpbmdfdG9fdHlwZZSTlC4=",
      "name": "_convert_string_to_type",
      "hash": "024e40c56cb46e6fe9f52fe7e6e64a3effc17736268ef31195596c6a6be4c311",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "_convert_string_to_type"
      }
     },
     "_log_error_to_file": {
      "__helper_func__": true,
      "pickled": "gASVLgAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjBJfbG9nX2Vycm9yX3RvX2ZpbGWUk5Qu",
      "name": "_log_error_to_file",
      "hash": "c02546b672eb25afd5dc51ea7e1967cbb6fd264ca18ffd15c3cbeccebe4046ba",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "_log_error_to_file"
      }
     },
     "difflib": {
      "__module_type__": true,
      "name": "difflib",
      "spec": "difflib"
     },
     "clean_unicode_string": {
      "__imported_callable__": true,
      "pickled": "gASVNQAAAAAAAACMGGJvdHMudXRpbHMudW5pY29kZV91dGlsc5SMFGNsZWFuX3VuaWNvZGVfc3RyaW5nlJOULg==",
      "name": "clean_unicode_string",
      "hash": "2316910285c0cef615cfa77d71869e6841488cbe386a2ae90e4f7ebf187fec5e",
      "provenance": {
       "module": "bots.utils.unicode_utils",
       "qualname": "clean_unicode_string"
      }
     },
     "_read_file_bom_safe": {
      "__helper_func__": true,
      "pickled": "gASVMQAAAAAAAACMFWJvdHMudG9vbHMuY29kZV90b29sc5SME19yZWFkX2ZpbGVfYm9tX3NhZmWUk5Qu",
      "name": "_read_file_bom_safe",
      "hash": "7eebe2a51e84122e8270a51d6dd427aa2f4ef27a8fd569504fa218fff0fea0df",
      "provenance": {
       "module": "bots.tools.code_tools",
       "qualname": "_read_file_bom_safe"
      }
     },
     "_write_file_bom_safe": {
      "__helper_func__": true,
      "pickled": "gASVMgAAAAAAAACMFWJvdHMudG9vbHMuY29kZV90b29sc5SMFF93cml0ZV9maWxlX2JvbV9zYWZllJOULg==",
      "name": "_write_file_bom_safe",
      "hash": "4673b28157f3244ba7c580ec0d8c3dffb0286aaa8710857f8a16c0ec76504dcf",
      "provenance": {
       "module": "bots.tools.code_tools",
       "qualname": "_write_file_bom_safe"
      }
     },
     "view": {
      "__imported_callable__": true,
      "pickled": "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ZSBjb250ZW50cyB3aXRoIGxpbmUgbnVtYmVycywKICAgIGZpbHRlcmVkIGFjY29yZGluZyB0byB0aGUgc3BlY2lmaWVkIHBhcmFtZXRlcnMuCiAgICCUKIwFdXRmLTiUjAZ1dGYtMTaUjAh1dGYtMTZsZZSMBWFzY2lplIwGY3AxMjUylIwKaXNvLTg4NTktMZR0lE6MAXKUjAhlbmNvZGluZ5SFlIwWTm8gbWF0Y2hlcyBmb3VuZCBmb3IgJ5SMASeUSwBLAYwDLi4ulIwBOpSMAQqUjBNFcnJvcjogc3RhcnRfbGluZSAolIwXKSBleGNlZWRzIGZpbGUgbGVuZ3RoICiUjAcgbGluZXMplIxARXJyb3I6IFVuYWJsZSB0byByZWFkIGZpbGUgd2l0aCBhbnkgb2YgdGhlIGF0dGVtcHRlZCBlbmNvZGluZ3M6IJSMAiwglHSUKIwDaW50lIwEb3BlbpSMCXJlYWRsaW5lc5SMCWVudW1lcmF0ZZSMBmFwcGVuZJSMA3NldJSMA21heJSMA21pbpSMA2xlbpSMBXJhbmdllIwDYWRklIwGc29ydGVklIwGcnN0cmlwlIwEam9pbpSMElVuaWNvZGVEZWNvZGVFcnJvcpR0lCiMCWZpbGVfcGF0aJSMCnN0YXJ0X2xpbmWUjAhlbmRfbGluZZSMEGFyb3VuZF9zdHJfbWF0Y2iUjA9kaXN0X2Zyb21fbWF0Y2iUjAllbmNvZGluZ3OUaEOMBGZpbGWUjAVsaW5lc5SMFW1hdGNoaW5nX2xpbmVfbnVtYmVyc5SMAWmUjARsaW5llIwLbGluZV9yYW5nZXOUjAptYXRjaF9saW5llIwFc3RhcnSUjANlbmSUjAhsaW5lX251bZSMDHNvcnRlZF9saW5lc5SMDm51bWJlcmVkX2xpbmVzlIwJcHJldl9saW5llIwJc3RhcnRfaWR4lIwHZW5kX2lkeJSMDnNlbGVjdGVkX2xpbmVzlHSUaCJoLmguS09CgQIAAIAA8hwAEVEBgEnYJC7QJDqUE5BalB/ABIBK2CAo0CA0jHOQOIx9uCSASNguPdAuSZRjmC/UFirIdIBP3BQdiAjwAiQJFdwRFZBpoBOoeNUROLhE2Bgcnw6ZDtMYKJAF9wMAEjniDx/YKCrQECXcHyioFdYfL5FHkEGQdNgXJ6g00hcv2Bgt1xg00Rg0sFHVGDfwBQAgMPEGABgt2B0z0DRE0DNFwFHQG0fSFEfcHiGbZZAL2yI3kErcHB+gAaA6sA/RIz/THECQRdwaHZxjoCWbaqgqsH/RKkbIEdEqStMaS5BD3CQpqCWwE9YkNZgI2Bgjnw+ZD6gI1Rgx8QMAJTbwBwAjOPQKACAmoGvTHzKQDNghI5AO2BwgkAnbICyQSNgXINAXLLAYuEnIAblN0jFJ2Bgm1xgt0RgtqGXUGDTYFCLXFCnRFCmoWLgBqVyoTrghuEXAKLlP1zxS0TxS0zxU0DtV0CpW1BRX2CAokUnwCQAhLfAKABgcl3mReaAe0xcw0hAw4S44mEqoEZpOuGGQCdkmLpkotEO4BbNKkAfcHB+gAaA50xwtkAncGh2cY6Alm2qoJ9MaMpAH2BMcpAOgRaMK0hMq2B0wsBqwDNA8U9RUV9BYXdNUXtBTX9BfZtAbZ9IUZ9ghJqB5sBfQITmQDtxYYdBicNRYcdQhctFYcclXyFHQUFSgUagZoV2wUdElNtAkN7BxuBS/G7kbux24D9IiSNBYcZAO0SFy2Bcbl3mReaAe0xcw0hAw8EcBABUe8EwBAA5OAchkz2nJadBYYdNOYtBNY9ALZNAEZPdJAQASOdEROPzzQAEAInMB+OQPIfIAAQkV2gwU8AMBCRX6lENPuQ5INgLBBxFIIwXBGCJINgLBOxpINgLCGEMKSDYCxSVBGEg2AscAE0g2AscTJUgwCMc4E0g2AsgjBUgtCcgoDkg2Asg2CUkDBckCAUkDBZQpKXSUUpR9lGgsaC1zaC4oTk5OjAIxMJR0lE50lFKUfZR9lCiMB19fZG9jX1+UaDqMD19fYW5ub3RhdGlvbnNfX5R9lChoYGgAjApfbG9hZF90eXBllJOUaBSFlFKUaGFoiGhiaIhoY2iIaGRoiHV1hpRijBJfX21vZHVsZV9jb250ZXh0X1+UjBRib3RzLmZvdW5kYXRpb24uYmFzZZSMDU1vZHVsZUNvbnRleHSUk5QpgZR9lCiMBG5hbWWUaC2MBnNvdXJjZZRYwBgAAGRlZiB0b29saWZ5KGRlc2NyaXB0aW9uOiBzdHIgPSBOb25lKToKICAgICIiIgogICAgQ29udmVydCBhbnkgZnVuY3Rpb24gaW50byBhIGJvdCB0b29sIHdpdGggc3RyaW5nLWluLCBzdHJpbmctb3V0IGludGVyZmFjZS4KCiAgICAtIENvbnZlcnRzIHN0cmluZyBpbnB1dHMgdG8gcHJvcGVyIHR5cGVzIHVzaW5nIHR5cGUgaGludHMKICAgIC0gRW5zdXJlcyBzdHJpbmcgb3V0cHV0IChKU09OIGZvciBjb21wbGV4IHR5cGVzKQogICAgLSBXcmFwcyBpbiBlcnJvciBoYW5kbGluZyAocmV0dXJucyBlcnJvciBzdHJpbmdzLCBuZXZlciByYWlzZXMpCiAgICAtIEVuaGFuY2VzIGRvY3N0cmluZyBpZiBkZXNjcmlwdGlvbiBwcm92aWRlZAoKICAgIEFyZ3M6CiAgICAgICAgZGVzY3JpcHRpb24gKHN0ciwgb3B0aW9uYWwpOiBPdmVycmlkZSB0aGUgZnVuY3Rpb24ncyBkb2NzdHJpbmcKCiAgICBFeGFtcGxlOgogICAgICAgIEB0b29saWZ5KCkKICAgICAgICBkZWYgYWRkX251bWJlcnMoeDogaW50LCB5OiBpbnQgPSAwKSAtPiBpbnQ6CiAgICAgICAgICAgIHJldHVybiB4ICsgeQoKICAgICAgICBAdG9vbGlmeSgiQ2FsY3VsYXRlIHRoZSBhcmVhIG9mIGEgY2lyY2xlIikKICAgICAgICBkZWYgYXJlYShyYWRpdXM6IGZsb2F0KSAtPiBmbG9hdDoKICAgICAgICAgICAgcmV0dXJuIDMuMTQxNTkgKiByYWRpdXMgKiByYWRpdXMKICAgICIiIgoKICAgIGRlZiBkZWNvcmF0b3IoZnVuYyk6CiAgICAgICAgQGZ1bmN0b29scy53cmFwcyhmdW5jKQogICAgICAgIGRlZiB3cmFwcGVyKCphcmdzLCAqKmt3YXJncyk6CiAgICAgICAgICAgIHRyeToKICAgICAgICAgICAgICAgICMgQ29udmVydCBzdHJpbmcgaW5wdXRzIHRvIHByb3BlciB0eXBlcyB1c2luZyB0eXBlIGhpbnRzCiAgICAgICAgICAgICAgICBjb252ZXJ0ZWRfYXJncywgY29udmVydGVkX2t3YXJncyA9IF9jb252ZXJ0X3Rvb2xfaW5wdXRzKGZ1bmMsIGFyZ3MsIGt3YXJncykKCiAgICAgICAgICAgICAgICAjIENhbGwgb3JpZ2luYWwgZnVuY3Rpb24KICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmMoKmNvbnZlcnRlZF9hcmdzLCAqKmNvbnZlcnRlZF9rd2FyZ3MpCgogICAgICAgICAgICAgICAgIyBDb252ZXJ0IHJlc3VsdCB0byBzdHJpbmcKICAgICAgICAgICAgICAgIHJldHVybiBfY29udmVydF90b29sX291dHB1dChyZXN1bHQpCgogICAgICAgICAgICBleGNlcHQgS2V5Ym9hcmRJbnRlcnJ1cHQgYXMgZToKICAgICAgICAgICAgICAgICMgQ29udmVydCBLZXlib2FyZEludGVycnVwdCB0byBUb29sRXhlY3V0aW9uRXJyb3IgdG8gcHJldmVudCBpdCBmcm9tCiAgICAgICAgICAgICAgICAjIGJ1YmJsaW5nIHVwIHRvIENMSSBhbmQgYmVpbmcgdHJlYXRlZCBhcyB1c2VyIEN0cmwrQwogICAgICAgICAgICAgICAgZnJvbSBib3RzLnV0aWxzLmhlbHBlcnMgaW1wb3J0IF9wcm9jZXNzX2Vycm9yCgogICAgICAgICAgICAgICAgdG9vbF9lcnJvciA9IFRvb2xFeGVjdXRpb25FcnJvcihmIlRvb2wgZXhlY3V0aW9uIGludGVycnVwdGVkOiB7c3RyKGUpfSIpCiAgICAgICAgICAgICAgICByZXR1cm4gX3Byb2Nlc3NfZXJyb3IodG9vbF9lcnJvcikKCiAgICAgICAgICAgIGV4Y2VwdCBUeXBlRXJyb3IgYXMgZToKICAgICAgICAgICAgICAgICMgQ2hlY2sgaWYgdGhpcyBpcyBhIG1pc3NpbmcgcmVxdWlyZWQgYXJndW1lbnQgZXJyb3IKICAgICAgICAgICAgICAgIGVycm9yX21zZyA9IHN0cihlKQogICAgICAgICAgICAgICAgaWYgIm1pc3NpbmciIGluIGVycm9yX21zZyBhbmQgInJlcXVpcmVkIiBpbiBlcnJvcl9tc2cgYW5kICJhcmd1bWVudCIgaW4gZXJyb3JfbXNnOgogICAgICAgICAgICAgICAgICAgICMgQWRkIHNwZWNpYWwgbWVzc2FnZSBmb3Igb3V0cHV0IHRva2VuIGxpbWl0YXRpb24KICAgICAgICAgICAgICAgICAgICBlbmhhbmNlZF9lcnJvciA9IFR5cGVFcnJvcigKICAgICAgICAgICAgICAgICAgICAgICAgZiJ7ZXJyb3JfbXNnfVxuXG4iCiAgICAgICAgICAgICAgICAgICAgICAgIGYi4pqg77iPICBUaGlzIGVycm9yIGlzIGNvbW1vbmx5IGNhdXNlZCBieSBoaXR0aW5nIHRoZSBtYXhfdG9rZW5zIGxpbWl0IGJlZm9yZSBjb21wbGV0aW5nIHRoZSB0b29sIGNhbGwuXG4iCiAgICAgICAgICAgICAgICAgICAgICAgIGYiVGhlIHJlc3BvbnNlIHdhcyB0cnVuY2F0ZWQgbWlkLXBhcmFtZXRlciwgbWFraW5nIGl0IGFwcGVhciB0aGF0IHJlcXVpcmVkIHBhcmFtZXRlcnMgYXJlIG1pc3NpbmcuXG4iCiAgICAgICAgICAgICAgICAgICAgICAgIGYiVG8gZml4IHRoaXM6IFdvcmsgaW4gU01BTExFUiBDSFVOS1MuIEVkaXQgZmV3ZXIgbGluZXMgYXQgYSB0aW1lLCAiCiAgICAgICAgICAgICAgICAgICAgICAgIGYib3IgYnJlYWsgeW91ciB0YXNrIGludG8gbXVsdGlwbGUgc3RlcHMuIgogICAgICAgICAgICAgICAgICAgICkKICAgICAgICAgICAgICAgICAgICBmcm9tIGJvdHMudXRpbHMuaGVscGVycyBpbXBvcnQgX3Byb2Nlc3NfZXJyb3IKCiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9wcm9jZXNzX2Vycm9yKGVuaGFuY2VkX2Vycm9yKQogICAgICAgICAgICAgICAgZWxzZToKICAgICAgICAgICAgICAgICAgICBmcm9tIGJvdHMudXRpbHMuaGVscGVycyBpbXBvcnQgX3Byb2Nlc3NfZXJyb3IKCiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9wcm9jZXNzX2Vycm9yKGUpCiAgICAgICAgICAgIGV4Y2VwdCBFeGNlcHRpb24gYXMgZToKICAgICAgICAgICAgICAgIGZyb20gYm90cy51dGlscy5oZWxwZXJzIGltcG9ydCBfcHJvY2Vzc19lcnJvcgoKICAgICAgICAgICAgICAgIHJldHVybiBfcHJvY2Vzc19lcnJvcihlKQoKICAgICAgICAjIFVwZGF0ZSBkb2NzdHJpbmcgaWYgZGVzY3JpcHRpb24gcHJvdmlkZWQKICAgICAgICBpZiBkZXNjcmlwdGlvbjoKICAgICAgICAgICAgd3JhcHBlci5fX2RvY19fID0gZGVzY3JpcHRpb24KICAgICAgICBlbGlmIG5vdCB3cmFwcGVyLl9fZG9jX186CiAgICAgICAgICAgICMgR2VuZXJhdGUgbWluaW1hbCBkb2NzdHJpbmcgZnJvbSBmdW5jdGlvbiBuYW1lCiAgICAgICAgICAgIHdyYXBwZXIuX19kb2NfXyA9IGYiRXhlY3V0ZSB7ZnVuYy5fX25hbWVfXy5yZXBsYWNlKCdfJywgJyAnKX0iCgogICAgICAgIHJldHVybiB3cmFwcGVyCgogICAgcmV0dXJuIGRlY29yYXRvcgoKQHRvb2xpZnkoKQpkZWYgdmlldyhmaWxlX3BhdGg6IHN0ciwgc3RhcnRfbGluZTogc3RyPU5vbmUsIGVuZF9saW5lOiBzdHI9Tm9uZSwgYXJvdW5kX3N0cl9tYXRjaDogc3RyPU5vbmUsIGRpc3RfZnJvbV9tYXRjaDogc3RyPScxMCcpOgogICAgIiIiCiAgICBEaXNwbGF5IHRoZSBjb250ZW50cyBvZiBhIGZpbGUgd2l0aCBsaW5lIG51bWJlcnMuCiAgICBQYXJhbWV0ZXJzOgogICAgLSBmaWxlX3BhdGggKHN0cik6IFRoZSBwYXRoIHRvIHRoZSBmaWxlIHRvIGJlIHZpZXdlZC4KICAgIC0gc3RhcnRfbGluZSAoaW50LCBvcHRpb25hbCk6IFN0YXJ0aW5nIGxpbmUgbnVtYmVyICgxLWluZGV4ZWQpLiBJZiBOb25lLCBzdGFydHMgZnJvbSBiZWdpbm5pbmcuCiAgICAtIGVuZF9saW5lIChpbnQsIG9wdGlvbmFsKTogRW5kaW5nIGxpbmUgbnVtYmVyICgxLWluZGV4ZWQpLiBJZiBOb25lLCBnb2VzIHRvIGVuZCBvZiBmaWxlLgogICAgLSBhcm91bmRfc3RyX21hdGNoIChzdHIsIG9wdGlvbmFsKTogU3RyaW5nIHRvIHNlYXJjaCBmb3IuIElmIHByb3ZpZGVkLCBzaG93cyBsaW5lcyBhcm91bmQgbWF0Y2hlcy4KICAgIC0gZGlzdF9mcm9tX21hdGNoIChpbnQsIG9wdGlvbmFsKTogTnVtYmVyIG9mIGxpbmVzIHRvIHNob3cgYmVmb3JlIGFuZCBhZnRlciBlYWNoIG1hdGNoLiBEZWZhdWx0cyB0byAxMC4KICAgIFJldHVybnM6CiAgICBBIHN0cmluZyBjb250YWluaW5nIHRoZSBmaWxlIGNvbnRlbnRzIHdpdGggbGluZSBudW1iZXJzLAogICAgZmlsdGVyZWQgYWNjb3JkaW5nIHRvIHRoZSBzcGVjaWZpZWQgcGFyYW1ldGVycy4KICAgICIiIgogICAgZW5jb2RpbmdzID0gWyd1dGYtOCcsICd1dGYtMTYnLCAndXRmLTE2bGUnLCAnYXNjaWknLCAnY3AxMjUyJywgJ2lzby04ODU5LTEnXQogICAgc3RhcnRfbGluZSA9IGludChzdGFydF9saW5lKSBpZiBzdGFydF9saW5lIGlzIG5vdCBOb25lIGVsc2UgTm9uZQogICAgZW5kX2xpbmUgPSBpbnQoZW5kX2xpbmUpIGlmIGVuZF9saW5lIGlzIG5vdCBOb25lIGVsc2UgTm9uZQogICAgZGlzdF9mcm9tX21hdGNoID0gaW50KGRpc3RfZnJvbV9tYXRjaCkgaWYgZGlzdF9mcm9tX21hdGNoIGlzIG5vdCBOb25lIGVsc2UgTm9uZQogICAgZm9yIGVuY29kaW5nIGluIGVuY29kaW5nczoKICAgICAgICB0cnk6CiAgICAgICAgICAgIHdpdGggb3BlbihmaWxlX3BhdGgsICdyJywgZW5jb2Rpbmc9ZW5jb2RpbmcpIGFzIGZpbGU6CiAgICAgICAgICAgICAgICBsaW5lcyA9IGZpbGUucmVhZGxpbmVzKCkKICAgICAgICAgICAgaWYgYXJvdW5kX3N0cl9tYXRjaDoKICAgICAgICAgICAgICAgIG1hdGNoaW5nX2xpbmVfbnVtYmVycyA9IFtdCiAgICAgICAgICAgICAgICBmb3IgaSwgbGluZSBpbiBlbnVtZXJhdGUobGluZXMpOgogICAgICAgICAgICAgICAgICAgIGlmIGFyb3VuZF9zdHJfbWF0Y2ggaW4gbGluZToKICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hpbmdfbGluZV9udW1iZXJzLmFwcGVuZChpKQogICAgICAgICAgICAgICAgaWYgbm90IG1hdGNoaW5nX2xpbmVfbnVtYmVyczoKICAgICAgICAgICAgICAgICAgICByZXR1cm4gZiJObyBtYXRjaGVzIGZvdW5kIGZvciAne2Fyb3VuZF9zdHJfbWF0Y2h9JyIKICAgICAgICAgICAgICAgIGxpbmVfcmFuZ2VzID0gc2V0KCkKICAgICAgICAgICAgICAgIGZvciBtYXRjaF9saW5lIGluIG1hdGNoaW5nX2xpbmVfbnVtYmVyczoKICAgICAgICAgICAgICAgICAgICBzdGFydCA9IG1heCgwLCBtYXRjaF9saW5lIC0gZGlzdF9mcm9tX21hdGNoKQogICAgICAgICAgICAgICAgICAgIGVuZCA9IG1pbihsZW4obGluZXMpLCBtYXRjaF9saW5lICsgZGlzdF9mcm9tX21hdGNoICsgMSkKICAgICAgICAgICAgICAgICAgICBmb3IgbGluZV9udW0gaW4gcmFuZ2Uoc3RhcnQsIGVuZCk6CiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVfcmFuZ2VzLmFkZChsaW5lX251bSkKICAgICAgICAgICAgICAgIHNvcnRlZF9saW5lcyA9IHNvcnRlZChsaW5lX3JhbmdlcykKICAgICAgICAgICAgICAgIG51bWJlcmVkX2xpbmVzID0gW10KICAgICAgICAgICAgICAgIHByZXZfbGluZSA9IE5vbmUKICAgICAgICAgICAgICAgIGZvciBsaW5lX251bSBpbiBzb3J0ZWRfbGluZXM6CiAgICAgICAgICAgICAgICAgICAgaWYgcHJldl9saW5lIGlzIG5vdCBOb25lIGFuZCBsaW5lX251bSA+IHByZXZfbGluZSArIDE6CiAgICAgICAgICAgICAgICAgICAgICAgIG51bWJlcmVkX2xpbmVzLmFwcGVuZCgnLi4uJykKICAgICAgICAgICAgICAgICAgICBudW1iZXJlZF9saW5lcy5hcHBlbmQoZid7bGluZV9udW0gKyAxfTp7bGluZXNbbGluZV9udW1dLnJzdHJpcCgpfScpCiAgICAgICAgICAgICAgICAgICAgcHJldl9saW5lID0gbGluZV9udW0KICAgICAgICAgICAgICAgIHJldHVybiAnXG4nLmpvaW4obnVtYmVyZWRfbGluZXMpCiAgICAgICAgICAgIGVsc2U6CiAgICAgICAgICAgICAgICBzdGFydF9pZHggPSBzdGFydF9saW5lIC0gMSBpZiBzdGFydF9saW5lIGVsc2UgMAogICAgICAgICAgICAgICAgZW5kX2lkeCA9IGVuZF9saW5lIGlmIGVuZF9saW5lIGVsc2UgbGVuKGxpbmVzKQogICAgICAgICAgICAgICAgc3RhcnRfaWR4ID0gbWF4KDAsIHN0YXJ0X2lkeCkKICAgICAgICAgICAgICAgIGVuZF9pZHggPSBtaW4obGVuKGxpbmVzKSwgZW5kX2lkeCkKICAgICAgICAgICAgICAgIGlmIHN0YXJ0X2lkeCA+PSBsZW4obGluZXMpOgogICAgICAgICAgICAgICAgICAgIHJldHVybiBmJ0Vycm9yOiBzdGFydF9saW5lICh7c3RhcnRfbGluZX0pIGV4Y2VlZHMgZmlsZSBsZW5ndGggKHtsZW4obGluZXMpfSBsaW5lcyknCiAgICAgICAgICAgICAgICBzZWxlY3RlZF9saW5lcyA9IGxpbmVzW3N0YXJ0X2lkeDplbmRfaWR4XQogICAgICAgICAgICAgICAgbnVtYmVyZWRfbGluZXMgPSBbZid7aSArIHN0YXJ0X2lkeCArIDF9OntsaW5lLnJzdHJpcCgpfScgZm9yIGksIGxpbmUgaW4gZW51bWVyYXRlKHNlbGVjdGVkX2xpbmVzKV0KICAgICAgICAgICAgICAgIHJldHVybiAnXG4nLmpvaW4obnVtYmVyZWRfbGluZXMpCiAgICAgICAgZXhjZXB0IFVuaWNvZGVEZWNvZGVFcnJvcjoKICAgICAgICAgICAgY29udGludWUKICAgIHJldHVybiBmIkVycm9yOiBVbmFibGUgdG8gcmVhZCBmaWxlIHdpdGggYW55IG9mIHRoZSBhdHRlbXB0ZWQgZW5jb2RpbmdzOiB7JywgJy5qb2luKGVuY29kaW5ncyl9IpRoYIwjZHluYW1pY19tb2R1bGVfLTcwODI5OTEzODc1NDcwMDEyMzOUjAluYW1lc3BhY2WUaACMDl9pbXBvcnRfbW9kdWxllJOUjC9fX3J1bnRpbWVfXy5keW5hbWljX21vZHVsZV8tMTI3NDUyNDU3NjA0MTk3MDQ4NJSFlFKUfZQoaCxoLWiCTowLX19wYWNrYWdlX1+UTowIX19zcGVjX1+UTowIX19maWxlX1+UaJNoD4wTYm90cy5kZXYuZGVjb3JhdG9yc5RoD5OUaBBonmgQk5RoE2ieaBOTlIwDYXN0lGiWaKKFlFKUjAhkYXRldGltZZRolmilhZRSlIwJZnVuY3Rvb2xzlGiWaKiFlFKUjAdpbnNwZWN0lGiWaKuFlFKUjAdsb2dnaW5nlGiWaK6FlFKUjAJvc5RolmixhZRSlIwDc3lzlGiWjANzeXOUhZRSlIwIdGV4dHdyYXCUaJZouIWUUpSMCXRyYWNlYmFja5Rolmi7hZRSlIwFd3JhcHOUaKhovpOUjANBbnmUjAZ0eXBpbmeUaMCTlIwIQ2FsbGFibGWUaMFow5OUjAhPcHRpb25hbJRowWjFk5SMBFR5cGWUaMFox5OUjBJyZW1vdmVfY29kZV9ibG9ja3OUaBJoyZOUjAZsb2dnZXKUaK6MCWdldExvZ2dlcpSTlGiehZRSlIwMTm9IVFRQRmlsdGVylGieaNCTlIwHbGF6eV9mbpRonmjSk5SMCmxhenlfY2xhc3OUaJ5o1JOUjAxfZ2V0X2NvbnRleHSUaJ5o1pOUjBFfZ2V0X3B5X2ludGVyZmFjZZRonmjYk5SMBGxhenmUaJ5o2pOUjA5kZWJ1Z19vbl9lcnJvcpRonmjck5SMCmxvZ19lcnJvcnOUaJ5o3pOUjAd0b29saWZ5lGgCKGgEKEMEBBYKNpRLAUsASwBLAksCSwNDEocAlwCIAGYBZAGECH0BfAFTAJRYiAIAAAogICAgQ29udmVydCBhbnkgZnVuY3Rpb24gaW50byBhIGJvdCB0b29sIHdpdGggc3RyaW5nLWluLCBzdHJpbmctb3V0IGludGVyZmFjZS4KCiAgICAtIENvbnZlcnRzIHN0cmluZyBpbnB1dHMgdG8gcHJvcGVyIHR5cGVzIHVzaW5nIHR5cGUgaGludHMKICAgIC0gRW5zdXJlcyBzdHJpbmcgb3V0cHV0IChKU09OIGZvciBjb21wbGV4IHR5cGVzKQogICAgLSBXcmFwcyBpbiBlcnJvciBoYW5kbGluZyAocmV0dXJucyBlcnJvciBzdHJpbmdzLCBuZXZlciByYWlzZXMpCiAgICAtIEVuaGFuY2VzIGRvY3N0cmluZyBpZiBkZXNjcmlwdGlvbiBwcm92aWRlZAoKICAgIEFyZ3M6CiAgICAgICAgZGVzY3JpcHRpb24gKHN0ciwgb3B0aW9uYWwpOiBPdmVycmlkZSB0aGUgZnVuY3Rpb24ncyBkb2NzdHJpbmcKCiAgICBFeGFtcGxlOgogICAgICAgIEB0b29saWZ5KCkKICAgICAgICBkZWYgYWRkX251bWJlcnMoeDogaW50LCB5OiBpbnQgPSAwKSAtPiBpbnQ6CiAgICAgICAgICAgIHJldHVybiB4ICsgeQoKICAgICAgICBAdG9vbGlmeSgiQ2FsY3VsYXRlIHRoZSBhcmVhIG9mIGEgY2lyY2xlIikKICAgICAgICBkZWYgYXJlYShyYWRpdXM6IGZsb2F0KSAtPiBmbG9hdDoKICAgICAgICAgICAgcmV0dXJuIDMuMTQxNTkgKiByYWRpdXMgKiByYWRpdXMKICAgIJRoBChDFAYBKAEI/wgBAiwEAQ4FBPwYAkgClEsBSwBLAEsCSwVLE0O6lQGHAJcAdAAAAAAAAAAAAGoDAAAAAAAAAAAAAAAAAAAAAAAAiQCrAQAAAAAAAIgAZgFkAYQIqwAAAAAAAAB9AYkCcgmJAnwBXwIAAAAAAAAAAHwBUwB8AWoEAAAAAAAAAAAAAAAAAAAAAAAAcyRkAokAagYAAAAAAAAAAAAAAAAAAAAAAABqCQAAAAAAAAAAAAAAAAAAAAAAAGQDZASrAgAAAAAAAJsAnQJ8AV8CAAAAAAAAAAB8AVMAlChOaCqMCEV4ZWN1dGUglIwBX5SMASCUdJQoaKhovmiCaCyMB3JlcGxhY2WUdJRoJ2gjhpRoIowJZGVjb3JhdG9ylIwadG9vbGlmeS48bG9jYWxzPi5kZWNvcmF0b3KUSxdDYPmAANwJEo8fiR+YFNMJHvMCKQkp8wMACh/wAikJKfFYAQAMF9geKYhHjE/wCgAQF4gO8AkAEhmXH5If4CAoqBSvHakd1yk+0Sk+uHPAQ9MpSNAoSdAeSohHjE/gDxaIDpRDAJSMC2Rlc2NyaXB0aW9ulIWUaCeFlHSUUpSGlClo8WjthpRoImjgaOBLAUMR+IAA9Cw0BRfwbAEADBXQBBSUaPApaPGFlHSUUpR9lGgsaC1zaOBOhZROdJRSlH2UfZQoaIJo42iDfZRo8WiIc3WGlGKMF19jb252ZXJ0X3N0cmluZ190b190eXBllGieagQBAACTlIwSX2xvZ19lcnJvcl90b19maWxllGieagYBAACTlIwHZGlmZmxpYpRolmoIAQAAhZRSlIwUY2xlYW5fdW5pY29kZV9zdHJpbmeUjBhib3RzLnV0aWxzLnVuaWNvZGVfdXRpbHOUagsBAACTlIwTX3JlYWRfZmlsZV9ib21fc2FmZZSMFWJvdHMudG9vbHMuY29kZV90b29sc5RqDgEAAJOUjBRfd3JpdGVfZmlsZV9ib21fc2FmZZRqDwEAAGoRAQAAk5RoLmg1jAh2aWV3X2RpcpRqDwEAAGoTAQAAk5SMGF9yZW1vdmVfYm9tX2Zyb21fY29udGVudJRqDwEAAGoVAQAAk5SMCnBhdGNoX2VkaXSUag8BAABqFwEAAJOUjBpfZmluZF9tYXRjaF93aXRoX2hpZXJhcmNoeZRqDwEAAGoZAQAAk5SMHl9jaGVja19leGFjdF9tYXRjaF9hdF9wb3NpdGlvbpRqDwEAAGobAQAAk5SMGl9maW5kX2V4YWN0X21hdGNoX2FueXdoZXJllGoPAQAAah0BAACTlIwjX2NoZWNrX3doaXRlc3BhY2VfbWF0Y2hfYXRfcG9zaXRpb26Uag8BAABqHwEAAJOUjB9fZmluZF93aGl0ZXNwYWNlX21hdGNoX2FueXdoZXJllGoPAQAAaiEBAACTlIwcX2FkanVzdF9hZGRpdGlvbnNfdG9fY29udGV4dJRqDwEAAGojAQAAk5SMFl9maW5kX2Jsb2NrX2luX2NvbnRlbnSUag8BAABqJQEAAJOUjBVfZ2V0X2xpbmVfaW5kZW50YXRpb26Uag8BAABqJwEAAJOUjA9fbm9ybWFsaXplX3BhdGiUag8BAABqKQEAAJOUjBdfbm9ybWFsaXplX2hlYWRlcl9saW5lc5RqDwEAAGorAQAAk5R1YowJY29kZV9oYXNolIwgYjE2MjFlMmMxYjIwMjk2ZTIxYThkODZiNjFlYjliY2GUdWJ1fZQoaIJoOmiDaIR1hpRiaPwoaCxoLWiCTmibTowKX19sb2FkZXJfX5ROaJxOaJ1ok2gPaJ9oEGigaBNooWiiaKRopWinaKhoqmiraK1ormiwaLFos2i0aLdouGi6aLtovWi+aL9owGjCaMNoxGjFaMZox2jIaMloymjLaM9o0GjRaNJo02jUaNVo1mjXaNho2WjaaNto3GjdaN5o32jgaP9qBAEAAGoFAQAAagYBAABqBwEAAGoIAQAAagoBAABqCwEAAGoNAQAAag4BAABqEAEAAGoRAQAAahIBAABoLmg1ahMBAABqFAEAAGoVAQAAahYBAABqFwEAAGoYAQAAahkBAABqGgEAAGobAQAAahwBAABqHQEAAGoeAQAAah8BAABqIAEAAGohAQAAaiIBAABqIwEAAGokAQAAaiUBAABqJgEAAGonAQAAaigBAABqKQEAAGoqAQAAaisBAABqLAEAAIwMX19idWlsdGluc19flGNidWlsdGlucwpfX2RpY3RfXwp1MGh7KGgsaC1ogk5om05qMQEAAE5onE5onWiTaA9on2gQaKBoE2ihaKJopGilaKdoqGiqaKtorWiuaLBosWizaLRot2i4aLpou2i9aL5ov2jAaMJow2jEaMVoxmjHaMhoyWjKaMtoz2jQaNFo0mjTaNRo1WjWaNdo2GjZaNpo22jcaN1o3mjfaOBo/2oEAQAAagUBAABqBgEAAGoHAQAAaggBAABqCgEAAGoLAQAAag0BAABqDgEAAGoQAQAAahEBAABqEgEAAGguaDVqEwEAAGoUAQAAahUBAABqFgEAAGoXAQAAahgBAABqGQEAAGoaAQAAahsBAABqHAEAAGodAQAAah4BAABqHwEAAGogAQAAaiEBAABqIgEAAGojAQAAaiQBAABqJQEAAGomAQAAaicBAABqKAEAAGopAQAAaioBAABqKwEAAGosAQAAajIBAABjYnVpbHRpbnMKX19kaWN0X18KdTCMCGJ1aWx0aW5zlIwHZ2V0YXR0cpSTlIwEZGlsbJSMBV9kaWxslJOUjAhfc2V0YXR0cpRqMwEAAIwHc2V0YXR0cpSTlIeUUpRoMowNY2VsbF9jb250ZW50c5Rof4eUUjBoKyhoLGgtaIJOaJtOajEBAABOaJxOaJ1ok2gPaJ9oEGigaBNooWiiaKRopWinaKhoqmiraK1ormiwaLFos2i0aLdouGi6aLtovWi+aL9owGjCaMNoxGjFaMZox2jIaMloymjLaM9o0GjRaNJo02jUaNVo1mjXaNho2WjaaNto3GjdaN5o32jgaP9qBAEAAGoFAQAAagYBAABqBwEAAGoIAQAAagoBAABqCwEAAGoNAQAAag4BAABqEAEAAGoRAQAAahIBAABoLmg1ahMBAABqFAEAAGoVAQAAahYBAABqFwEAAGoYAQAAahkBAABqGgEAAGobAQAAahwBAABqHQEAAGoeAQAAah8BAABqIAEAAGohAQAAaiIBAABqIwEAAGokAQAAaiUBAABqJgEAAGonAQAAaigBAABqKQEAAGoqAQAAaisBAABqLAEAAGoyAQAAY2J1aWx0aW5zCl9fZGljdF9fCnUwLg==",
      "name": "view",
      "hash": "1b8b1f9ef98990e3576882a9dde96444d0ce93c0d0a13309948ad903bfcde189",
      "provenance": {
       "module": "dynamic_module_-1274524576041970484",
       "qualname": "view"
      }
     },
     "view_dir": {
      "__imported_callable__": true,
      "pickled": "gASVJgAAAAAAAACMFWJvdHMudG9vbHMuY29kZV90b29sc5SMCHZpZXdfZGlylJOULg==",
      "name": "view_dir",
      "hash": "4880c8e1efcfe8f8f94accc6ee1197c2029a69a9fa016ddf2497006d0a05569f",
      "provenance": {
       "module": "bots.tools.code_tools",
       "qualname": "view_dir"
      }
     },
     "_remove_bom_from_content": {
      "__helper_func__": true,
      "pickled": "gASVNgAAAAAAAACMFWJvdHMudG9vbHMuY29kZV90b29sc5SMGF9yZW1vdmVfYm9tX2Zyb21fY29udGVudJSTlC4=",
      "name": "_remove_bom_from_content",
      "hash": "d9d446d33da960fcc8b018bd9547231a837f7eb9a2ba7f3c4b816ead1341b18b",
      "provenance": {
       "module": "bots.tools.code_tools",
       "qualname": "_remove_bom_from_content"
      }
     },
     "patch_edit": {
      "__imported_callable__": true,
      "pickled": "gASVKAAAAAAAAACMFWJvdHMudG9vbHMuY29kZV90b29sc5SMCnBhdGNoX2VkaXSUk5Qu",
      "name": "patch_edit",
      "hash": "a9661a3046d1fae3a45b08fbf107dd4a8e1b655c8d5e2575a52dfbcf5446cd76",
      "provenance": {
       "module": "bots.tools.code_tools",
       "qualname": "patch_edit"
      }
     },
     "_find_match_with_hierarchy": {
      "__helper_func__": true,
      "pickled": "gASVOAAAAAAAAACMFWJvdHMudG9vbHMuY29kZV90b29sc5SMGl9maW5kX21hdGNoX3dpdGhfaGllcmFyY2h5lJOULg==",
      "name": "_find_match_with_hierarchy",
      "hash": "72cfaacd68dc4ef6dd01b4d0d154dc1ed416f6dc9f878c0c751e427676175d04",
      "provenance": {
       "module": "bots.tools.code_tools",
       "qualname": "_find_match_with_hierarchy"
      }
     },
     "_check_exact_match_at_position": {
      "__helper_func__": true,
      "pickled": "gASVPAAAAAAAAACMFWJvdHMudG9vbHMuY29kZV90b29sc5SMHl9jaGVja19leGFjdF9tYXRjaF9hdF9wb3NpdGlvbpSTlC4=",
      "name": "_check_exact_match_at_position",
      "hash": "954282a86f378dc83f5c8a5c4e752ce4f656dc2a05bd95b26402cab246431588",
      "provenance": {
       "module": "bots.tools.code_tools",
       "qualname": "_check_exact_match_at_position"
      }
     },
     "_find_exact_match_anywhere": {
      "__helper_func__": true,
      "pickled": "gASVOAAAAAAAAACMFWJvdHMudG9vbHMuY29kZV90b29sc5SMGl9maW5kX2V4YWN0X21hdGNoX2FueXdoZXJllJOULg==",
      "name": "_find_exact_match_anywhere",
      "hash": "6f8df2c5f4ecfdb97043bd57ebcaf73ce2bbc581e6c2e5a6910bd1e30ca00f29",
      "provenance": {
       "module": "bots.tools.code_tools",
       "qualname": "_find_exact_match_anywhere"
      }
     },
     "_check_whitespace_match_at_position": {
      "__helper_func__": true,
      "pickled": "gASVQQAAAAAAAACMFWJvdHMudG9vbHMuY29kZV90b29sc5SMI19jaGVja193aGl0ZXNwYWNlX21hdGNoX2F0X3Bvc2l0aW9ulJOULg==",
      "name": "_check_whitespace_match_at_position",
      "hash": "c37161b273930ea6072ae82862b8f339d761bf21f953c8977511f653cdb8fdee",
      "provenance": {
       "module": "bots.tools.code_tools",
       "qualname": "_check_whitespace_match_at_position"
      }
     },
     "_find_whitespace_match_anywhere": {
      "__helper_func__": true,
      "pickled": "gASVPQAAAAAAAACMFWJvdHMudG9vbHMuY29kZV90b29sc5SMH19maW5kX3doaXRlc3BhY2VfbWF0Y2hfYW55d2hlcmWUk5Qu",
      "name": "_find_whitespace_match_anywhere",
      "hash": "58cbf338385d6aedded2c770972ee96c2ec3f40244a5e7fd4d77fb0f2cb1eb9f",
      "provenance": {
       "module": "bots.tools.code_tools",
       "qualname": "_find_whitespace_match_anywhere"
      }
     },
     "_adjust_additions_to_context": {
      "__helper_func__": true,
      "pickled": "gASVOgAAAAAAAACMFWJvdHMudG9vbHMuY29kZV90b29sc5SMHF9hZGp1c3RfYWRkaXRpb25zX3RvX2NvbnRleHSUk5Qu",
      "name": "_adjust_additions_to_context",
      "hash": "ac4e016513ea5a6c2f8c793716cc23ed4a4b5f0b5bd36335bf4ef717c160aa24",
      "provenance": {
       "module": "bots.tools.code_tools",
       "qualname": "_adjust_additions_to_context"
      }
     },
     "_find_block_in_content": {
      "__helper_func__": true,
      "pickled": "gASVNAAAAAAAAACMFWJvdHMudG9vbHMuY29kZV90b29sc5SMFl9maW5kX2Jsb2NrX2luX2NvbnRlbnSUk5Qu",
      "name": "_find_block_in_content",
      "hash": "2d17add9744a0cc0464e74ca36a537755901c56c480c2415f52cbabfb904a641",
      "provenance": {
       "module": "bots.tools.code_tools",
       "qualname": "_find_block_in_content"
      }
     },
     "_get_line_indentation": {
      "__helper_func__": true,
      "pickled": "gASVMwAAAAAAAACMFWJvdHMudG9vbHMuY29kZV90b29sc5SMFV9nZXRfbGluZV9pbmRlbnRhdGlvbpSTlC4=",
      "name": "_get_line_indentation",
      "hash": "3e53aa2ee6bb58d4cef81abb0b40fe7def49633328504b5125ec4539ca92567d",
      "provenance": {
       "module": "bots.tools.code_tools",
       "qualname": "_get_line_indentation"
      }
     },
     "_normalize_path": {
      "__helper_func__": true,
      "pickled": "gASVLQAAAAAAAACMFWJvdHMudG9vbHMuY29kZV90b29sc5SMD19ub3JtYWxpemVfcGF0aJSTlC4=",
      "name": "_normalize_path",
      "hash": "f66c63bbb8160b5675fff68fe72db8018887054bc654c6991da8306b7f96bf25",
      "provenance": {
       "module": "bots.tools.code_tools",
       "qualname": "_normalize_path"
      }
     },
     "_normalize_header_lines": {
      "__helper_func__": true,
      "pickled": "gASVNQAAAAAAAACMFWJvdHMudG9vbHMuY29kZV90b29sc5SMF19ub3JtYWxpemVfaGVhZGVyX2xpbmVzlJOULg==",
      "name": "_normalize_header_lines",
      "hash": "74939c7140ffdd2cb344d2edc81428ecd0e0216ebd1b7ae24bc5691de94036d2",
      "provenance": {
       "module": "bots.tools.code_tools",
       "qualname": "_normalize_header_lines"
      }
     }
    }
   },
   "dynamic_module_2207060386889269295": {
    "name": "dynamic_module_-3678211723916847881",
    "source": "from bots.utils.helpers import _process_error\n\ndef toolify(description: str = None):\n    \"\"\"\n    Convert any function into a bot tool with string-in, string-out interface.\n\n    - Converts string inputs to proper types using type hints\n    - Ensures string output (JSON for complex types)\n    - Wraps in error handling (returns error strings, never raises)\n    - Enhances docstring if description provided\n\n    Args:\n        description (str, optional): Override the function's docstring\n\n    Example:\n        @toolify()\n        def add_numbers(x: int, y: int = 0) -> int:\n            return x + y\n\n        @toolify(\"Calculate the area of a circle\")\n        def area(radius: float) -> float:\n            return 3.14159 * radius * radius\n    \"\"\"\n\n    def decorator(func):\n        @functools.wraps(func)\n        def wrapper(*args, **kwargs):\n            try:\n                # Convert string inputs to proper types using type hints\n                converted_args, converted_kwargs = _convert_tool_inputs(func, args, kwargs)\n\n                # Call original function\n                result = func(*converted_args, **converted_kwargs)\n\n                # Convert result to string\n                return _convert_tool_output(result)\n\n            except KeyboardInterrupt as e:\n                # Convert KeyboardInterrupt to ToolExecutionError to prevent it from\n                # bubbling up to CLI and being treated as user Ctrl+C\n\n                tool_error = ToolExecutionError(f\"Tool execution interrupted: {str(e)}\")\n                return _process_error(tool_error)\n\n            except TypeError as e:\n                # Check if this is a missing required argument error\n                error_msg = str(e)\n                if \"missing\" in error_msg and \"required\" in error_msg and \"argument\" in error_msg:\n                    # Add special message for output token limitation\n                    enhanced_error = TypeError(\n                        f\"{error_msg}\\n\\n\"\n                        f\"\u26a0\ufe0f  This error is commonly caused by hitting the max_tokens limit before completing the tool call.\\n\"\n                        f\"The response was truncated mid-parameter, making it appear that required parameters are missing.\\n\"\n                        f\"To fix this: Work in SMALLER CHUNKS. Edit fewer lines at a time, \"\n                        f\"or break your task into multiple steps.\"\n                    )\n\n                    return _process_error(enhanced_error)\n                else:\n\n                    return _process_error(e)\n            except Exception as e:\n\n                return _process_error(e)\n\n        # Update docstring if description provided\n        if description:\n            wrapper.__doc__ = description\n        elif not wrapper.__doc__:\n            # Generate minimal docstring from function name\n            wrapper.__doc__ = f\"Execute {func.__name__.replace('_', ' ')}\"\n\n        return wrapper\n\n    return decorator\n\n@toolify()\ndef view_dir(start_path: str='.', output_file=None, target_extensions: str=\"['py', 'txt', 'md']\", max_lines: int=500):\n    \"\"\"\n    Creates a summary of the directory structure starting from the given path, writing only files\n    with specified extensions and showing venv directories without their contents.\n    Parameters:\n    - start_path (str): The root directory to start scanning from.\n    - output_file (str): The name of the file to optionally write the directory structure to.\n    - target_extensions (str): String representation of a list of file extensions (e.g. \"['py', 'txt']\").\n    - max_lines (int): Maximum number of lines in output. If exceeded, deepest levels are truncated. Default 500.\n    Returns:\n    str: A formatted string containing the directory structure, with each directory and file properly indented.\n    Example output:\n    my_project/\n        venv/\n        module1/\n            script.py\n            README.md\n        module2/\n            utils.py\n    cost: low\n    \"\"\"\n    if max_lines:\n        max_lines = int(max_lines)\n    extensions_list = [ext.strip().strip('\\'\"') for ext in target_extensions.strip('[]').split(',')]\n    extensions_list = ['.' + ext if not ext.startswith('.') else ext for ext in extensions_list]\n    dir_entries = []\n    max_level = 0\n    for root, dirs, files in os.walk(start_path):\n        level = root.replace(start_path, '').count(os.sep)\n        indent = '    ' * level\n        basename = os.path.basename(root)\n        is_venv = basename in ['venv', 'env', '.env'] or 'pyvenv.cfg' in files\n        if is_venv:\n            dir_entries.append((level, f'{indent}{basename}/'))\n            max_level = max(max_level, level)\n            dirs[:] = []\n            continue\n        has_relevant_files = False\n        for _, _, fs in os.walk(root):\n            if any((f.endswith(tuple(extensions_list)) for f in fs)):\n                has_relevant_files = True\n                break\n        if has_relevant_files:\n            dir_entries.append((level, f'{indent}{basename}/'))\n            max_level = max(max_level, level)\n            subindent = '    ' * (level + 1)\n            for file in files:\n                if file.endswith(tuple(extensions_list)):\n                    dir_entries.append((level + 1, f'{subindent}{file}'))\n                    max_level = max(max_level, level + 1)\n    current_level_limit = max_level\n    while current_level_limit >= 0:\n        filtered_entries = [(level, line) for level, line in dir_entries if level <= current_level_limit]\n        truncated_dirs = set()\n        for level, line in dir_entries:\n            if level > current_level_limit and level == current_level_limit + 1:\n                parent_level = level - 1\n                for parent_level_check, parent_line in filtered_entries:\n                    if parent_level_check == parent_level and parent_line.endswith('/'):\n                        truncated_dirs.add(parent_line)\n        final_entries = []\n        for level, line in filtered_entries:\n            final_entries.append(line)\n            if line in truncated_dirs:\n                truncation_indent = '    ' * (level + 1)\n                final_entries.append(f'{truncation_indent}...')\n        if len(final_entries) <= max_lines:\n            output_text = final_entries\n            break\n        current_level_limit -= 1\n    else:\n        output_text = [f'Project too large (>{max_lines} lines). Showing root level only:', f'{os.path.basename(start_path) or start_path}/', '    ...']\n    if output_file is not None:\n        with open(output_file, 'w') as file:\n            file.write('\\n'.join(output_text))\n    return '\\n'.join(output_text)",
    "file_path": "dynamic_module_2207060386889269295",
    "code_hash": "e10d9ab0222e33171d8ce5b97bcf16ee",
    "globals": {
     "_convert_tool_inputs": {
      "__helper_func__": true,
      "pickled": "gASVMAAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjBRfY29udmVydF90b29sX2lucHV0c5STlC4=",
      "name": "_convert_tool_inputs",
      "hash": "8bc4aba1c7d69350a812d8553b6a7ff0cd23ae5c818f3b9533752a69e91acf2e",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "_convert_tool_inputs"
      }
     },
     "_convert_tool_output": {
      "__helper_func__": true,
      "pickled": "gASVMAAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjBRfY29udmVydF90b29sX291dHB1dJSTlC4=",
      "name": "_convert_tool_output",
      "hash": "6c85767d30db1c50646d25d2b954c893aed15774f97345f9b8c99674c59cf928",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "_convert_tool_output"
      }
     },
     "ToolExecutionError": {
      "__imported_callable__": true,
      "pickled": "gASVLgAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjBJUb29sRXhlY3V0aW9uRXJyb3KUk5Qu",
      "name": "ToolExecutionError",
      "hash": "e3f136f46cc3014d1b1a8ac6716adb9da7db1dd83f2ed8529e090d97ae0db998",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "ToolExecutionError"
      }
     },
     "ast": {
      "__module_type__": true,
      "name": "ast",
      "spec": "ast"
     },
     "datetime": {
      "__module_type__": true,
      "name": "datetime",
      "spec": "datetime"
     },
     "functools": {
      "__module_type__": true,
      "name": "functools",
      "spec": "functools"
     },
     "inspect": {
      "__module_type__": true,
      "name": "inspect",
      "spec": "inspect"
     },
     "logging": {
      "__module_type__": true,
      "name": "logging",
      "spec": "logging"
     },
     "os": {
      "__module_type__": true,
      "name": "os",
      "spec": "os"
     },
     "sys": {
      "__module_type__": true,
      "name": "sys",
      "spec": "sys"
     },
     "textwrap": {
      "__module_type__": true,
      "name": "textwrap",
      "spec": "textwrap"
     },
     "traceback": {
      "__module_type__": true,
      "name": "traceback",
      "spec": "traceback"
     },
     "wraps": {
      "__imported_callable__": true,
      "pickled": "gASVFwAAAAAAAACMCWZ1bmN0b29sc5SMBXdyYXBzlJOULg==",
      "name": "wraps",
      "hash": "4c7c8f91a978a903bce2515f7fe83cb09b7074259dabad02b312209312f718ed",
      "provenance": {
       "module": "functools",
       "qualname": "wraps"
      }
     },
     "Any": {
      "__imported_callable__": true,
      "pickled": "gASVEgAAAAAAAACMBnR5cGluZ5SMA0FueZSTlC4=",
      "name": "Any",
      "hash": "fbf19bc6bf716a555ce7094664e2bc898734e4acfc2cd6d9ee399edef2e5c02b",
      "provenance": {
       "module": "typing",
       "qualname": "Any"
      }
     },
     "Callable": {
      "__imported_callable__": true,
      "pickled": "gASVFwAAAAAAAACMBnR5cGluZ5SMCENhbGxhYmxllJOULg==",
      "name": "Callable",
      "hash": "17cf7f09b805961290dccb95aa11199df32c246cb879f355ffa1a31d6285edad",
      "provenance": {
       "module": "typing",
       "qualname": "Callable"
      }
     },
     "Optional": {
      "__imported_callable__": true,
      "pickled": "gASVFwAAAAAAAACMBnR5cGluZ5SMCE9wdGlvbmFslJOULg==",
      "name": "Optional",
      "hash": "d69b63c158dd563d1537447d9d3a68afdda0efb70794ab11c234d01e2e593e56",
      "provenance": {
       "module": "typing",
       "qualname": "Optional"
      }
     },
     "Type": {
      "__imported_callable__": true,
      "pickled": "gASVEwAAAAAAAACMBnR5cGluZ5SMBFR5cGWUk5Qu",
      "name": "Type",
      "hash": "9e98fdb991d3addb0aad6e13cd94b21998f5d97e9f30b15f9c697afe5cde1832",
      "provenance": {
       "module": "typing",
       "qualname": "Type"
      }
     },
     "remove_code_blocks": {
      "__imported_callable__": true,
      "pickled": "gASVLQAAAAAAAACMEmJvdHMudXRpbHMuaGVscGVyc5SMEnJlbW92ZV9jb2RlX2Jsb2Nrc5STlC4=",
      "name": "remove_code_blocks",
      "hash": "44524fda389310a2a28f80da99409efd110baefaa9ea50345d092a634c89fc1d",
      "provenance": {
       "module": "bots.utils.helpers",
       "qualname": "remove_code_blocks"
      }
     },
     "NoHTTPFilter": {
      "__imported_callable__": true,
      "pickled": "gASVKAAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjAxOb0hUVFBGaWx0ZXKUk5Qu",
      "name": "NoHTTPFilter",
      "hash": "9f920bc687c51afef3dea517f9b64393473ed37dac3fda0cedd01a655b483a52",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "NoHTTPFilter"
      }
     },
     "lazy_fn": {
      "__imported_callable__": true,
      "pickled": "gASVIwAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjAdsYXp5X2ZulJOULg==",
      "name": "lazy_fn",
      "hash": "a1737e2cf8adde594f0dd0b3f17ffaad4c126dcf16906e82cb07f18c13d8b7a2",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "lazy_fn"
      }
     },
     "lazy_class": {
      "__imported_callable__": true,
      "pickled": "gASVJgAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjApsYXp5X2NsYXNzlJOULg==",
      "name": "lazy_class",
      "hash": "d1883fc4e7eb2d64f47b4e90b4b6b69d0c5be0d0e3175787058ad631d122e4c6",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "lazy_class"
      }
     },
     "_get_context": {
      "__helper_func__": true,
      "pickled": "gASVKAAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjAxfZ2V0X2NvbnRleHSUk5Qu",
      "name": "_get_context",
      "hash": "979ef249cdc1f76f4020d948ffc352f7c667afb0d89f221770156eebd7717c7a",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "_get_context"
      }
     },
     "_get_py_interface": {
      "__helper_func__": true,
      "pickled": "gASVLQAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjBFfZ2V0X3B5X2ludGVyZmFjZZSTlC4=",
      "name": "_get_py_interface",
      "hash": "d45b0506fb8815e8d9c3a9217b0ca101dac4fb9f51c8546285cf68a95ab027e7",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "_get_py_interface"
      }
     },
     "lazy": {
      "__imported_callable__": true,
      "pickled": "gASVIAAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjARsYXp5lJOULg==",
      "name": "lazy",
      "hash": "6e25446d8765ac65a5518c01582ddf52784eb90c51d57e224c94823d5b7c55cd",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "lazy"
      }
     },
     "debug_on_error": {
      "__imported_callable__": true,
      "pickled": "gASVKgAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjA5kZWJ1Z19vbl9lcnJvcpSTlC4=",
      "name": "debug_on_error",
      "hash": "06d89d594519c41c1dae666437441d4fd4aeeea959f1c905694940a50ae4ddfe",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "debug_on_error"
      }
     },
     "log_errors": {
      "__imported_callable__": true,
      "pickled": "gASVJgAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjApsb2dfZXJyb3JzlJOULg==",
      "name": "log_errors",
      "hash": "f9446c0ae11aa5bb7726b83da744e8dc707a91edc91085abbca1cefd1897d829",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "log_errors"
      }
     },
     "toolify": {
      "__imported_callable__": true,
      "pickled": "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ZGVzY3JpcHRpb24gcHJvdmlkZWQKCiAgICBBcmdzOgogICAgICAgIGRlc2NyaXB0aW9uIChzdHIsIG9wdGlvbmFsKTogT3ZlcnJpZGUgdGhlIGZ1bmN0aW9uJ3MgZG9jc3RyaW5nCgogICAgRXhhbXBsZToKICAgICAgICBAdG9vbGlmeSgpCiAgICAgICAgZGVmIGFkZF9udW1iZXJzKHg6IGludCwgeTogaW50ID0gMCkgLT4gaW50OgogICAgICAgICAgICByZXR1cm4geCArIHkKCiAgICAgICAgQHRvb2xpZnkoIkNhbGN1bGF0ZSB0aGUgYXJlYSBvZiBhIGNpcmNsZSIpCiAgICAgICAgZGVmIGFyZWEocmFkaXVzOiBmbG9hdCkgLT4gZmxvYXQ6CiAgICAgICAgICAgIHJldHVybiAzLjE0MTU5ICogcmFkaXVzICogcmFkaXVzCiAgICAiIiIKCiAgICBkZWYgZGVjb3JhdG9yKGZ1bmMpOgogICAgICAgIEBmdW5jdG9vbHMud3JhcHMoZnVuYykKICAgICAgICBkZWYgd3JhcHBlcigqYXJncywgKiprd2FyZ3MpOgogICAgICAgICAgICB0cnk6CiAgICAgICAgICAgICAgICAjIENvbnZlcnQgc3RyaW5nIGlucHV0cyB0byBwcm9wZXIgdHlwZXMgdXNpbmcgdHlwZSBoaW50cwogICAgICAgICAgICAgICAgY29udmVydGVkX2FyZ3MsIGNvbnZlcnRlZF9rd2FyZ3MgPSBfY29udmVydF90b29sX2lucHV0cyhmdW5jLCBhcmdzLCBrd2FyZ3MpCgogICAgICAgICAgICAgICAgIyBDYWxsIG9yaWdpbmFsIGZ1bmN0aW9uCiAgICAgICAgICAgICAgICByZXN1bHQgPSBmdW5jKCpjb252ZXJ0ZWRfYXJncywgKipjb252ZXJ0ZWRfa3dhcmdzKQoKICAgICAgICAgICAgICAgICMgQ29udmVydCByZXN1bHQgdG8gc3RyaW5nCiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnZlcnRfdG9vbF9vdXRwdXQocmVzdWx0KQoKICAgICAgICAgICAgZXhjZXB0IEtleWJvYXJkSW50ZXJydXB0IGFzIGU6CiAgICAgICAgICAgICAgICAjIENvbnZlcnQgS2V5Ym9hcmRJbnRlcnJ1cHQgdG8gVG9vbEV4ZWN1dGlvbkVycm9yIHRvIHByZXZlbnQgaXQgZnJvbQogICAgICAgICAgICAgICAgIyBidWJibGluZyB1cCB0byBDTEkgYW5kIGJlaW5nIHRyZWF0ZWQgYXMgdXNlciBDdHJsK0MKICAgICAgICAgICAgICAgIGZyb20gYm90cy51dGlscy5oZWxwZXJzIGltcG9ydCBfcHJvY2Vzc19lcnJvcgoKICAgICAgICAgICAgICAgIHRvb2xfZXJyb3IgPSBUb29sRXhlY3V0aW9uRXJyb3IoZiJUb29sIGV4ZWN1dGlvbiBpbnRlcnJ1cHRlZDoge3N0cihlKX0iKQogICAgICAgICAgICAgICAgcmV0dXJuIF9wcm9jZXNzX2Vycm9yKHRvb2xfZXJyb3IpCgogICAgICAgICAgICBleGNlcHQgVHlwZUVycm9yIGFzIGU6CiAgICAgICAgICAgICAgICAjIENoZWNrIGlmIHRoaXMgaXMgYSBtaXNzaW5nIHJlcXVpcmVkIGFyZ3VtZW50IGVycm9yCiAgICAgICAgICAgICAgICBlcnJvcl9tc2cgPSBzdHIoZSkKICAgICAgICAgICAgICAgIGlmICJtaXNzaW5nIiBpbiBlcnJvcl9tc2cgYW5kICJyZXF1aXJlZCIgaW4gZXJyb3JfbXNnIGFuZCAiYXJndW1lbnQiIGluIGVycm9yX21zZzoKICAgICAgICAgICAgICAgICAgICAjIEFkZCBzcGVjaWFsIG1lc3NhZ2UgZm9yIG91dHB1dCB0b2tlbiBsaW1pdGF0aW9uCiAgICAgICAgICAgICAgICAgICAgZW5oYW5jZWRfZXJyb3IgPSBUeXBlRXJyb3IoCiAgICAgICAgICAgICAgICAgICAgICAgIGYie2Vycm9yX21zZ31cblxuIgogICAgICAgICAgICAgICAgICAgICAgICBmIuKaoO+4jyAgVGhpcyBlcnJvciBpcyBjb21tb25seSBjYXVzZWQgYnkgaGl0dGluZyB0aGUgbWF4X3Rva2VucyBsaW1pdCBiZWZvcmUgY29tcGxldGluZyB0aGUgdG9vbCBjYWxsLlxuIgogICAgICAgICAgICAgICAgICAgICAgICBmIlRoZSByZXNwb25zZSB3YXMgdHJ1bmNhdGVkIG1pZC1wYXJhbWV0ZXIsIG1ha2luZyBpdCBhcHBlYXIgdGhhdCByZXF1aXJlZCBwYXJhbWV0ZXJzIGFyZSBtaXNzaW5nLlxuIgogICAgICAgICAgICAgICAgICAgICAgICBmIlRvIGZpeCB0aGlzOiBXb3JrIGluIFNNQUxMRVIgQ0hVTktTLiBFZGl0IGZld2VyIGxpbmVzIGF0IGEgdGltZSwgIgogICAgICAgICAgICAgICAgICAgICAgICBmIm9yIGJyZWFrIHlvdXIgdGFzayBpbnRvIG11bHRpcGxlIHN0ZXBzLiIKICAgICAgICAgICAgICAgICAgICApCiAgICAgICAgICAgICAgICAgICAgZnJvbSBib3RzLnV0aWxzLmhlbHBlcnMgaW1wb3J0IF9wcm9jZXNzX2Vycm9yCgogICAgICAgICAgICAgICAgICAgIHJldHVybiBfcHJvY2Vzc19lcnJvcihlbmhhbmNlZF9lcnJvcikKICAgICAgICAgICAgICAgIGVsc2U6CiAgICAgICAgICAgICAgICAgICAgZnJvbSBib3RzLnV0aWxzLmhlbHBlcnMgaW1wb3J0IF9wcm9jZXNzX2Vycm9yCgogICAgICAgICAgICAgICAgICAgIHJldHVybiBfcHJvY2Vzc19lcnJvcihlKQogICAgICAgICAgICBleGNlcHQgRXhjZXB0aW9uIGFzIGU6CiAgICAgICAgICAgICAgICBmcm9tIGJvdHMudXRpbHMuaGVscGVycyBpbXBvcnQgX3Byb2Nlc3NfZXJyb3IKCiAgICAgICAgICAgICAgICByZXR1cm4gX3Byb2Nlc3NfZXJyb3IoZSkKCiAgICAgICAgIyBVcGRhdGUgZG9jc3RyaW5nIGlmIGRlc2NyaXB0aW9uIHByb3ZpZGVkCiAgICAgICAgaWYgZGVzY3JpcHRpb246CiAgICAgICAgICAgIHdyYXBwZXIuX19kb2NfXyA9IGRlc2NyaXB0aW9uCiAgICAgICAgZWxpZiBub3Qgd3JhcHBlci5fX2RvY19fOgogICAgICAgICAgICAjIEdlbmVyYXRlIG1pbmltYWwgZG9jc3RyaW5nIGZyb20gZnVuY3Rpb24gbmFtZQogICAgICAgICAgICB3cmFwcGVyLl9fZG9jX18gPSBmIkV4ZWN1dGUge2Z1bmMuX19uYW1lX18ucmVwbGFjZSgnXycsICcgJyl9IgoKICAgICAgICByZXR1cm4gd3JhcHBlcgoKICAgIHJldHVybiBkZWNvcmF0b3IKCkB0b29saWZ5KCkKZGVmIHZpZXdfZGlyKHN0YXJ0X3BhdGg6IHN0cj0nLicsIG91dHB1dF9maWxlPU5vbmUsIHRhcmdldF9leHRlbnNpb25zOiBzdHI9IlsncHknLCAndHh0JywgJ21kJ10iLCBtYXhfbGluZXM6IGludD01MDApOgogICAgIiIiCiAgICBDcmVhdGVzIGEgc3VtbWFyeSBvZiB0aGUgZGlyZWN0b3J5IHN0cnVjdHVyZSBzdGFydGluZyBmcm9tIHRoZSBnaXZlbiBwYXRoLCB3cml0aW5nIG9ubHkgZmlsZXMKICAgIHdpdGggc3BlY2lmaWVkIGV4dGVuc2lvbnMgYW5kIHNob3dpbmcgdmVudiBkaXJlY3RvcmllcyB3aXRob3V0IHRoZWlyIGNvbnRlbnRzLgogICAgUGFyYW1ldGVyczoKICAgIC0gc3RhcnRfcGF0aCAoc3RyKTogVGhlIHJvb3QgZGlyZWN0b3J5IHRvIHN0YXJ0IHNjYW5uaW5nIGZyb20uCiAgICAtIG91dHB1dF9maWxlIChzdHIpOiBUaGUgbmFtZSBvZiB0aGUgZmlsZSB0byBvcHRpb25hbGx5IHdyaXRlIHRoZSBkaXJlY3Rvcnkgc3RydWN0dXJlIHRvLgogICAgLSB0YXJnZXRfZXh0ZW5zaW9ucyAoc3RyKTogU3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgbGlzdCBvZiBmaWxlIGV4dGVuc2lvbnMgKGUuZy4gIlsncHknLCAndHh0J10iKS4KICAgIC0gbWF4X2xpbmVzIChpbnQpOiBNYXhpbXVtIG51bWJlciBvZiBsaW5lcyBpbiBvdXRwdXQuIElmIGV4Y2VlZGVkLCBkZWVwZXN0IGxldmVscyBhcmUgdHJ1bmNhdGVkLiBEZWZhdWx0IDUwMC4KICAgIFJldHVybnM6CiAgICBzdHI6IEEgZm9ybWF0dGVkIHN0cmluZyBjb250YWluaW5nIHRoZSBkaXJlY3Rvcnkgc3RydWN0dXJlLCB3aXRoIGVhY2ggZGlyZWN0b3J5IGFuZCBmaWxlIHByb3Blcmx5IGluZGVudGVkLgogICAgRXhhbXBsZSBvdXRwdXQ6CiAgICBteV9wcm9qZWN0LwogICAgICAgIHZlbnYvCiAgICAgICAgbW9kdWxlMS8KICAgICAgICAgICAgc2NyaXB0LnB5CiAgICAgICAgICAgIFJFQURNRS5tZAogICAgICAgIG1vZHVsZTIvCiAgICAgICAgICAgIHV0aWxzLnB5CiAgICBjb3N0OiBsb3cKICAgICIiIgogICAgaWYgbWF4X2xpbmVzOgogICAgICAgIG1heF9saW5lcyA9IGludChtYXhfbGluZXMpCiAgICBleHRlbnNpb25zX2xpc3QgPSBbZXh0LnN0cmlwKCkuc3RyaXAoJ1wnIicpIGZvciBleHQgaW4gdGFyZ2V0X2V4dGVuc2lvbnMuc3RyaXAoJ1tdJykuc3BsaXQoJywnKV0KICAgIGV4dGVuc2lvbnNfbGlzdCA9IFsnLicgKyBleHQgaWYgbm90IGV4dC5zdGFydHN3aXRoKCcuJykgZWxzZSBleHQgZm9yIGV4dCBpbiBleHRlbnNpb25zX2xpc3RdCiAgICBkaXJfZW50cmllcyA9IFtdCiAgICBtYXhfbGV2ZWwgPSAwCiAgICBmb3Igcm9vdCwgZGlycywgZmlsZXMgaW4gb3Mud2FsayhzdGFydF9wYXRoKToKICAgICAgICBsZXZlbCA9IHJvb3QucmVwbGFjZShzdGFydF9wYXRoLCAnJykuY291bnQob3Muc2VwKQogICAgICAgIGluZGVudCA9ICcgICAgJyAqIGxldmVsCiAgICAgICAgYmFzZW5hbWUgPSBvcy5wYXRoLmJhc2VuYW1lKHJvb3QpCiAgICAgICAgaXNfdmVudiA9IGJhc2VuYW1lIGluIFsndmVudicsICdlbnYnLCAnLmVudiddIG9yICdweXZlbnYuY2ZnJyBpbiBmaWxlcwogICAgICAgIGlmIGlzX3ZlbnY6CiAgICAgICAgICAgIGRpcl9lbnRyaWVzLmFwcGVuZCgobGV2ZWwsIGYne2luZGVudH17YmFzZW5hbWV9LycpKQogICAgICAgICAgICBtYXhfbGV2ZWwgPSBtYXgobWF4X2xldmVsLCBsZXZlbCkKICAgICAgICAgICAgZGlyc1s6XSA9IFtdCiAgICAgICAgICAgIGNvbnRpbnVlCiAgICAgICAgaGFzX3JlbGV2YW50X2ZpbGVzID0gRmFsc2UKICAgICAgICBmb3IgXywgXywgZnMgaW4gb3Mud2Fsayhyb290KToKICAgICAgICAgICAgaWYgYW55KChmLmVuZHN3aXRoKHR1cGxlKGV4dGVuc2lvbnNfbGlzdCkpIGZvciBmIGluIGZzKSk6CiAgICAgICAgICAgICAgICBoYXNfcmVsZXZhbnRfZmlsZXMgPSBUcnVlCiAgICAgICAgICAgICAgICBicmVhawogICAgICAgIGlmIGhhc19yZWxldmFudF9maWxlczoKICAgICAgICAgICAgZGlyX2VudHJpZXMuYXBwZW5kKChsZXZlbCwgZid7aW5kZW50fXtiYXNlbmFtZX0vJykpCiAgICAgICAgICAgIG1heF9sZXZlbCA9IG1heChtYXhfbGV2ZWwsIGxldmVsKQogICAgICAgICAgICBzdWJpbmRlbnQgPSAnICAgICcgKiAobGV2ZWwgKyAxKQogICAgICAgICAgICBmb3IgZmlsZSBpbiBmaWxlczoKICAgICAgICAgICAgICAgIGlmIGZpbGUuZW5kc3dpdGgodHVwbGUoZXh0ZW5zaW9uc19saXN0KSk6CiAgICAgICAgICAgICAgICAgICAgZGlyX2VudHJpZXMuYXBwZW5kKChsZXZlbCArIDEsIGYne3N1YmluZGVudH17ZmlsZX0nKSkKICAgICAgICAgICAgICAgICAgICBtYXhfbGV2ZWwgPSBtYXgobWF4X2xldmVsLCBsZXZlbCArIDEpCiAgICBjdXJyZW50X2xldmVsX2xpbWl0ID0gbWF4X2xldmVsCiAgICB3aGlsZSBjdXJyZW50X2xldmVsX2xpbWl0ID49IDA6CiAgICAgICAgZmlsdGVyZWRfZW50cmllcyA9IFsobGV2ZWwsIGxpbmUpIGZvciBsZXZlbCwgbGluZSBpbiBkaXJfZW50cmllcyBpZiBsZXZlbCA8PSBjdXJyZW50X2xldmVsX2xpbWl0XQogICAgICAgIHRydW5jYXRlZF9kaXJzID0gc2V0KCkKICAgICAgICBmb3IgbGV2ZWwsIGxpbmUgaW4gZGlyX2VudHJpZXM6CiAgICAgICAgICAgIGlmIGxldmVsID4gY3VycmVudF9sZXZlbF9saW1pdCBhbmQgbGV2ZWwgPT0gY3VycmVudF9sZXZlbF9saW1pdCArIDE6CiAgICAgICAgICAgICAgICBwYXJlbnRfbGV2ZWwgPSBsZXZlbCAtIDEKICAgICAgICAgICAgICAgIGZvciBwYXJlbnRfbGV2ZWxfY2hlY2ssIHBhcmVudF9saW5lIGluIGZpbHRlcmVkX2VudHJpZXM6CiAgICAgICAgICAgICAgICAgICAgaWYgcGFyZW50X2xldmVsX2NoZWNrID09IHBhcmVudF9sZXZlbCBhbmQgcGFyZW50X2xpbmUuZW5kc3dpdGgoJy8nKToKICAgICAgICAgICAgICAgICAgICAgICAgdHJ1bmNhdGVkX2RpcnMuYWRkKHBhcmVudF9saW5lKQogICAgICAgIGZpbmFsX2VudHJpZXMgPSBbXQogICAgICAgIGZvciBsZXZlbCwgbGluZSBpbiBmaWx0ZXJlZF9lbnRyaWVzOgogICAgICAgICAgICBmaW5hbF9lbnRyaWVzLmFwcGVuZChsaW5lKQogICAgICAgICAgICBpZiBsaW5lIGluIHRydW5jYXRlZF9kaXJzOgogICAgICAgICAgICAgICAgdHJ1bmNhdGlvbl9pbmRlbnQgPSAnICAgICcgKiAobGV2ZWwgKyAxKQogICAgICAgICAgICAgICAgZmluYWxfZW50cmllcy5hcHBlbmQoZid7dHJ1bmNhdGlvbl9pbmRlbnR9Li4uJykKICAgICAgICBpZiBsZW4oZmluYWxfZW50cmllcykgPD0gbWF4X2xpbmVzOgogICAgICAgICAgICBvdXRwdXRfdGV4dCA9IGZpbmFsX2VudHJpZXMKICAgICAgICAgICAgYnJlYWsKICAgICAgICBjdXJyZW50X2xldmVsX2xpbWl0IC09IDEKICAgIGVsc2U6CiAgICAgICAgb3V0cHV0X3RleHQgPSBbZidQcm9qZWN0IHRvbyBsYXJnZSAoPnttYXhfbGluZXN9IGxpbmVzKS4gU2hvd2luZyByb290IGxldmVsIG9ubHk6JywgZid7b3MucGF0aC5iYXNlbmFtZShzdGFydF9wYXRoKSBvciBzdGFydF9wYXRofS8nLCAnICAgIC4uLiddCiAgICBpZiBvdXRwdXRfZmlsZSBpcyBub3QgTm9uZToKICAgICAgICB3aXRoIG9wZW4ob3V0cHV0X2ZpbGUsICd3JykgYXMgZmlsZToKICAgICAgICAgICAgZmlsZS53cml0ZSgnXG4nLmpvaW4ob3V0cHV0X3RleHQpKQogICAgcmV0dXJuICdcbicuam9pbihvdXRwdXRfdGV4dCmUjAlmaWxlX3BhdGiUaF2MCW5hbWVzcGFjZZRoZIwvX19ydW50aW1lX18uZHluYW1pY19tb2R1bGVfLTM2NzgyMTE3MjM5MTY4NDc4ODGUhZRSlH2UKGg3aExoNk5oWU5oW05oXGhdaBRoX2gVaGBoGGhhaGJoZmhnaGloNGhraGxobmhvaHFocmh0aHVoeGh5aHtofGh+aDVof2iAaIJog2iEaIVohmiHaIhoiWiKaItoj2iQaJFokmiTaJRolWiWaJdomGiZaJpom2icaJ1onmifaEZoT2igaKFoomijaKRopminaKloqmisaK1ormivaLBosWi5jBhfcmVtb3ZlX2JvbV9mcm9tX2NvbnRlbnSUaKtqLwEAAJOUjApwYXRjaF9lZGl0lGirajEBAACTlIwaX2ZpbmRfbWF0Y2hfd2l0aF9oaWVyYXJjaHmUaKtqMwEAAJOUjB5fY2hlY2tfZXhhY3RfbWF0Y2hfYXRfcG9zaXRpb26UaKtqNQEAAJOUjBpfZmluZF9leGFjdF9tYXRjaF9hbnl3aGVyZZRoq2o3AQAAk5SMI19jaGVja193aGl0ZXNwYWNlX21hdGNoX2F0X3Bvc2l0aW9ulGirajkBAACTlIwfX2ZpbmRfd2hpdGVzcGFjZV9tYXRjaF9hbnl3aGVyZZRoq2o7AQAAk5SMHF9hZGp1c3RfYWRkaXRpb25zX3RvX2NvbnRleHSUaKtqPQEAAJOUjBZfZmluZF9ibG9ja19pbl9jb250ZW50lGiraj8BAACTlIwVX2dldF9saW5lX2luZGVudGF0aW9ulGirakEBAACTlIwPX25vcm1hbGl6ZV9wYXRolGirakMBAACTlIwXX25vcm1hbGl6ZV9oZWFkZXJfbGluZXOUaKtqRQEAAJOUdWKMCWNvZGVfaGFzaJSMIDBhZmQ4YzRkMWQxZWNmY2ViMzUwMTNlYjY1ZmRlZDQ2lHVidX2UKGg2aL5oUmocAQAAdYaUYmoVAQAAKGg3aExoNk5oWU5oWk5oW05oXGhdaBRoX2gVaGBoGGhhaGJoZmhnaGloNGhraGxobmhvaHFocmh0aHVoeGh5aHtofGh+aDVof2iAaIJog2iEaIVohmiHaIhoiWiKaItoj2iQaJFokmiTaJRolWiWaJdomGiZaJpom2icaJ1onmifaEZoT2igaKFoomijaKRopminaKloqmisaK1ormivaLBosWi5ai8BAABqMAEAAGoxAQAAajIBAABqMwEAAGo0AQAAajUBAABqNgEAAGo3AQAAajgBAABqOQEAAGo6AQAAajsBAABqPAEAAGo9AQAAaj4BAABqPwEAAGpAAQAAakEBAABqQgEAAGpDAQAAakQBAABqRQEAAGpGAQAAjAxfX2J1aWx0aW5zX1+UY2J1aWx0aW5zCl9fZGljdF9fCnUwjAhidWlsdGluc5SMB2dldGF0dHKUk5SMBGRpbGyUjAVfZGlsbJSTlIwIX3NldGF0dHKUakwBAACMB3NldGF0dHKUk5SHlFKUaLaMDWNlbGxfY29udGVudHOUahkBAACHlFIwaLIoaDdoTGg2TmhZTmhaTmhbTmhcaF1oFGhfaBVoYGgYaGFoYmhmaGdoaWg0aGtobGhuaG9ocWhyaHRodWh4aHloe2h8aH5oNWh/aIBogmiDaIRohWiGaIdoiGiJaIpoi2iPaJBokWiSaJNolGiVaJZol2iYaJlommibaJxonWieaJ9oRmhPaKBooWiiaKNopGimaKdoqWiqaKxorWiuaK9osGixaLlqLwEAAGowAQAAajEBAABqMgEAAGozAQAAajQBAABqNQEAAGo2AQAAajcBAABqOAEAAGo5AQAAajoBAABqOwEAAGo8AQAAaj0BAABqPgEAAGo/AQAAakABAABqQQEAAGpCAQAAakMBAABqRAEAAGpFAQAAakYBAABqSwEAAGNidWlsdGlucwpfX2RpY3RfXwp1MGovAQAAajABAABqMQEAAGoyAQAAajMBAABqNAEAAGo1AQAAajYBAABqNwEAAGo4AQAAajkBAABqOgEAAGo7AQAAajwBAABqPQEAAGo+AQAAaj8BAABqQAEAAGpBAQAAakIBAABqQwEAAGpEAQAAakUBAABqRgEAAGpLAQAAY2J1aWx0aW5zCl9fZGljdF9fCnUwLg==",
      "name": "toolify",
      "hash": "c933b4aa2455e953d2cb31e506310d40454fb68cbdd025cb97f2f5baddde1438",
      "provenance": {
       "module": "dynamic_module_-3678211723916847881",
       "qualname": "toolify"
      }
     },
     "_convert_string_to_type": {
      "__helper_func__": true,
      "pickled": "gASVMwAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjBdfY29udmVydF9zdHJpbmdfdG9fdHlwZZSTlC4=",
      "name": "_convert_string_to_type",
      "hash": "024e40c56cb46e6fe9f52fe7e6e64a3effc17736268ef31195596c6a6be4c311",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "_convert_string_to_type"
      }
     },
     "_log_error_to_file": {
      "__helper_func__": true,
      "pickled": "gASVLgAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjBJfbG9nX2Vycm9yX3RvX2ZpbGWUk5Qu",
      "name": "_log_error_to_file",
      "hash": "c02546b672eb25afd5dc51ea7e1967cbb6fd264ca18ffd15c3cbeccebe4046ba",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "_log_error_to_file"
      }
     },
     "difflib": {
      "__module_type__": true,
      "name": "difflib",
      "spec": "difflib"
     },
     "clean_unicode_string": {
      "__imported_callable__": true,
      "pickled": "gASVNQAAAAAAAACMGGJvdHMudXRpbHMudW5pY29kZV91dGlsc5SMFGNsZWFuX3VuaWNvZGVfc3RyaW5nlJOULg==",
      "name": "clean_unicode_string",
      "hash": "2316910285c0cef615cfa77d71869e6841488cbe386a2ae90e4f7ebf187fec5e",
      "provenance": {
       "module": "bots.utils.unicode_utils",
       "qualname": "clean_unicode_string"
      }
     },
     "_read_file_bom_safe": {
      "__helper_func__": true,
      "pickled": "gASVMQAAAAAAAACMFWJvdHMudG9vbHMuY29kZV90b29sc5SME19yZWFkX2ZpbGVfYm9tX3NhZmWUk5Qu",
      "name": "_read_file_bom_safe",
      "hash": "7eebe2a51e84122e8270a51d6dd427aa2f4ef27a8fd569504fa218fff0fea0df",
      "provenance": {
       "module": "bots.tools.code_tools",
       "qualname": "_read_file_bom_safe"
      }
     },
     "_write_file_bom_safe": {
      "__helper_func__": true,
      "pickled": "gASVMgAAAAAAAACMFWJvdHMudG9vbHMuY29kZV90b29sc5SMFF93cml0ZV9maWxlX2JvbV9zYWZllJOULg==",
      "name": "_write_file_bom_safe",
      "hash": "4673b28157f3244ba7c580ec0d8c3dffb0286aaa8710857f8a16c0ec76504dcf",
      "provenance": {
       "module": "bots.tools.code_tools",
       "qualname": "_write_file_bom_safe"
      }
     },
     "view": {
      "__imported_callable__": true,
      "pickled": "gASVIgAAAAAAAACMFWJvdHMudG9vbHMuY29kZV90b29sc5SMBHZpZXeUk5Qu",
      "name": "view",
      "hash": "6cc80eb439a268354cadbfc036a385293b757cfb4f20682694592992f35b9e9a",
      "provenance": {
       "module": "bots.tools.code_tools",
       "qualname": "view"
      }
     },
     "view_dir": {
      "__imported_callable__": true,
      "pickled": "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ZSBkaXJlY3Rvcnkgc3RydWN0dXJlIHN0YXJ0aW5nIGZyb20gdGhlIGdpdmVuIHBhdGgsIHdyaXRpbmcgb25seSBmaWxlcwogICAgd2l0aCBzcGVjaWZpZWQgZXh0ZW5zaW9ucyBhbmQgc2hvd2luZyB2ZW52IGRpcmVjdG9yaWVzIHdpdGhvdXQgdGhlaXIgY29udGVudHMuCiAgICBQYXJhbWV0ZXJzOgogICAgLSBzdGFydF9wYXRoIChzdHIpOiBUaGUgcm9vdCBkaXJlY3RvcnkgdG8gc3RhcnQgc2Nhbm5pbmcgZnJvbS4KICAgIC0gb3V0cHV0X2ZpbGUgKHN0cik6IFRoZSBuYW1lIG9mIHRoZSBmaWxlIHRvIG9wdGlvbmFsbHkgd3JpdGUgdGhlIGRpcmVjdG9yeSBzdHJ1Y3R1cmUgdG8uCiAgICAtIHRhcmdldF9leHRlbnNpb25zIChzdHIpOiBTdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBsaXN0IG9mIGZpbGUgZXh0ZW5zaW9ucyAoZS5nLiAiWydweScsICd0eHQnXSIpLgogICAgLSBtYXhfbGluZXMgKGludCk6IE1heGltdW0gbnVtYmVyIG9mIGxpbmVzIGluIG91dHB1dC4gSWYgZXhjZWVkZWQsIGRlZXBlc3QgbGV2ZWxzIGFyZSB0cnVuY2F0ZWQuIERlZmF1bHQgNTAwLgogICAgUmV0dXJuczoKICAgIHN0cjogQSBmb3JtYXR0ZWQgc3RyaW5nIGNvbnRhaW5pbmcgdGhlIGRpcmVjdG9yeSBzdHJ1Y3R1cmUsIHdpdGggZWFjaCBkaXJlY3RvcnkgYW5kIGZpbGUgcHJvcGVybHkgaW5kZW50ZWQuCiAgICBFeGFtcGxlIG91dHB1dDoKICAgIG15X3Byb2plY3QvCiAgICAgICAgdmVudi8KICAgICAgICBtb2R1bGUxLwogICAgICAgICAgICBzY3JpcHQucHkKICAgICAgICAgICAgUkVBRE1FLm1kCiAgICAgICAgbW9kdWxlMi8KICAgICAgICAgICAgdXRpbHMucHkKICAgIGNvc3Q6IGxvdwogICAglIwCW12UjAEslIwCJyKUjAEulEsAjACUjAQgICAglIwEdmVudpSMA2VudpSMBC5lbnaUh5SMCnB5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IGFyZWEocmFkaXVzOiBmbG9hdCkgLT4gZmxvYXQ6CiAgICAgICAgICAgIHJldHVybiAzLjE0MTU5ICogcmFkaXVzICogcmFkaXVzCiAgICAiIiIKCiAgICBkZWYgZGVjb3JhdG9yKGZ1bmMpOgogICAgICAgIEBmdW5jdG9vbHMud3JhcHMoZnVuYykKICAgICAgICBkZWYgd3JhcHBlcigqYXJncywgKiprd2FyZ3MpOgogICAgICAgICAgICB0cnk6CiAgICAgICAgICAgICAgICAjIENvbnZlcnQgc3RyaW5nIGlucHV0cyB0byBwcm9wZXIgdHlwZXMgdXNpbmcgdHlwZSBoaW50cwogICAgICAgICAgICAgICAgY29udmVydGVkX2FyZ3MsIGNvbnZlcnRlZF9rd2FyZ3MgPSBfY29udmVydF90b29sX2lucHV0cyhmdW5jLCBhcmdzLCBrd2FyZ3MpCgogICAgICAgICAgICAgICAgIyBDYWxsIG9yaWdpbmFsIGZ1bmN0aW9uCiAgICAgICAgICAgICAgICByZXN1bHQgPSBmdW5jKCpjb252ZXJ0ZWRfYXJncywgKipjb252ZXJ0ZWRfa3dhcmdzKQoKICAgICAgICAgICAgICAgICMgQ29udmVydCByZXN1bHQgdG8gc3RyaW5nCiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnZlcnRfdG9vbF9vdXRwdXQocmVzdWx0KQoKICAgICAgICAgICAgZXhjZXB0IEtleWJvYXJkSW50ZXJydXB0IGFzIGU6CiAgICAgICAgICAgICAgICAjIENvbnZlcnQgS2V5Ym9hcmRJbnRlcnJ1cHQgdG8gVG9vbEV4ZWN1dGlvbkVycm9yIHRvIHByZXZlbnQgaXQgZnJvbQogICAgICAgICAgICAgICAgIyBidWJibGluZyB1cCB0byBDTEkgYW5kIGJlaW5nIHRyZWF0ZWQgYXMgdXNlciBDdHJsK0MKICAgICAgICAgICAgICAgIGZyb20gYm90cy51dGlscy5oZWxwZXJzIGltcG9ydCBfcHJvY2Vzc19lcnJvcgoKICAgICAgICAgICAgICAgIHRvb2xfZXJyb3IgPSBUb29sRXhlY3V0aW9uRXJyb3IoZiJUb29sIGV4ZWN1dGlvbiBpbnRlcnJ1cHRlZDoge3N0cihlKX0iKQogICAgICAgICAgICAgICAgcmV0dXJuIF9wcm9jZXNzX2Vycm9yKHRvb2xfZXJyb3IpCgogICAgICAgICAgICBleGNlcHQgVHlwZUVycm9yIGFzIGU6CiAgICAgICAgICAgICAgICAjIENoZWNrIGlmIHRoaXMgaXMgYSBtaXNzaW5nIHJlcXVpcmVkIGFyZ3VtZW50IGVycm9yCiAgICAgICAgICAgICAgICBlcnJvcl9tc2cgPSBzdHIoZSkKICAgICAgICAgICAgICAgIGlmICJtaXNzaW5nIiBpbiBlcnJvcl9tc2cgYW5kICJyZXF1aXJlZCIgaW4gZXJyb3JfbXNnIGFuZCAiYXJndW1lbnQiIGluIGVycm9yX21zZzoKICAgICAgICAgICAgICAgICAgICAjIEFkZCBzcGVjaWFsIG1lc3NhZ2UgZm9yIG91dHB1dCB0b2tlbiBsaW1pdGF0aW9uCiAgICAgICAgICAgICAgICAgICAgZW5oYW5jZWRfZXJyb3IgPSBUeXBlRXJyb3IoCiAgICAgICAgICAgICAgICAgICAgICAgIGYie2Vycm9yX21zZ31cblxuIgogICAgICAgICAgICAgICAgICAgICAgICBmIuKaoO+4jyAgVGhpcyBlcnJvciBpcyBjb21tb25seSBjYXVzZWQgYnkgaGl0dGluZyB0aGUgbWF4X3Rva2VucyBsaW1pdCBiZWZvcmUgY29tcGxldGluZyB0aGUgdG9vbCBjYWxsLlxuIgogICAgICAgICAgICAgICAgICAgICAgICBmIlRoZSByZXNwb25zZSB3YXMgdHJ1bmNhdGVkIG1pZC1wYXJhbWV0ZXIsIG1ha2luZyBpdCBhcHBlYXIgdGhhdCByZXF1aXJlZCBwYXJhbWV0ZXJzIGFyZSBtaXNzaW5nLlxuIgogICAgICAgICAgICAgICAgICAgICAgICBmIlRvIGZpeCB0aGlzOiBXb3JrIGluIFNNQUxMRVIgQ0hVTktTLiBFZGl0IGZld2VyIGxpbmVzIGF0IGEgdGltZSwgIgogICAgICAgICAgICAgICAgICAgICAgICBmIm9yIGJyZWFrIHlvdXIgdGFzayBpbnRvIG11bHRpcGxlIHN0ZXBzLiIKICAgICAgICAgICAgICAgICAgICApCiAgICAgICAgICAgICAgICAgICAgZnJvbSBib3RzLnV0aWxzLmhlbHBlcnMgaW1wb3J0IF9wcm9jZXNzX2Vycm9yCgogICAgICAgICAgICAgICAgICAgIHJldHVybiBfcHJvY2Vzc19lcnJvcihlbmhhbmNlZF9lcnJvcikKICAgICAgICAgICAgICAgIGVsc2U6CiAgICAgICAgICAgICAgICAgICAgZnJvbSBib3RzLnV0aWxzLmhlbHBlcnMgaW1wb3J0IF9wcm9jZXNzX2Vycm9yCgogICAgICAgICAgICAgICAgICAgIHJldHVybiBfcHJvY2Vzc19lcnJvcihlKQogICAgICAgICAgICBleGNlcHQgRXhjZXB0aW9uIGFzIGU6CiAgICAgICAgICAgICAgICBmcm9tIGJvdHMudXRpbHMuaGVscGVycyBpbXBvcnQgX3Byb2Nlc3NfZXJyb3IKCiAgICAgICAgICAgICAgICByZXR1cm4gX3Byb2Nlc3NfZXJyb3IoZSkKCiAgICAgICAgIyBVcGRhdGUgZG9jc3RyaW5nIGlmIGRlc2NyaXB0aW9uIHByb3ZpZGVkCiAgICAgICAgaWYgZGVzY3JpcHRpb246CiAgICAgICAgICAgIHdyYXBwZXIuX19kb2NfXyA9IGRlc2NyaXB0aW9uCiAgICAgICAgZWxpZiBub3Qgd3JhcHBlci5fX2RvY19fOgogICAgICAgICAgICAjIEdlbmVyYXRlIG1pbmltYWwgZG9jc3RyaW5nIGZyb20gZnVuY3Rpb24gbmFtZQogICAgICAgICAgICB3cmFwcGVyLl9fZG9jX18gPSBmIkV4ZWN1dGUge2Z1bmMuX19uYW1lX18ucmVwbGFjZSgnXycsICcgJyl9IgoKICAgICAgICByZXR1cm4gd3JhcHBlcgoKICAgIHJldHVybiBkZWNvcmF0b3IKCkB0b29saWZ5KCkKZGVmIHZpZXdfZGlyKHN0YXJ0X3BhdGg6IHN0cj0nLicsIG91dHB1dF9maWxlPU5vbmUsIHRhcmdldF9leHRlbnNpb25zOiBzdHI9IlsncHknLCAndHh0JywgJ21kJ10iLCBtYXhfbGluZXM6IGludD01MDApOgogICAgIiIiCiAgICBDcmVhdGVzIGEgc3VtbWFyeSBvZiB0aGUgZGlyZWN0b3J5IHN0cnVjdHVyZSBzdGFydGluZyBmcm9tIHRoZSBnaXZlbiBwYXRoLCB3cml0aW5nIG9ubHkgZmlsZXMKICAgIHdpdGggc3BlY2lmaWVkIGV4dGVuc2lvbnMgYW5kIHNob3dpbmcgdmVudiBkaXJlY3RvcmllcyB3aXRob3V0IHRoZWlyIGNvbnRlbnRzLgogICAgUGFyYW1ldGVyczoKICAgIC0gc3RhcnRfcGF0aCAoc3RyKTogVGhlIHJvb3QgZGlyZWN0b3J5IHRvIHN0YXJ0IHNjYW5uaW5nIGZyb20uCiAgICAtIG91dHB1dF9maWxlIChzdHIpOiBUaGUgbmFtZSBvZiB0aGUgZmlsZSB0byBvcHRpb25hbGx5IHdyaXRlIHRoZSBkaXJlY3Rvcnkgc3RydWN0dXJlIHRvLgogICAgLSB0YXJnZXRfZXh0ZW5zaW9ucyAoc3RyKTogU3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgbGlzdCBvZiBmaWxlIGV4dGVuc2lvbnMgKGUuZy4gIlsncHknLCAndHh0J10iKS4KICAgIC0gbWF4X2xpbmVzIChpbnQpOiBNYXhpbXVtIG51bWJlciBvZiBsaW5lcyBpbiBvdXRwdXQuIElmIGV4Y2VlZGVkLCBkZWVwZXN0IGxldmVscyBhcmUgdHJ1bmNhdGVkLiBEZWZhdWx0IDUwMC4KICAgIFJldHVybnM6CiAgICBzdHI6IEEgZm9ybWF0dGVkIHN0cmluZyBjb250YWluaW5nIHRoZSBkaXJlY3Rvcnkgc3RydWN0dXJlLCB3aXRoIGVhY2ggZGlyZWN0b3J5IGFuZCBmaWxlIHByb3Blcmx5IGluZGVudGVkLgogICAgRXhhbXBsZSBvdXRwdXQ6CiAgICBteV9wcm9qZWN0LwogICAgICAgIHZlbnYvCiAgICAgICAgbW9kdWxlMS8KICAgICAgICAgICAgc2NyaXB0LnB5CiAgICAgICAgICAgIFJFQURNRS5tZAogICAgICAgIG1vZHVsZTIvCiAgICAgICAgICAgIHV0aWxzLnB5CiAgICBjb3N0OiBsb3cKICAgICIiIgogICAgaWYgbWF4X2xpbmVzOgogICAgICAgIG1heF9saW5lcyA9IGludChtYXhfbGluZXMpCiAgICBleHRlbnNpb25zX2xpc3QgPSBbZXh0LnN0cmlwKCkuc3RyaXAoJ1wnIicpIGZvciBleHQgaW4gdGFyZ2V0X2V4dGVuc2lvbnMuc3RyaXAoJ1tdJykuc3BsaXQoJywnKV0KICAgIGV4dGVuc2lvbnNfbGlzdCA9IFsnLicgKyBleHQgaWYgbm90IGV4dC5zdGFydHN3aXRoKCcuJykgZWxzZSBleHQgZm9yIGV4dCBpbiBleHRlbnNpb25zX2xpc3RdCiAgICBkaXJfZW50cmllcyA9IFtdCiAgICBtYXhfbGV2ZWwgPSAwCiAgICBmb3Igcm9vdCwgZGlycywgZmlsZXMgaW4gb3Mud2FsayhzdGFydF9wYXRoKToKICAgICAgICBsZXZlbCA9IHJvb3QucmVwbGFjZShzdGFydF9wYXRoLCAnJykuY291bnQob3Muc2VwKQogICAgICAgIGluZGVudCA9ICcgICAgJyAqIGxldmVsCiAgICAgICAgYmFzZW5hbWUgPSBvcy5wYXRoLmJhc2VuYW1lKHJvb3QpCiAgICAgICAgaXNfdmVudiA9IGJhc2VuYW1lIGluIFsndmVudicsICdlbnYnLCAnLmVudiddIG9yICdweXZlbnYuY2ZnJyBpbiBmaWxlcwogICAgICAgIGlmIGlzX3ZlbnY6CiAgICAgICAgICAgIGRpcl9lbnRyaWVzLmFwcGVuZCgobGV2ZWwsIGYne2luZGVudH17YmFzZW5hbWV9LycpKQogICAgICAgICAgICBtYXhfbGV2ZWwgPSBtYXgobWF4X2xldmVsLCBsZXZlbCkKICAgICAgICAgICAgZGlyc1s6XSA9IFtdCiAgICAgICAgICAgIGNvbnRpbnVlCiAgICAgICAgaGFzX3JlbGV2YW50X2ZpbGVzID0gRmFsc2UKICAgICAgICBmb3IgXywgXywgZnMgaW4gb3Mud2Fsayhyb290KToKICAgICAgICAgICAgaWYgYW55KChmLmVuZHN3aXRoKHR1cGxlKGV4dGVuc2lvbnNfbGlzdCkpIGZvciBmIGluIGZzKSk6CiAgICAgICAgICAgICAgICBoYXNfcmVsZXZhbnRfZmlsZXMgPSBUcnVlCiAgICAgICAgICAgICAgICBicmVhawogICAgICAgIGlmIGhhc19yZWxldmFudF9maWxlczoKICAgICAgICAgICAgZGlyX2VudHJpZXMuYXBwZW5kKChsZXZlbCwgZid7aW5kZW50fXtiYXNlbmFtZX0vJykpCiAgICAgICAgICAgIG1heF9sZXZlbCA9IG1heChtYXhfbGV2ZWwsIGxldmVsKQogICAgICAgICAgICBzdWJpbmRlbnQgPSAnICAgICcgKiAobGV2ZWwgKyAxKQogICAgICAgICAgICBmb3IgZmlsZSBpbiBmaWxlczoKICAgICAgICAgICAgICAgIGlmIGZpbGUuZW5kc3dpdGgodHVwbGUoZXh0ZW5zaW9uc19saXN0KSk6CiAgICAgICAgICAgICAgICAgICAgZGlyX2VudHJpZXMuYXBwZW5kKChsZXZlbCArIDEsIGYne3N1YmluZGVudH17ZmlsZX0nKSkKICAgICAgICAgICAgICAgICAgICBtYXhfbGV2ZWwgPSBtYXgobWF4X2xldmVsLCBsZXZlbCArIDEpCiAgICBjdXJyZW50X2xldmVsX2xpbWl0ID0gbWF4X2xldmVsCiAgICB3aGlsZSBjdXJyZW50X2xldmVsX2xpbWl0ID49IDA6CiAgICAgICAgZmlsdGVyZWRfZW50cmllcyA9IFsobGV2ZWwsIGxpbmUpIGZvciBsZXZlbCwgbGluZSBpbiBkaXJfZW50cmllcyBpZiBsZXZlbCA8PSBjdXJyZW50X2xldmVsX2xpbWl0XQogICAgICAgIHRydW5jYXRlZF9kaXJzID0gc2V0KCkKICAgICAgICBmb3IgbGV2ZWwsIGxpbmUgaW4gZGlyX2VudHJpZXM6CiAgICAgICAgICAgIGlmIGxldmVsID4gY3VycmVudF9sZXZlbF9saW1pdCBhbmQgbGV2ZWwgPT0gY3VycmVudF9sZXZlbF9saW1pdCArIDE6CiAgICAgICAgICAgICAgICBwYXJlbnRfbGV2ZWwgPSBsZXZlbCAtIDEKICAgICAgICAgICAgICAgIGZvciBwYXJlbnRfbGV2ZWxfY2hlY2ssIHBhcmVudF9saW5lIGluIGZpbHRlcmVkX2VudHJpZXM6CiAgICAgICAgICAgICAgICAgICAgaWYgcGFyZW50X2xldmVsX2NoZWNrID09IHBhcmVudF9sZXZlbCBhbmQgcGFyZW50X2xpbmUuZW5kc3dpdGgoJy8nKToKICAgICAgICAgICAgICAgICAgICAgICAgdHJ1bmNhdGVkX2RpcnMuYWRkKHBhcmVudF9saW5lKQogICAgICAgIGZpbmFsX2VudHJpZXMgPSBbXQogICAgICAgIGZvciBsZXZlbCwgbGluZSBpbiBmaWx0ZXJlZF9lbnRyaWVzOgogICAgICAgICAgICBmaW5hbF9lbnRyaWVzLmFwcGVuZChsaW5lKQogICAgICAgICAgICBpZiBsaW5lIGluIHRydW5jYXRlZF9kaXJzOgogICAgICAgICAgICAgICAgdHJ1bmNhdGlvbl9pbmRlbnQgPSAnICAgICcgKiAobGV2ZWwgKyAxKQogICAgICAgICAgICAgICAgZmluYWxfZW50cmllcy5hcHBlbmQoZid7dHJ1bmNhdGlvbl9pbmRlbnR9Li4uJykKICAgICAgICBpZiBsZW4oZmluYWxfZW50cmllcykgPD0gbWF4X2xpbmVzOgogICAgICAgICAgICBvdXRwdXRfdGV4dCA9IGZpbmFsX2VudHJpZXMKICAgICAgICAgICAgYnJlYWsKICAgICAgICBjdXJyZW50X2xldmVsX2xpbWl0IC09IDEKICAgIGVsc2U6CiAgICAgICAgb3V0cHV0X3RleHQgPSBbZidQcm9qZWN0IHRvbyBsYXJnZSAoPnttYXhfbGluZXN9IGxpbmVzKS4gU2hvd2luZyByb290IGxldmVsIG9ubHk6JywgZid7b3MucGF0aC5iYXNlbmFtZShzdGFydF9wYXRoKSBvciBzdGFydF9wYXRofS8nLCAnICAgIC4uLiddCiAgICBpZiBvdXRwdXRfZmlsZSBpcyBub3QgTm9uZToKICAgICAgICB3aXRoIG9wZW4ob3V0cHV0X2ZpbGUsICd3JykgYXMgZmlsZToKICAgICAgICAgICAgZmlsZS53cml0ZSgnXG4nLmpvaW4ob3V0cHV0X3RleHQpKQogICAgcmV0dXJuICdcbicuam9pbihvdXRwdXRfdGV4dCmUjAlmaWxlX3BhdGiUjCJkeW5hbWljX21vZHVsZV8yMjA3MDYwMzg2ODg5MjY5Mjk1lIwJbmFtZXNwYWNllGgAjA5faW1wb3J0X21vZHVsZZSTlIwvX19ydW50aW1lX18uZHluYW1pY19tb2R1bGVfLTM2NzgyMTE3MjM5MTY4NDc4ODGUhZRSlH2UKGgsaC1onU6MC19fcGFja2FnZV9flE6MCF9fc3BlY19flE6MCF9fZmlsZV9flGixaA+ME2JvdHMuZGV2LmRlY29yYXRvcnOUaA+TlGgQaLxoEJOUaBNovGgTk5SMA2FzdJRotGjAhZRSlIwIZGF0ZXRpbWWUaLRow4WUUpSMCWZ1bmN0b29sc5RotGjGhZRSlIwHaW5zcGVjdJRotGjJhZRSlIwHbG9nZ2luZ5RotGjMhZRSlGhjaLRoY4WUUpSMA3N5c5RotIwDc3lzlIWUUpSMCHRleHR3cmFwlGi0aNWFlFKUjAl0cmFjZWJhY2uUaLRo2IWUUpSMBXdyYXBzlGjGaNuTlIwDQW55lIwGdHlwaW5nlGjdk5SMCENhbGxhYmxllGjeaOCTlIwIT3B0aW9uYWyUaN5o4pOUjARUeXBllGjeaOSTlIwScmVtb3ZlX2NvZGVfYmxvY2tzlGgSaOaTlIwGbG9nZ2VylGjMjAlnZXRMb2dnZXKUk5RovIWUUpSMDE5vSFRUUEZpbHRlcpRovGjtk5SMB2xhenlfZm6UaLxo75OUjApsYXp5X2NsYXNzlGi8aPGTlIwMX2dldF9jb250ZXh0lGi8aPOTlIwRX2dldF9weV9pbnRlcmZhY2WUaLxo9ZOUjARsYXp5lGi8aPeTlIwOZGVidWdfb25fZXJyb3KUaLxo+ZOUjApsb2dfZXJyb3JzlGi8aPuTlIwHdG9vbGlmeZRoAihoBChDBAQWCjaUSwFLAEsASwJLAksDQxKHAJcAiABmAWQBhAh9AXwBUwCUWIgCAAAKICAgIENvbnZlcnQgYW55IGZ1bmN0aW9uIGludG8gYSBib3QgdG9vbCB3aXRoIHN0cmluZy1pbiwgc3RyaW5nLW91dCBpbnRlcmZhY2UuCgogICAgLSBDb252ZXJ0cyBzdHJpbmcgaW5wdXRzIHRvIHByb3BlciB0eXBlcyB1c2luZyB0eXBlIGhpbnRzCiAgICAtIEVuc3VyZXMgc3RyaW5nIG91dHB1dCAoSlNPTiBmb3IgY29tcGxleCB0eXBlcykKICAgIC0gV3JhcHMgaW4gZXJyb3IgaGFuZGxpbmcgKHJldHVybnMgZXJyb3Igc3RyaW5ncywgbmV2ZXIgcmFpc2VzKQogICAgLSBFbmhhbmNlcyBkb2NzdHJpbmcgaWYgZGVzY3JpcHRpb24gcHJvdmlkZWQKCiAgICBBcmdzOgogICAgICAgIGRlc2NyaXB0aW9uIChzdHIsIG9wdGlvbmFsKTogT3ZlcnJpZGUgdGhlIGZ1bmN0aW9uJ3MgZG9jc3RyaW5nCgogICAgRXhhbXBsZToKICAgICAgICBAdG9vbGlmeSgpCiAgICAgICAgZGVmIGFkZF9udW1iZXJzKHg6IGludCwgeTogaW50ID0gMCkgLT4gaW50OgogICAgICAgICAgICByZXR1cm4geCArIHkKCiAgICAgICAgQHRvb2xpZnkoIkNhbGN1bGF0ZSB0aGUgYXJlYSBvZiBhIGNpcmNsZSIpCiAgICAgICAgZGVmIGFyZWEocmFkaXVzOiBmbG9hdCkgLT4gZmxvYXQ6CiAgICAgICAgICAgIHJldHVybiAzLjE0MTU5ICogcmFkaXVzICogcmFkaXVzCiAgICCUaAQoQxQGASgBCP8IAQIsBAEOBQT8GAJIApRLAUsASwBLAksFSxNDupUBhwCXAHQAAAAAAAAAAABqAwAAAAAAAAAAAAAAAAAAAAAAAIkAqwEAAAAAAACIAGYBZAGECKsAAAAAAAAAfQGJAnIJiQJ8AV8CAAAAAAAAAAB8AVMAfAFqBAAAAAAAAAAAAAAAAAAAAAAAAHMkZAKJAGoGAAAAAAAAAAAAAAAAAAAAAAAAagkAAAAAAAAAAAAAAAAAAAAAAABkA2QEqwIAAAAAAACbAJ0CfAFfAgAAAAAAAAAAfAFTAJQoTmgqjAhFeGVjdXRlIJRogowBIJR0lChoxmjbaJ1oLGhldJRoJ2gjhpRoIowJZGVjb3JhdG9ylIwadG9vbGlmeS48bG9jYWxzPi5kZWNvcmF0b3KUSxdDYPmAANwJEo8fiR+YFNMJHvMCKQkp8wMACh/wAikJKfFYAQAMF9geKYhHjE/wCgAQF4gO8AkAEhmXH5If4CAoqBSvHakd1yk+0Sk+uHPAQ9MpSNAoSdAeSohHjE/gDxaIDpRoR4wLZGVzY3JpcHRpb26UhZRoJ4WUdJRSlIaUKWoLAQAAaggBAACGlGgiaP1o/UsBQxH4gAD0LDQFF/BsAQAMFdAEFJRoRylqCwEAAIWUdJRSlH2UaCxoLXNo/WhJTnSUUpR9lH2UKGidagABAABonn2UagsBAABoo3N1hpRijBdfY29udmVydF9zdHJpbmdfdG9fdHlwZZRovGodAQAAk5SMEl9sb2dfZXJyb3JfdG9fZmlsZZRovGofAQAAk5SMB2RpZmZsaWKUaLRqIQEAAIWUUpSMFGNsZWFuX3VuaWNvZGVfc3RyaW5nlIwYYm90cy51dGlscy51bmljb2RlX3V0aWxzlGokAQAAk5SME19yZWFkX2ZpbGVfYm9tX3NhZmWUjBVib3RzLnRvb2xzLmNvZGVfdG9vbHOUaicBAACTlIwUX3dyaXRlX2ZpbGVfYm9tX3NhZmWUaigBAABqKgEAAJOUjAR2aWV3lGooAQAAaiwBAACTlGguaDWMGF9yZW1vdmVfYm9tX2Zyb21fY29udGVudJRqKAEAAGouAQAAk5SMCnBhdGNoX2VkaXSUaigBAABqMAEAAJOUjBpfZmluZF9tYXRjaF93aXRoX2hpZXJhcmNoeZRqKAEAAGoyAQAAk5SMHl9jaGVja19leGFjdF9tYXRjaF9hdF9wb3NpdGlvbpRqKAEAAGo0AQAAk5SMGl9maW5kX2V4YWN0X21hdGNoX2FueXdoZXJllGooAQAAajYBAACTlIwjX2NoZWNrX3doaXRlc3BhY2VfbWF0Y2hfYXRfcG9zaXRpb26UaigBAABqOAEAAJOUjB9fZmluZF93aGl0ZXNwYWNlX21hdGNoX2FueXdoZXJllGooAQAAajoBAACTlIwcX2FkanVzdF9hZGRpdGlvbnNfdG9fY29udGV4dJRqKAEAAGo8AQAAk5SMFl9maW5kX2Jsb2NrX2luX2NvbnRlbnSUaigBAABqPgEAAJOUjBVfZ2V0X2xpbmVfaW5kZW50YXRpb26UaigBAABqQAEAAJOUjA9fbm9ybWFsaXplX3BhdGiUaigBAABqQgEAAJOUjBdfbm9ybWFsaXplX2hlYWRlcl9saW5lc5RqKAEAAGpEAQAAk5R1YowJY29kZV9oYXNolIwgMGFmZDhjNGQxZDFlY2ZjZWIzNTAxM2ViNjVmZGVkNDaUdWJ1fZQoaJ1oOmieaJ91hpRiahYBAAAoaCxoLWidTmi5TowKX19sb2FkZXJfX5ROaLpOaLtosWgPaL1oEGi+aBNov2jAaMJow2jFaMZoyGjJaMtozGjOaGNo0GjRaNRo1WjXaNho2mjbaNxo3WjfaOBo4WjiaONo5GjlaOZo52joaOxo7WjuaO9o8GjxaPJo82j0aPVo9mj3aPho+Wj6aPto/Gj9ahgBAABqHQEAAGoeAQAAah8BAABqIAEAAGohAQAAaiMBAABqJAEAAGomAQAAaicBAABqKQEAAGoqAQAAaisBAABqLAEAAGotAQAAaC5oNWouAQAAai8BAABqMAEAAGoxAQAAajIBAABqMwEAAGo0AQAAajUBAABqNgEAAGo3AQAAajgBAABqOQEAAGo6AQAAajsBAABqPAEAAGo9AQAAaj4BAABqPwEAAGpAAQAAakEBAABqQgEAAGpDAQAAakQBAABqRQEAAIwMX19idWlsdGluc19flGNidWlsdGlucwpfX2RpY3RfXwp1MGiWKGgsaC1onU5ouU5qSgEAAE5ouk5ou2ixaA9ovWgQaL5oE2i/aMBowmjDaMVoxmjIaMloy2jMaM5oY2jQaNFo1GjVaNdo2GjaaNto3GjdaN9o4GjhaOJo42jkaOVo5mjnaOho7GjtaO5o72jwaPFo8mjzaPRo9Wj2aPdo+Gj5aPpo+2j8aP1qGAEAAGodAQAAah4BAABqHwEAAGogAQAAaiEBAABqIwEAAGokAQAAaiYBAABqJwEAAGopAQAAaioBAABqKwEAAGosAQAAai0BAABoLmg1ai4BAABqLwEAAGowAQAAajEBAABqMgEAAGozAQAAajQBAABqNQEAAGo2AQAAajcBAABqOAEAAGo5AQAAajoBAABqOwEAAGo8AQAAaj0BAABqPgEAAGo/AQAAakABAABqQQEAAGpCAQAAakMBAABqRAEAAGpFAQAAaksBAABjYnVpbHRpbnMKX19kaWN0X18KdTCMCGJ1aWx0aW5zlIwHZ2V0YXR0cpSTlIwEZGlsbJSMBV9kaWxslJOUjAhfc2V0YXR0cpRqTAEAAIwHc2V0YXR0cpSTlIeUUpRoMowNY2VsbF9jb250ZW50c5RomoeUUjBoKyhoLGgtaJ1OaLlOakoBAABOaLpOaLtosWgPaL1oEGi+aBNov2jAaMJow2jFaMZoyGjJaMtozGjOaGNo0GjRaNRo1WjXaNho2mjbaNxo3WjfaOBo4WjiaONo5GjlaOZo52joaOxo7WjuaO9o8GjxaPJo82j0aPVo9mj3aPho+Wj6aPto/Gj9ahgBAABqHQEAAGoeAQAAah8BAABqIAEAAGohAQAAaiMBAABqJAEAAGomAQAAaicBAABqKQEAAGoqAQAAaisBAABqLAEAAGotAQAAaC5oNWouAQAAai8BAABqMAEAAGoxAQAAajIBAABqMwEAAGo0AQAAajUBAABqNgEAAGo3AQAAajgBAABqOQEAAGo6AQAAajsBAABqPAEAAGo9AQAAaj4BAABqPwEAAGpAAQAAakEBAABqQgEAAGpDAQAAakQBAABqRQEAAGpLAQAAY2J1aWx0aW5zCl9fZGljdF9fCnUwLg==",
      "name": "view_dir",
      "hash": "0733076c93148a8d5eac89295e9f19185d44a4b09314d292eb63c5f556f64735",
      "provenance": {
       "module": "dynamic_module_-3678211723916847881",
       "qualname": "view_dir"
      }
     },
     "_remove_bom_from_content": {
      "__helper_func__": true,
      "pickled": "gASVNgAAAAAAAACMFWJvdHMudG9vbHMuY29kZV90b29sc5SMGF9yZW1vdmVfYm9tX2Zyb21fY29udGVudJSTlC4=",
      "name": "_remove_bom_from_content",
      "hash": "d9d446d33da960fcc8b018bd9547231a837f7eb9a2ba7f3c4b816ead1341b18b",
      "provenance": {
       "module": "bots.tools.code_tools",
       "qualname": "_remove_bom_from_content"
      }
     },
     "patch_edit": {
      "__imported_callable__": true,
      "pickled": "gASVKAAAAAAAAACMFWJvdHMudG9vbHMuY29kZV90b29sc5SMCnBhdGNoX2VkaXSUk5Qu",
      "name": "patch_edit",
      "hash": "a9661a3046d1fae3a45b08fbf107dd4a8e1b655c8d5e2575a52dfbcf5446cd76",
      "provenance": {
       "module": "bots.tools.code_tools",
       "qualname": "patch_edit"
      }
     },
     "_find_match_with_hierarchy": {
      "__helper_func__": true,
      "pickled": "gASVOAAAAAAAAACMFWJvdHMudG9vbHMuY29kZV90b29sc5SMGl9maW5kX21hdGNoX3dpdGhfaGllcmFyY2h5lJOULg==",
      "name": "_find_match_with_hierarchy",
      "hash": "72cfaacd68dc4ef6dd01b4d0d154dc1ed416f6dc9f878c0c751e427676175d04",
      "provenance": {
       "module": "bots.tools.code_tools",
       "qualname": "_find_match_with_hierarchy"
      }
     },
     "_check_exact_match_at_position": {
      "__helper_func__": true,
      "pickled": "gASVPAAAAAAAAACMFWJvdHMudG9vbHMuY29kZV90b29sc5SMHl9jaGVja19leGFjdF9tYXRjaF9hdF9wb3NpdGlvbpSTlC4=",
      "name": "_check_exact_match_at_position",
      "hash": "954282a86f378dc83f5c8a5c4e752ce4f656dc2a05bd95b26402cab246431588",
      "provenance": {
       "module": "bots.tools.code_tools",
       "qualname": "_check_exact_match_at_position"
      }
     },
     "_find_exact_match_anywhere": {
      "__helper_func__": true,
      "pickled": "gASVOAAAAAAAAACMFWJvdHMudG9vbHMuY29kZV90b29sc5SMGl9maW5kX2V4YWN0X21hdGNoX2FueXdoZXJllJOULg==",
      "name": "_find_exact_match_anywhere",
      "hash": "6f8df2c5f4ecfdb97043bd57ebcaf73ce2bbc581e6c2e5a6910bd1e30ca00f29",
      "provenance": {
       "module": "bots.tools.code_tools",
       "qualname": "_find_exact_match_anywhere"
      }
     },
     "_check_whitespace_match_at_position": {
      "__helper_func__": true,
      "pickled": "gASVQQAAAAAAAACMFWJvdHMudG9vbHMuY29kZV90b29sc5SMI19jaGVja193aGl0ZXNwYWNlX21hdGNoX2F0X3Bvc2l0aW9ulJOULg==",
      "name": "_check_whitespace_match_at_position",
      "hash": "c37161b273930ea6072ae82862b8f339d761bf21f953c8977511f653cdb8fdee",
      "provenance": {
       "module": "bots.tools.code_tools",
       "qualname": "_check_whitespace_match_at_position"
      }
     },
     "_find_whitespace_match_anywhere": {
      "__helper_func__": true,
      "pickled": "gASVPQAAAAAAAACMFWJvdHMudG9vbHMuY29kZV90b29sc5SMH19maW5kX3doaXRlc3BhY2VfbWF0Y2hfYW55d2hlcmWUk5Qu",
      "name": "_find_whitespace_match_anywhere",
      "hash": "58cbf338385d6aedded2c770972ee96c2ec3f40244a5e7fd4d77fb0f2cb1eb9f",
      "provenance": {
       "module": "bots.tools.code_tools",
       "qualname": "_find_whitespace_match_anywhere"
      }
     },
     "_adjust_additions_to_context": {
      "__helper_func__": true,
      "pickled": "gASVOgAAAAAAAACMFWJvdHMudG9vbHMuY29kZV90b29sc5SMHF9hZGp1c3RfYWRkaXRpb25zX3RvX2NvbnRleHSUk5Qu",
      "name": "_adjust_additions_to_context",
      "hash": "ac4e016513ea5a6c2f8c793716cc23ed4a4b5f0b5bd36335bf4ef717c160aa24",
      "provenance": {
       "module": "bots.tools.code_tools",
       "qualname": "_adjust_additions_to_context"
      }
     },
     "_find_block_in_content": {
      "__helper_func__": true,
      "pickled": "gASVNAAAAAAAAACMFWJvdHMudG9vbHMuY29kZV90b29sc5SMFl9maW5kX2Jsb2NrX2luX2NvbnRlbnSUk5Qu",
      "name": "_find_block_in_content",
      "hash": "2d17add9744a0cc0464e74ca36a537755901c56c480c2415f52cbabfb904a641",
      "provenance": {
       "module": "bots.tools.code_tools",
       "qualname": "_find_block_in_content"
      }
     },
     "_get_line_indentation": {
      "__helper_func__": true,
      "pickled": "gASVMwAAAAAAAACMFWJvdHMudG9vbHMuY29kZV90b29sc5SMFV9nZXRfbGluZV9pbmRlbnRhdGlvbpSTlC4=",
      "name": "_get_line_indentation",
      "hash": "3e53aa2ee6bb58d4cef81abb0b40fe7def49633328504b5125ec4539ca92567d",
      "provenance": {
       "module": "bots.tools.code_tools",
       "qualname": "_get_line_indentation"
      }
     },
     "_normalize_path": {
      "__helper_func__": true,
      "pickled": "gASVLQAAAAAAAACMFWJvdHMudG9vbHMuY29kZV90b29sc5SMD19ub3JtYWxpemVfcGF0aJSTlC4=",
      "name": "_normalize_path",
      "hash": "f66c63bbb8160b5675fff68fe72db8018887054bc654c6991da8306b7f96bf25",
      "provenance": {
       "module": "bots.tools.code_tools",
       "qualname": "_normalize_path"
      }
     },
     "_normalize_header_lines": {
      "__helper_func__": true,
      "pickled": "gASVNQAAAAAAAACMFWJvdHMudG9vbHMuY29kZV90b29sc5SMF19ub3JtYWxpemVfaGVhZGVyX2xpbmVzlJOULg==",
      "name": "_normalize_header_lines",
      "hash": "74939c7140ffdd2cb344d2edc81428ecd0e0216ebd1b7ae24bc5691de94036d2",
      "provenance": {
       "module": "bots.tools.code_tools",
       "qualname": "_normalize_header_lines"
      }
     }
    }
   },
   "dynamic_module_-3217427946027585444": {
    "name": "dynamic_module_-1753053330809666478",
    "source": "import ast\nfrom bots.utils.helpers import _process_error\n\ndef toolify(description: str = None):\n    \"\"\"\n    Convert any function into a bot tool with string-in, string-out interface.\n\n    - Converts string inputs to proper types using type hints\n    - Ensures string output (JSON for complex types)\n    - Wraps in error handling (returns error strings, never raises)\n    - Enhances docstring if description provided\n\n    Args:\n        description (str, optional): Override the function's docstring\n\n    Example:\n        @toolify()\n        def add_numbers(x: int, y: int = 0) -> int:\n            return x + y\n\n        @toolify(\"Calculate the area of a circle\")\n        def area(radius: float) -> float:\n            return 3.14159 * radius * radius\n    \"\"\"\n\n    def decorator(func):\n        @functools.wraps(func)\n        def wrapper(*args, **kwargs):\n            try:\n                # Convert string inputs to proper types using type hints\n                converted_args, converted_kwargs = _convert_tool_inputs(func, args, kwargs)\n\n                # Call original function\n                result = func(*converted_args, **converted_kwargs)\n\n                # Convert result to string\n                return _convert_tool_output(result)\n\n            except KeyboardInterrupt as e:\n                # Convert KeyboardInterrupt to ToolExecutionError to prevent it from\n                # bubbling up to CLI and being treated as user Ctrl+C\n\n                tool_error = ToolExecutionError(f\"Tool execution interrupted: {str(e)}\")\n                return _process_error(tool_error)\n\n            except TypeError as e:\n                # Check if this is a missing required argument error\n                error_msg = str(e)\n                if \"missing\" in error_msg and \"required\" in error_msg and \"argument\" in error_msg:\n                    # Add special message for output token limitation\n                    enhanced_error = TypeError(\n                        f\"{error_msg}\\n\\n\"\n                        f\"\u26a0\ufe0f  This error is commonly caused by hitting the max_tokens limit before completing the tool call.\\n\"\n                        f\"The response was truncated mid-parameter, making it appear that required parameters are missing.\\n\"\n                        f\"To fix this: Work in SMALLER CHUNKS. Edit fewer lines at a time, \"\n                        f\"or break your task into multiple steps.\"\n                    )\n\n                    return _process_error(enhanced_error)\n                else:\n\n                    return _process_error(e)\n            except Exception as e:\n\n                return _process_error(e)\n\n        # Update docstring if description provided\n        if description:\n            wrapper.__doc__ = description\n        elif not wrapper.__doc__:\n            # Generate minimal docstring from function name\n            wrapper.__doc__ = f\"Execute {func.__name__.replace('_', ' ')}\"\n\n        return wrapper\n\n    return decorator\n\n@toolify()\ndef python_view(target_scope: str, max_lines: str='500') -> str:\n    \"\"\"\n    View Python code using pytest-style scope syntax with scope-aware truncation.\n\n    Parameters:\n    -----------\n    target_scope : str\n        Location to view in pytest-style scope syntax:\n        - \"file.py\" (whole file)\n        - \"file.py::MyClass\" (class)\n        - \"file.py::my_function\" (function)\n        - \"file.py::MyClass::method\" (method)\n    max_lines : int, optional\n        Maximum number of lines in output. If exceeded, deeper scopes will be\n        progressively truncated to create an outline view. Default 500.\n\n    Returns:\n    --------\n    str\n        The source code at the specified scope, or error message\n    \"\"\"\n    max_lines = int(max_lines)\n    try:\n        file_path, *path_elements = target_scope.split('::')\n        if not file_path.endswith('.py'):\n            return _process_error(ValueError(f'File path must end with .py: {file_path}'))\n        for element in path_elements:\n            if not element.isidentifier():\n                return _process_error(ValueError(f'Invalid identifier in path: {element}'))\n        abs_path = os.path.abspath(file_path)\n        if not os.path.exists(abs_path):\n            return _process_error(FileNotFoundError(f'File not found: {abs_path}'))\n        try:\n            source_code = _read_file_bom_safe(abs_path)\n            if not source_code.strip():\n                return f\"File '{abs_path}' is empty.\"\n        except Exception as e:\n            return _process_error(ValueError(f'Error reading file {abs_path}: {str(e)}'))\n        if not path_elements:\n            if max_lines and max_lines > 0:\n                return _apply_scope_aware_truncation(source_code, max_lines)\n            return source_code\n        try:\n            wrapper = cst.MetadataWrapper(cst.parse_module(source_code))\n        except Exception as e:\n            return _process_error(ValueError(f'Error parsing file {abs_path}: {str(e)}'))\n        finder = ScopeFinder(path_elements)\n        wrapper.visit(finder)\n        if not finder.target_node:\n            return _process_error(ValueError(f'Target scope not found: {target_scope}'))\n        result_code = wrapper.module.code_for_node(finder.target_node)\n        if max_lines and max_lines > 0:\n            return _apply_scope_aware_truncation(result_code, max_lines)\n        return result_code\n    except Exception as e:\n        return _process_error(e)\n\ndef _read_file_bom_safe(file_path: str) -> str:\n    \"\"\"Read a file with BOM protection.\"\"\"\n    with open(file_path, 'r', encoding='utf-8') as file:\n        content = file.read()\n    return clean_unicode_string(content)\n\ndef _apply_scope_aware_truncation(source_code: str, max_lines: int) -> str:\n    \"\"\"Apply scope-aware truncation to Python source code.\"\"\"\n    if not source_code.strip():\n        return source_code\n    lines = source_code.splitlines()\n    if len(lines) <= max_lines:\n        return source_code\n    tree = ast.parse(source_code)\n    scope_entries = []\n    _collect_scope_entries(tree, scope_entries, 0)\n    max_depth = max((entry['depth'] for entry in scope_entries), default=0)\n    for current_depth_limit in range(max_depth, -1, -1):\n        result_lines = _create_outline_view(scope_entries, current_depth_limit, lines)\n        if len(result_lines) <= max_lines:\n            return '\\n'.join(result_lines)\n    result_lines = _create_outline_view(scope_entries, 0, lines)\n    if len(result_lines) > max_lines:\n        result_lines = _create_signature_outline(scope_entries, lines, max_lines)\n    return '\\n'.join(result_lines)",
    "file_path": "dynamic_module_-3217427946027585444",
    "code_hash": "868a65001a429c1fc16c3bedb9518d3e",
    "globals": {
     "_convert_tool_inputs": {
      "__helper_func__": true,
      "pickled": "gASVMAAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjBRfY29udmVydF90b29sX2lucHV0c5STlC4=",
      "name": "_convert_tool_inputs",
      "hash": "8bc4aba1c7d69350a812d8553b6a7ff0cd23ae5c818f3b9533752a69e91acf2e",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "_convert_tool_inputs"
      }
     },
     "_convert_tool_output": {
      "__helper_func__": true,
      "pickled": "gASVMAAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjBRfY29udmVydF90b29sX291dHB1dJSTlC4=",
      "name": "_convert_tool_output",
      "hash": "6c85767d30db1c50646d25d2b954c893aed15774f97345f9b8c99674c59cf928",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "_convert_tool_output"
      }
     },
     "ToolExecutionError": {
      "__imported_callable__": true,
      "pickled": "gASVLgAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjBJUb29sRXhlY3V0aW9uRXJyb3KUk5Qu",
      "name": "ToolExecutionError",
      "hash": "e3f136f46cc3014d1b1a8ac6716adb9da7db1dd83f2ed8529e090d97ae0db998",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "ToolExecutionError"
      }
     },
     "ast": {
      "__module_type__": true,
      "name": "ast",
      "spec": "ast"
     },
     "datetime": {
      "__module_type__": true,
      "name": "datetime",
      "spec": "datetime"
     },
     "functools": {
      "__module_type__": true,
      "name": "functools",
      "spec": "functools"
     },
     "inspect": {
      "__module_type__": true,
      "name": "inspect",
      "spec": "inspect"
     },
     "logging": {
      "__module_type__": true,
      "name": "logging",
      "spec": "logging"
     },
     "os": {
      "__module_type__": true,
      "name": "os",
      "spec": "os"
     },
     "sys": {
      "__module_type__": true,
      "name": "sys",
      "spec": "sys"
     },
     "textwrap": {
      "__module_type__": true,
      "name": "textwrap",
      "spec": "textwrap"
     },
     "traceback": {
      "__module_type__": true,
      "name": "traceback",
      "spec": "traceback"
     },
     "wraps": {
      "__imported_callable__": true,
      "pickled": "gASVFwAAAAAAAACMCWZ1bmN0b29sc5SMBXdyYXBzlJOULg==",
      "name": "wraps",
      "hash": "4c7c8f91a978a903bce2515f7fe83cb09b7074259dabad02b312209312f718ed",
      "provenance": {
       "module": "functools",
       "qualname": "wraps"
      }
     },
     "Any": {
      "__imported_callable__": true,
      "pickled": "gASVEgAAAAAAAACMBnR5cGluZ5SMA0FueZSTlC4=",
      "name": "Any",
      "hash": "fbf19bc6bf716a555ce7094664e2bc898734e4acfc2cd6d9ee399edef2e5c02b",
      "provenance": {
       "module": "typing",
       "qualname": "Any"
      }
     },
     "Callable": {
      "__imported_callable__": true,
      "pickled": "gASVFwAAAAAAAACMBnR5cGluZ5SMCENhbGxhYmxllJOULg==",
      "name": "Callable",
      "hash": "17cf7f09b805961290dccb95aa11199df32c246cb879f355ffa1a31d6285edad",
      "provenance": {
       "module": "typing",
       "qualname": "Callable"
      }
     },
     "Optional": {
      "__imported_callable__": true,
      "pickled": "gASVFwAAAAAAAACMBnR5cGluZ5SMCE9wdGlvbmFslJOULg==",
      "name": "Optional",
      "hash": "d69b63c158dd563d1537447d9d3a68afdda0efb70794ab11c234d01e2e593e56",
      "provenance": {
       "module": "typing",
       "qualname": "Optional"
      }
     },
     "Type": {
      "__imported_callable__": true,
      "pickled": "gASVEwAAAAAAAACMBnR5cGluZ5SMBFR5cGWUk5Qu",
      "name": "Type",
      "hash": "9e98fdb991d3addb0aad6e13cd94b21998f5d97e9f30b15f9c697afe5cde1832",
      "provenance": {
       "module": "typing",
       "qualname": "Type"
      }
     },
     "remove_code_blocks": {
      "__imported_callable__": true,
      "pickled": "gASVLQAAAAAAAACMEmJvdHMudXRpbHMuaGVscGVyc5SMEnJlbW92ZV9jb2RlX2Jsb2Nrc5STlC4=",
      "name": "remove_code_blocks",
      "hash": "44524fda389310a2a28f80da99409efd110baefaa9ea50345d092a634c89fc1d",
      "provenance": {
       "module": "bots.utils.helpers",
       "qualname": "remove_code_blocks"
      }
     },
     "NoHTTPFilter": {
      "__imported_callable__": true,
      "pickled": "gASVKAAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjAxOb0hUVFBGaWx0ZXKUk5Qu",
      "name": "NoHTTPFilter",
      "hash": "9f920bc687c51afef3dea517f9b64393473ed37dac3fda0cedd01a655b483a52",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "NoHTTPFilter"
      }
     },
     "lazy_fn": {
      "__imported_callable__": true,
      "pickled": "gASVIwAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjAdsYXp5X2ZulJOULg==",
      "name": "lazy_fn",
      "hash": "a1737e2cf8adde594f0dd0b3f17ffaad4c126dcf16906e82cb07f18c13d8b7a2",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "lazy_fn"
      }
     },
     "lazy_class": {
      "__imported_callable__": true,
      "pickled": "gASVJgAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjApsYXp5X2NsYXNzlJOULg==",
      "name": "lazy_class",
      "hash": "d1883fc4e7eb2d64f47b4e90b4b6b69d0c5be0d0e3175787058ad631d122e4c6",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "lazy_class"
      }
     },
     "_get_context": {
      "__helper_func__": true,
      "pickled": "gASVKAAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjAxfZ2V0X2NvbnRleHSUk5Qu",
      "name": "_get_context",
      "hash": "979ef249cdc1f76f4020d948ffc352f7c667afb0d89f221770156eebd7717c7a",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "_get_context"
      }
     },
     "_get_py_interface": {
      "__helper_func__": true,
      "pickled": "gASVLQAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjBFfZ2V0X3B5X2ludGVyZmFjZZSTlC4=",
      "name": "_get_py_interface",
      "hash": "d45b0506fb8815e8d9c3a9217b0ca101dac4fb9f51c8546285cf68a95ab027e7",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "_get_py_interface"
      }
     },
     "lazy": {
      "__imported_callable__": true,
      "pickled": "gASVIAAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjARsYXp5lJOULg==",
      "name": "lazy",
      "hash": "6e25446d8765ac65a5518c01582ddf52784eb90c51d57e224c94823d5b7c55cd",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "lazy"
      }
     },
     "debug_on_error": {
      "__imported_callable__": true,
      "pickled": "gASVKgAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjA5kZWJ1Z19vbl9lcnJvcpSTlC4=",
      "name": "debug_on_error",
      "hash": "06d89d594519c41c1dae666437441d4fd4aeeea959f1c905694940a50ae4ddfe",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "debug_on_error"
      }
     },
     "log_errors": {
      "__imported_callable__": true,
      "pickled": "gASVJgAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjApsb2dfZXJyb3JzlJOULg==",
      "name": "log_errors",
      "hash": "f9446c0ae11aa5bb7726b83da744e8dc707a91edc91085abbca1cefd1897d829",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "log_errors"
      }
     },
     "toolify": {
      "__imported_callable__": true,
      "pickled": "gASVC0gAAAAAAACMCmRpbGwuX2RpbGyUjBBfY3JlYXRlX2Z1bmN0aW9ulJOUKGgAjAxfY3JlYXRlX2NvZGWUk5QoQwQEFgo2lEsBSwBLAEsCSwJLA0MShwCXAIgAZgFkAYQIfQF8AVMAlFiIAgAACiAgICBDb252ZXJ0IGFueSBmdW5jdGlvbiBpbnRvIGEgYm90IHRvb2wgd2l0aCBzdHJpbmctaW4sIHN0cmluZy1vdXQgaW50ZXJmYWNlLgoKICAgIC0gQ29udmVydHMgc3RyaW5nIGlucHV0cyB0byBwcm9wZXIgdHlwZXMgdXNpbmcgdHlwZSBoaW50cwogICAgLSBFbnN1cmVzIHN0cmluZyBvdXRwdXQgKEpTT04gZm9yIGNvbXBsZXggdHlwZXMpCiAgICAtIFdyYXBzIGluIGVycm9yIGhhbmRsaW5nIChyZXR1cm5zIGVycm9yIHN0cmluZ3MsIG5ldmVyIHJhaXNlcykKICAgIC0gRW5oYW5jZXMgZG9jc3RyaW5nIGlmIGRlc2NyaXB0aW9uIHByb3ZpZGVkCgogICAgQXJnczoKICAgICAgICBkZXNjcmlwdGlvbiAoc3RyLCBvcHRpb25hbCk6IE92ZXJyaWRlIHRoZSBmdW5jdGlvbidzIGRvY3N0cmluZwoKICAgIEV4YW1wbGU6CiAgICAgICAgQHRvb2xpZnkoKQogICAgICAgIGRlZiBhZGRfbnVtYmVycyh4OiBpbnQsIHk6IGludCA9IDApIC0+IGludDoKICAgICAgICAgICAgcmV0dXJuIHggKyB5CgogICAgICAgIEB0b29saWZ5KCJDYWxjdWxhdGUgdGhlIGFyZWEgb2YgYSBjaXJjbGUiKQogICAgICAgIGRlZiBhcmVhKHJhZGl1czogZmxvYXQpIC0+IGZsb2F0OgogICAgICAgICAgICByZXR1cm4gMy4xNDE1OSAqIHJhZGl1cyAqIHJhZGl1cwogICAglGgEKEMUBgEoAQj/CAECLAQBDgUE/BgCSAKUSwFLAEsASwJLBUsTQ7qVAYcAlwB0AAAAAAAAAAAAagMAAAAAAAAAAAAAAAAAAAAAAACJAKsBAAAAAAAAiABmAWQBhAirAAAAAAAAAH0BiQJyCYkCfAFfAgAAAAAAAAAAfAFTAHwBagQAAAAAAAAAAAAAAAAAAAAAAABzJGQCiQBqBgAAAAAAAAAAAAAAAAAAAAAAAGoJAAAAAAAAAAAAAAAAAAAAAAAAZANkBKsCAAAAAAAAmwCdAnwBXwIAAAAAAAAAAHwBUwCUKE5oBChDLAQCAgIgAxADGAIQAwwCLgEiAhACFgEYAgoBCP8KBwwCGgIMAiIBEAEMAiL9lEsASwBLAEsKSwdLH0KuAQAAlQGXAAkAdAEAAAAAAAAAAIkKfAB8AasDAAAAAAAAXAIAAH0CfQMCAIkKfAJpAHwDpAGOAX0EdAMAAAAAAAAAAHwEqwEAAAAAAABTACMAdAQAAAAAAAAAACQAci99BWQBZAJsA20EfQYBAHQLAAAAAAAAAABkA3QNAAAAAAAAAAB8BasBAAAAAAAAmwCdAqsBAAAAAAAAfQcCAHwGfAerAQAAAAAAAGMCWQBkAH0FfgVTAGQAfQV+BXcBdA4AAAAAAAAAACQAclB9BXQNAAAAAAAAAAB8BasBAAAAAAAAfQhkBHwIdgByKWQFfAh2AHIlZAZ8CHYAciF0DwAAAAAAAAAAfAibAGQHnQKrAQAAAAAAAH0JZAFkAmwDbQR9BgEAAgB8BnwJqwEAAAAAAABjAlkAZAB9BX4FUwBkAWQCbANtBH0GAQACAHwGfAWrAQAAAAAAAGMCWQBkAH0FfgVTAGQAfQV+BXcBdBAAAAAAAAAAACQAchh9BWQBZAJsA20EfQYBAAIAfAZ8BasBAAAAAAAAYwJZAGQAfQV+BVMAZAB9BX4FdwF3AHgDWQB3AZQoTksAjA5fcHJvY2Vzc19lcnJvcpSFlIwcVG9vbCBleGVjdXRpb24gaW50ZXJydXB0ZWQ6IJSMB21pc3NpbmeUjAhyZXF1aXJlZJSMCGFyZ3VtZW50lFgyAQAACgrimqDvuI8gIFRoaXMgZXJyb3IgaXMgY29tbW9ubHkgY2F1c2VkIGJ5IGhpdHRpbmcgdGhlIG1heF90b2tlbnMgbGltaXQgYmVmb3JlIGNvbXBsZXRpbmcgdGhlIHRvb2wgY2FsbC4KVGhlIHJlc3BvbnNlIHdhcyB0cnVuY2F0ZWQgbWlkLXBhcmFtZXRlciwgbWFraW5nIGl0IGFwcGVhciB0aGF0IHJlcXVpcmVkIHBhcmFtZXRlcnMgYXJlIG1pc3NpbmcuClRvIGZpeCB0aGlzOiBXb3JrIGluIFNNQUxMRVIgQ0hVTktTLiBFZGl0IGZld2VyIGxpbmVzIGF0IGEgdGltZSwgb3IgYnJlYWsgeW91ciB0YXNrIGludG8gbXVsdGlwbGUgc3RlcHMulHSUKIwUX2NvbnZlcnRfdG9vbF9pbnB1dHOUjBRfY29udmVydF90b29sX291dHB1dJSMEUtleWJvYXJkSW50ZXJydXB0lIwSYm90cy51dGlscy5oZWxwZXJzlGgMjBJUb29sRXhlY3V0aW9uRXJyb3KUjANzdHKUjAlUeXBlRXJyb3KUjAlFeGNlcHRpb26UdJQojARhcmdzlIwGa3dhcmdzlIwOY29udmVydGVkX2FyZ3OUjBBjb252ZXJ0ZWRfa3dhcmdzlIwGcmVzdWx0lIwBZZRoDIwKdG9vbF9lcnJvcpSMCWVycm9yX21zZ5SMDmVuaGFuY2VkX2Vycm9ylHSUjAg8c3RyaW5nPpSMB3dyYXBwZXKUjCt0b29saWZ5Ljxsb2NhbHM+LmRlY29yYXRvci48bG9jYWxzPi53cmFwcGVylEsYQ+34gADwBCgNKeQzR8gEyGTQVFrTM1vREDCQDtAgMPEGABoemH7QGULQMUHRGUKQBvQGABgsqEbTFzPQEDP45BMk8gAGDTL1BgARPuQdL9AyTsxz0FNUy3bIaNAwV9MdWJAK2RcloGrTFzHVEDH75BMc8gASDS3kHB+gAZtGkAnYExygCdETKahquEnRLkXIKtBYYdFKYeQlLtgbJJgr8AAEJkIB8AAEGUMB8wMGJhaQTvUOABVCAeEbKagu0xs51RQ55RRB4RspqCHTGyzVFCz73BMc8gADDSndED3hFyWgYdMXKNUQKPvwBwMNKfqUQ0qDIiYApglDFAOvJEEZA8ETAUMUA8EZDEMUA8ElMkIwA8IXAUMUA8IdDUIwA8IqAUMUA8IwDEMUA8I8DUMPA8MJAUMUA8MPBUMUA5SMBGZ1bmOUhZQpdJRSlIwIRXhlY3V0ZSCUjAFflIwBIJR0lCiMCWZ1bmN0b29sc5SMBXdyYXBzlIwHX19kb2NfX5SMCF9fbmFtZV9flIwHcmVwbGFjZZR0lGgsaCiGlGgnjAlkZWNvcmF0b3KUjBp0b29saWZ5Ljxsb2NhbHM+LmRlY29yYXRvcpRLF0Ng+YAA3AkSjx+JH5gU0wke8wIpCSnzAwAKH/ACKQkp8VgBAAwX2B4piEeMT/AKABAXiA7wCQASGZcfkh/gICioFK8dqR3XKT7RKT64c8BD0ylI0ChJ0B5KiEeMT+APFogOlEMAlIwLZGVzY3JpcHRpb26UhZRoLIWUdJRSlIaUKWg/aDuGlGgnjAd0b29saWZ5lGhGSwFDEfiAAPQsNAUX8GwBAAwV0AQUlGg+KWg/hZR0lFKUfZRoN4wjZHluYW1pY19tb2R1bGVfLTE3NTMwNTMzMzA4MDk2NjY0NziUc2hGToWUTnSUUpR9lH2UKGg2aAeMD19fYW5ub3RhdGlvbnNfX5R9lGg/aACMCl9sb2FkX3R5cGWUk5RoGYWUUpRzdYaUYmhLKGg3aExoNk6MC19fcGFja2FnZV9flE6MCl9fbG9hZGVyX1+UTowIX19zcGVjX1+UTowIX19maWxlX1+UjCNkeW5hbWljX21vZHVsZV8tMzIxNzQyNzk0NjAyNzU4NTQ0NJRoFIwTYm90cy5kZXYuZGVjb3JhdG9yc5RoFJOUaBVoXmgVk5RoGGheaBiTlIwDYXN0lGgAjA5faW1wb3J0X21vZHVsZZSTlGhihZRSlIwIZGF0ZXRpbWWUaGRoZ4WUUpRoNGhkaDSFlFKUjAdpbnNwZWN0lGhkaGyFlFKUjAdsb2dnaW5nlGhkaG+FlFKUjAJvc5RoZGhyhZRSlIwDc3lzlGhkjANzeXOUhZRSlIwIdGV4dHdyYXCUaGRoeYWUUpSMCXRyYWNlYmFja5RoZGh8hZRSlGg1aDRoNZOUjANBbnmUjAZ0eXBpbmeUaICTlIwIQ2FsbGFibGWUaIFog5OUjAhPcHRpb25hbJRogWiFk5SMBFR5cGWUaIFoh5OUjBJyZW1vdmVfY29kZV9ibG9ja3OUaBdoiZOUjAZsb2dnZXKUaG+MCWdldExvZ2dlcpSTlGhehZRSlIwMTm9IVFRQRmlsdGVylGheaJCTlIwHbGF6eV9mbpRoXmiSk5SMCmxhenlfY2xhc3OUaF5olJOUjAxfZ2V0X2NvbnRleHSUaF5olpOUjBFfZ2V0X3B5X2ludGVyZmFjZZRoXmiYk5SMBGxhenmUaF5ompOUjA5kZWJ1Z19vbl9lcnJvcpRoXmick5SMCmxvZ19lcnJvcnOUaF5onpOUaEZoT4wXX2NvbnZlcnRfc3RyaW5nX3RvX3R5cGWUaF5ooJOUjBJfbG9nX2Vycm9yX3RvX2ZpbGWUaF5oopOUjARMaXN0lGiBaKSTlIwFVW5pb26UaIFoppOUjANjc3SUaGSMBmxpYmNzdJSFlFKUaAxoF2gMk5SMEV9weV9hc3RfdG9fc291cmNllGgXaK2TlIwUY2xlYW5fdW5pY29kZV9zdHJpbmeUjBhib3RzLnV0aWxzLnVuaWNvZGVfdXRpbHOUaK+TlIwKX21ha2VfZmlsZZSMFmJvdHMudG9vbHMucHl0aG9uX2VkaXSUaLKTlIwTX3JlYWRfZmlsZV9ib21fc2FmZZRoAihoBChDDAICHgEg/xACFv4QApRLAUsASwBLA0sGSwNDkpcAdAEAAAAAAAAAAHwAZAFkAqwDqwMAAAAAAAA1AH0BfAFqAwAAAAAAAAAAAAAAAAAAAAAAAKsAAAAAAAAAfQJkBGQEZASrAgAAAAAAAAEAdAUAAAAAAAAAAHwCqwEAAAAAAABTACMAMQBzAXcCAQBZAAEAAQB0BQAAAAAAAAAAfwKrAQAAAAAAAFMAeANZAHcBlCiMIFJlYWQgYSBmaWxlIHdpdGggQk9NIHByb3RlY3Rpb24ulIwBcpSMBXV0Zi04lIwIZW5jb2RpbmeUhZROdJSMBG9wZW6UjARyZWFklGivh5SMCWZpbGVfcGF0aJSMBGZpbGWUjAdjb250ZW50lIeUaCdotWi1S4lDPIAA5AkNiGmYE6B31QkvsDTYEhaXKZEpkyuIB/cDAAow5AsfoAfTCyjQBCj3BQAKMOQLH6AH0wso0AQo+pRDCY8RMwOzBUEGB5QpKXSUUpR9lGg3aExzaLVOTnSUUpR9lH2UKGg2aLhoUn2UKGjBaFeMBnJldHVybpRoV3V1hpRiaMkoaDdoTGg2TmhZTmhaTmhbTmhcaF1oFGhfaBVoYGgYaGFoYmhmaGdoaWg0aGtobGhuaG9ocWhyaHRodWh4aHloe2h8aH5oNWh/aIBogmiDaIRohWiGaIdoiGiJaIpoi2iPaJBokWiSaJNolGiVaJZol2iYaJlommibaJxonWieaJ9oRmhPaKBooWiiaKNopGilaKZop2ioaKtoDGisaK1ormivaLFosmi0aLVoy4wUX3dyaXRlX2ZpbGVfYm9tX3NhZmWUaLNo0ZOUjBpfY291bnRfbGluZXNfdG9fYmVfZGVsZXRlZJRos2jTk5SMGV9leHRyYWN0X2RlZmluaXRpb25fbmFtZXOUaLNo1ZOUjBVfY2hlY2tfZm9yX2R1cGxpY2F0ZXOUaLNo15OUjAtTY29wZVZpZXdlcpRos2jZk5SMEFNjb3BlVHJhbnNmb3JtZXKUaLNo25OUjBZHZW5lcmljUGF0dGVybkluc2VydGVylGizaN2TlIwLU2NvcGVGaW5kZXKUaLNo35OUjA1TY29wZVJlcGxhY2VylGizaOGTlIwLcHl0aG9uX3ZpZXeUaAIoaC99lGg3aExzaONOaACMDF9jcmVhdGVfY2VsbJSTlE6FlFKUhZR0lFKUfZQojAtfX3dyYXBwZWRfX5RoAihoBChDUAIWFgECASYBIgEuAQoBIgEy/gIDPgE+AS4BAgEWASABDP8CBAQBDgEYAQQBAgFQAxYBIgEYAS4BSgEOARgBBu8QAVj/CggQAVj/CgoQASj/lEsCSwBLAEsLSwtLA0J4BAAAlwB0AQAAAAAAAAAAfAGrAQAAAAAAAH0BCQB8AGoDAAAAAAAAAAAAAAAAAAAAAAAAZAGrAQAAAAAAAF4BfQJ9A3wCagUAAAAAAAAAAAAAAAAAAAAAAABkAqsBAAAAAAAAcxd0BwAAAAAAAAAAdAkAAAAAAAAAAGQDfAKbAJ0CqwEAAAAAAACrAQAAAAAAAFMAfANEAF0rAAB9BHwEagsAAAAAAAAAAAAAAAAAAAAAAACrAAAAAAAAAHIBjBR0BwAAAAAAAAAAdAkAAAAAAAAAAGQEfASbAJ0CqwEAAAAAAACrAQAAAAAAAGMCAQBTAAQAdAwAAAAAAAAAAGoOAAAAAAAAAAAAAAAAAAAAAAAAahEAAAAAAAAAAAAAAAAAAAAAAAB8AqsBAAAAAAAAfQV0DAAAAAAAAAAAag4AAAAAAAAAAAAAAAAAAAAAAABqEwAAAAAAAAAAAAAAAAAAAAAAAHwFqwEAAAAAAABzF3QHAAAAAAAAAAB0FQAAAAAAAAAAZAV8BZsAnQKrAQAAAAAAAKsBAAAAAAAAUwAJAHQXAAAAAAAAAAB8BasBAAAAAAAAfQZ8BmoZAAAAAAAAAAAAAAAAAAAAAAAAqwAAAAAAAABzBmQGfAWbAGQHnQNTAAkAfANzFXwBchF8AWQLa0QAAHIMdB8AAAAAAAAAAHwGfAGrAgAAAAAAAFMAfAZTAAkAdCAAAAAAAAAAAGojAAAAAAAAAAAAAAAAAAAAAAAAdCAAAAAAAAAAAGolAAAAAAAAAAAAAAAAAAAAAAAAfAarAQAAAAAAAKsBAAAAAAAAfQh0JwAAAAAAAAAAfAOrAQAAAAAAAH0JfAhqKQAAAAAAAAAAAAAAAAAAAAAAAHwJqwEAAAAAAAABAHwJaioAAAAAAAAAAAAAAAAAAAAAAABzF3QHAAAAAAAAAAB0CQAAAAAAAAAAZA18AJsAnQKrAQAAAAAAAKsBAAAAAAAAUwB8CGosAAAAAAAAAAAAAAAAAAAAAAAAai8AAAAAAAAAAAAAAAAAAAAAAAB8CWoqAAAAAAAAAAAAAAAAAAAAAAAAqwEAAAAAAAB9CnwBchF8AWQLa0QAAHIMdB8AAAAAAAAAAHwKfAGrAgAAAAAAAFMAfApTACMAdBoAAAAAAAAAACQAci19B3QHAAAAAAAAAAB0CQAAAAAAAAAAZAh8BZsAZAl0HQAAAAAAAAAAfAerAQAAAAAAAJsAnQSrAQAAAAAAAKsBAAAAAAAAYwJZAGQKfQd+B1MAZAp9B34HdwF3AHgDWQB3ASMAdBoAAAAAAAAAACQAci19B3QHAAAAAAAAAAB0CQAAAAAAAAAAZAx8BZsAZAl0HQAAAAAAAAAAfAerAQAAAAAAAJsAnQSrAQAAAAAAAKsBAAAAAAAAYwJZAGQKfQd+B1MAZAp9B34HdwF3AHgDWQB3ASMAdBoAAAAAAAAAACQAchV9B3QHAAAAAAAAAAB8B6sBAAAAAAAAYwJZAGQKfQd+B1MAZAp9B34HdwF3AHgDWQB3AZQoWH4CAAAKICAgIFZpZXcgUHl0aG9uIGNvZGUgdXNpbmcgcHl0ZXN0LXN0eWxlIHNjb3BlIHN5bnRheCB3aXRoIHNjb3BlLWF3YXJlIHRydW5jYXRpb24uCgogICAgUGFyYW1ldGVyczoKICAgIC0tLS0tLS0tLS0tCiAgICB0YXJnZXRfc2NvcGUgOiBzdHIKICAgICAgICBMb2NhdGlvbiB0byB2aWV3IGluIHB5dGVzdC1zdHlsZSBzY29wZSBzeW50YXg6CiAgICAgICAgLSAiZmlsZS5weSIgKHdob2xlIGZpbGUpCiAgICAgICAgLSAiZmlsZS5weTo6TXlDbGFzcyIgKGNsYXNzKQogICAgICAgIC0gImZpbGUucHk6Om15X2Z1bmN0aW9uIiAoZnVuY3Rpb24pCiAgICAgICAgLSAiZmlsZS5weTo6TXlDbGFzczo6bWV0aG9kIiAobWV0aG9kKQogICAgbWF4X2xpbmVzIDogaW50LCBvcHRpb25hbAogICAgICAgIE1heGltdW0gbnVtYmVyIG9mIGxpbmVzIGluIG91dHB1dC4gSWYgZXhjZWVkZWQsIGRlZXBlciBzY29wZXMgd2lsbCBiZQogICAgICAgIHByb2dyZXNzaXZlbHkgdHJ1bmNhdGVkIHRvIGNyZWF0ZSBhbiBvdXRsaW5lIHZpZXcuIERlZmF1bHQgNTAwLgoKICAgIFJldHVybnM6CiAgICAtLS0tLS0tLQogICAgc3RyCiAgICAgICAgVGhlIHNvdXJjZSBjb2RlIGF0IHRoZSBzcGVjaWZpZWQgc2NvcGUsIG9yIGVycm9yIG1lc3NhZ2UKICAgIJSMAjo6lIwDLnB5lIwdRmlsZSBwYXRoIG11c3QgZW5kIHdpdGggLnB5OiCUjBxJbnZhbGlkIGlkZW50aWZpZXIgaW4gcGF0aDoglIwQRmlsZSBub3QgZm91bmQ6IJSMBkZpbGUgJ5SMCycgaXMgZW1wdHkulIwTRXJyb3IgcmVhZGluZyBmaWxlIJSMAjoglE5LAIwTRXJyb3IgcGFyc2luZyBmaWxlIJSMGFRhcmdldCBzY29wZSBub3QgZm91bmQ6IJR0lCiMA2ludJSMBXNwbGl0lIwIZW5kc3dpdGiUaAyMClZhbHVlRXJyb3KUjAxpc2lkZW50aWZpZXKUaHKMBHBhdGiUjAdhYnNwYXRolIwGZXhpc3RzlIwRRmlsZU5vdEZvdW5kRXJyb3KUaLWMBXN0cmlwlGgbaBmMHV9hcHBseV9zY29wZV9hd2FyZV90cnVuY2F0aW9ulGiojA9NZXRhZGF0YVdyYXBwZXKUjAxwYXJzZV9tb2R1bGWUaN+MBXZpc2l0lIwLdGFyZ2V0X25vZGWUjAZtb2R1bGWUjA1jb2RlX2Zvcl9ub2RllHSUKIwMdGFyZ2V0X3Njb3BllIwJbWF4X2xpbmVzlGjBjA1wYXRoX2VsZW1lbnRzlIwHZWxlbWVudJSMCGFic19wYXRolIwLc291cmNlX2NvZGWUaCJoKIwGZmluZGVylIwLcmVzdWx0X2NvZGWUdJRoJ2jjaONLT0IjAgAAgAD0LAARFJBJkw6ASfACIQUh2CQw1yQ20SQ2sHTTJDzQCCGICZBN2A8Y1w8h0Q8hoCXUDyjcEyGkKtAvTMhZyEvQLVjTIlnTE1rQDFrbFySIR9gTGtcTJ9ETJ9UTKdwXJaRq0DNP0FBXyHnQMVnTJlrTF1vSEFvwBQAYJfQGABQWlzeRN5c/kT+gOdMTLYgI3A8Rj3eJd49+iX6YaNQPJ9wTIdQiM9A2RsB4wGrQNFHTIlLTE1PQDFPwAgUJWgHcGi2oaNMaN4hL2BMe1xMk0RMk1BMm2BkfoAiYeqgb0Bc10BA18AMAFCfxCAAQHdkPGJhZqBGaXdwXNLBbwCnTF0zQEEzYEx7QDB7wAgMJWgHcFhnXFinRFimsI9cqOtEqOrg70ypH0xZIiEf0BgASHZhd0xEriAbYCA+PDYkNkGbUCB3YDxXXDyHSDyHcEyGkKtAvR8gMwH7QLVbTIlfTE1jQDFjYFh2XbpFu1xYy0RYysDbXM0XRM0XTFkaIC9kLFJgZoFGaHdwTMLAbuGnTE0jQDEjYDxrQCBr49CMAEBnyAAEJWgHcEyGkKtAvQsA4wCrIQsxz0FNUy3bIaNAtV9MiWNMTWdUMWfvwAwEJWgH79BAAEBnyAAEJWgHcEyGkKtAvQsA4wCrIQsxz0FNUy3bIaNAtV9MiWNMTWdUMWfvwAwEJWgH79BQADBXyAAEFIdwPHZhh0w8g1Qgg+/ADAQUh+pRDoo06SBsAwQgVSBsAwR4YSBsAwTdBFUgbAMMOIEYpAMMvFUgbAMQFAUgbAMQIKEciAMQwPkgbAMUvN0gbAMYnAUgbAMYpCUcfA8YyIkcaA8cUAUcfA8cVBEgbAMcaBUcfA8cfA0gbAMciCUgYA8crIkgTA8gNAUgYA8gOBEgbAMgTBUgYA8gYA0gbAMgbCUg5A8gkCkg0A8guAUg5A8g0BUg5A5QpKXSUUpR9lGg3aExzaOOMAzUwMJSFlE50lFKUfZR9lChoNmjwaFJ9lChqDwEAAGhXahABAABoV2jPaFd1dYaUYowSX19tb2R1bGVfY29udGV4dF9flIwUYm90cy5mb3VuZGF0aW9uLmJhc2WUjA1Nb2R1bGVDb250ZXh0lJOUKYGUfZQojARuYW1llGhMjAZzb3VyY2WUWGcaAABkZWYgdG9vbGlmeShkZXNjcmlwdGlvbjogc3RyID0gTm9uZSk6CiAgICAiIiIKICAgIENvbnZlcnQgYW55IGZ1bmN0aW9uIGludG8gYSBib3QgdG9vbCB3aXRoIHN0cmluZy1pbiwgc3RyaW5nLW91dCBpbnRlcmZhY2UuCgogICAgLSBDb252ZXJ0cyBzdHJpbmcgaW5wdXRzIHRvIHByb3BlciB0eXBlcyB1c2luZyB0eXBlIGhpbnRzCiAgICAtIEVuc3VyZXMgc3RyaW5nIG91dHB1dCAoSlNPTiBmb3IgY29tcGxleCB0eXBlcykKICAgIC0gV3JhcHMgaW4gZXJyb3IgaGFuZGxpbmcgKHJldHVybnMgZXJyb3Igc3RyaW5ncywgbmV2ZXIgcmFpc2VzKQogICAgLSBFbmhhbmNlcyBkb2NzdHJpbmcgaWYgZGVzY3JpcHRpb24gcHJvdmlkZWQKCiAgICBBcmdzOgogICAgICAgIGRlc2NyaXB0aW9uIChzdHIsIG9wdGlvbmFsKTogT3ZlcnJpZGUgdGhlIGZ1bmN0aW9uJ3MgZG9jc3RyaW5nCgogICAgRXhhbXBsZToKICAgICAgICBAdG9vbGlmeSgpCiAgICAgICAgZGVmIGFkZF9udW1iZXJzKHg6IGludCwgeTogaW50ID0gMCkgLT4gaW50OgogICAgICAgICAgICByZXR1cm4geCArIHkKCiAgICAgICAgQHRvb2xpZnkoIkNhbGN1bGF0ZSB0aGUgYXJlYSBvZiBhIGNpcmNsZSIpCiAgICAgICAgZGVmIGFyZWEocmFkaXVzOiBmbG9hdCkgLT4gZmxvYXQ6CiAgICAgICAgICAgIHJldHVybiAzLjE0MTU5ICogcmFkaXVzICogcmFkaXVzCiAgICAiIiIKCiAgICBkZWYgZGVjb3JhdG9yKGZ1bmMpOgogICAgICAgIEBmdW5jdG9vbHMud3JhcHMoZnVuYykKICAgICAgICBkZWYgd3JhcHBlcigqYXJncywgKiprd2FyZ3MpOgogICAgICAgICAgICB0cnk6CiAgICAgICAgICAgICAgICAjIENvbnZlcnQgc3RyaW5nIGlucHV0cyB0byBwcm9wZXIgdHlwZXMgdXNpbmcgdHlwZSBoaW50cwogICAgICAgICAgICAgICAgY29udmVydGVkX2FyZ3MsIGNvbnZlcnRlZF9rd2FyZ3MgPSBfY29udmVydF90b29sX2lucHV0cyhmdW5jLCBhcmdzLCBrd2FyZ3MpCgogICAgICAgICAgICAgICAgIyBDYWxsIG9yaWdpbmFsIGZ1bmN0aW9uCiAgICAgICAgICAgICAgICByZXN1bHQgPSBmdW5jKCpjb252ZXJ0ZWRfYXJncywgKipjb252ZXJ0ZWRfa3dhcmdzKQoKICAgICAgICAgICAgICAgICMgQ29udmVydCByZXN1bHQgdG8gc3RyaW5nCiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnZlcnRfdG9vbF9vdXRwdXQocmVzdWx0KQoKICAgICAgICAgICAgZXhjZXB0IEtleWJvYXJkSW50ZXJydXB0IGFzIGU6CiAgICAgICAgICAgICAgICAjIENvbnZlcnQgS2V5Ym9hcmRJbnRlcnJ1cHQgdG8gVG9vbEV4ZWN1dGlvbkVycm9yIHRvIHByZXZlbnQgaXQgZnJvbQogICAgICAgICAgICAgICAgIyBidWJibGluZyB1cCB0byBDTEkgYW5kIGJlaW5nIHRyZWF0ZWQgYXMgdXNlciBDdHJsK0MKICAgICAgICAgICAgICAgIGZyb20gYm90cy51dGlscy5oZWxwZXJzIGltcG9ydCBfcHJvY2Vzc19lcnJvcgoKICAgICAgICAgICAgICAgIHRvb2xfZXJyb3IgPSBUb29sRXhlY3V0aW9uRXJyb3IoZiJUb29sIGV4ZWN1dGlvbiBpbnRlcnJ1cHRlZDoge3N0cihlKX0iKQogICAgICAgICAgICAgICAgcmV0dXJuIF9wcm9jZXNzX2Vycm9yKHRvb2xfZXJyb3IpCgogICAgICAgICAgICBleGNlcHQgVHlwZUVycm9yIGFzIGU6CiAgICAgICAgICAgICAgICAjIENoZWNrIGlmIHRoaXMgaXMgYSBtaXNzaW5nIHJlcXVpcmVkIGFyZ3VtZW50IGVycm9yCiAgICAgICAgICAgICAgICBlcnJvcl9tc2cgPSBzdHIoZSkKICAgICAgICAgICAgICAgIGlmICJtaXNzaW5nIiBpbiBlcnJvcl9tc2cgYW5kICJyZXF1aXJlZCIgaW4gZXJyb3JfbXNnIGFuZCAiYXJndW1lbnQiIGluIGVycm9yX21zZzoKICAgICAgICAgICAgICAgICAgICAjIEFkZCBzcGVjaWFsIG1lc3NhZ2UgZm9yIG91dHB1dCB0b2tlbiBsaW1pdGF0aW9uCiAgICAgICAgICAgICAgICAgICAgZW5oYW5jZWRfZXJyb3IgPSBUeXBlRXJyb3IoCiAgICAgICAgICAgICAgICAgICAgICAgIGYie2Vycm9yX21zZ31cblxuIgogICAgICAgICAgICAgICAgICAgICAgICBmIuKaoO+4jyAgVGhpcyBlcnJvciBpcyBjb21tb25seSBjYXVzZWQgYnkgaGl0dGluZyB0aGUgbWF4X3Rva2VucyBsaW1pdCBiZWZvcmUgY29tcGxldGluZyB0aGUgdG9vbCBjYWxsLlxuIgogICAgICAgICAgICAgICAgICAgICAgICBmIlRoZSByZXNwb25zZSB3YXMgdHJ1bmNhdGVkIG1pZC1wYXJhbWV0ZXIsIG1ha2luZyBpdCBhcHBlYXIgdGhhdCByZXF1aXJlZCBwYXJhbWV0ZXJzIGFyZSBtaXNzaW5nLlxuIgogICAgICAgICAgICAgICAgICAgICAgICBmIlRvIGZpeCB0aGlzOiBXb3JrIGluIFNNQUxMRVIgQ0hVTktTLiBFZGl0IGZld2VyIGxpbmVzIGF0IGEgdGltZSwgIgogICAgICAgICAgICAgICAgICAgICAgICBmIm9yIGJyZWFrIHlvdXIgdGFzayBpbnRvIG11bHRpcGxlIHN0ZXBzLiIKICAgICAgICAgICAgICAgICAgICApCiAgICAgICAgICAgICAgICAgICAgZnJvbSBib3RzLnV0aWxzLmhlbHBlcnMgaW1wb3J0IF9wcm9jZXNzX2Vycm9yCgogICAgICAgICAgICAgICAgICAgIHJldHVybiBfcHJvY2Vzc19lcnJvcihlbmhhbmNlZF9lcnJvcikKICAgICAgICAgICAgICAgIGVsc2U6CiAgICAgICAgICAgICAgICAgICAgZnJvbSBib3RzLnV0aWxzLmhlbHBlcnMgaW1wb3J0IF9wcm9jZXNzX2Vycm9yCgogICAgICAgICAgICAgICAgICAgIHJldHVybiBfcHJvY2Vzc19lcnJvcihlKQogICAgICAgICAgICBleGNlcHQgRXhjZXB0aW9uIGFzIGU6CiAgICAgICAgICAgICAgICBmcm9tIGJvdHMudXRpbHMuaGVscGVycyBpbXBvcnQgX3Byb2Nlc3NfZXJyb3IKCiAgICAgICAgICAgICAgICByZXR1cm4gX3Byb2Nlc3NfZXJyb3IoZSkKCiAgICAgICAgIyBVcGRhdGUgZG9jc3RyaW5nIGlmIGRlc2NyaXB0aW9uIHByb3ZpZGVkCiAgICAgICAgaWYgZGVzY3JpcHRpb246CiAgICAgICAgICAgIHdyYXBwZXIuX19kb2NfXyA9IGRlc2NyaXB0aW9uCiAgICAgICAgZWxpZiBub3Qgd3JhcHBlci5fX2RvY19fOgogICAgICAgICAgICAjIEdlbmVyYXRlIG1pbmltYWwgZG9jc3RyaW5nIGZyb20gZnVuY3Rpb24gbmFtZQogICAgICAgICAgICB3cmFwcGVyLl9fZG9jX18gPSBmIkV4ZWN1dGUge2Z1bmMuX19uYW1lX18ucmVwbGFjZSgnXycsICcgJyl9IgoKICAgICAgICByZXR1cm4gd3JhcHBlcgoKICAgIHJldHVybiBkZWNvcmF0b3IKCkB0b29saWZ5KCkKZGVmIHB5dGhvbl92aWV3KHRhcmdldF9zY29wZTogc3RyLCBtYXhfbGluZXM6IHN0cj0nNTAwJykgLT4gc3RyOgogICAgIiIiCiAgICBWaWV3IFB5dGhvbiBjb2RlIHVzaW5nIHB5dGVzdC1zdHlsZSBzY29wZSBzeW50YXggd2l0aCBzY29wZS1hd2FyZSB0cnVuY2F0aW9uLgoKICAgIFBhcmFtZXRlcnM6CiAgICAtLS0tLS0tLS0tLQogICAgdGFyZ2V0X3Njb3BlIDogc3RyCiAgICAgICAgTG9jYXRpb24gdG8gdmlldyBpbiBweXRlc3Qtc3R5bGUgc2NvcGUgc3ludGF4OgogICAgICAgIC0gImZpbGUucHkiICh3aG9sZSBmaWxlKQogICAgICAgIC0gImZpbGUucHk6Ok15Q2xhc3MiIChjbGFzcykKICAgICAgICAtICJmaWxlLnB5OjpteV9mdW5jdGlvbiIgKGZ1bmN0aW9uKQogICAgICAgIC0gImZpbGUucHk6Ok15Q2xhc3M6Om1ldGhvZCIgKG1ldGhvZCkKICAgIG1heF9saW5lcyA6IGludCwgb3B0aW9uYWwKICAgICAgICBNYXhpbXVtIG51bWJlciBvZiBsaW5lcyBpbiBvdXRwdXQuIElmIGV4Y2VlZGVkLCBkZWVwZXIgc2NvcGVzIHdpbGwgYmUKICAgICAgICBwcm9ncmVzc2l2ZWx5IHRydW5jYXRlZCB0byBjcmVhdGUgYW4gb3V0bGluZSB2aWV3LiBEZWZhdWx0IDUwMC4KCiAgICBSZXR1cm5zOgogICAgLS0tLS0tLS0KICAgIHN0cgogICAgICAgIFRoZSBzb3VyY2UgY29kZSBhdCB0aGUgc3BlY2lmaWVkIHNjb3BlLCBvciBlcnJvciBtZXNzYWdlCiAgICAiIiIKICAgIG1heF9saW5lcyA9IGludChtYXhfbGluZXMpCiAgICB0cnk6CiAgICAgICAgZmlsZV9wYXRoLCAqcGF0aF9lbGVtZW50cyA9IHRhcmdldF9zY29wZS5zcGxpdCgnOjonKQogICAgICAgIGlmIG5vdCBmaWxlX3BhdGguZW5kc3dpdGgoJy5weScpOgogICAgICAgICAgICByZXR1cm4gX3Byb2Nlc3NfZXJyb3IoVmFsdWVFcnJvcihmJ0ZpbGUgcGF0aCBtdXN0IGVuZCB3aXRoIC5weToge2ZpbGVfcGF0aH0nKSkKICAgICAgICBmb3IgZWxlbWVudCBpbiBwYXRoX2VsZW1lbnRzOgogICAgICAgICAgICBpZiBub3QgZWxlbWVudC5pc2lkZW50aWZpZXIoKToKICAgICAgICAgICAgICAgIHJldHVybiBfcHJvY2Vzc19lcnJvcihWYWx1ZUVycm9yKGYnSW52YWxpZCBpZGVudGlmaWVyIGluIHBhdGg6IHtlbGVtZW50fScpKQogICAgICAgIGFic19wYXRoID0gb3MucGF0aC5hYnNwYXRoKGZpbGVfcGF0aCkKICAgICAgICBpZiBub3Qgb3MucGF0aC5leGlzdHMoYWJzX3BhdGgpOgogICAgICAgICAgICByZXR1cm4gX3Byb2Nlc3NfZXJyb3IoRmlsZU5vdEZvdW5kRXJyb3IoZidGaWxlIG5vdCBmb3VuZDoge2Fic19wYXRofScpKQogICAgICAgIHRyeToKICAgICAgICAgICAgc291cmNlX2NvZGUgPSBfcmVhZF9maWxlX2JvbV9zYWZlKGFic19wYXRoKQogICAgICAgICAgICBpZiBub3Qgc291cmNlX2NvZGUuc3RyaXAoKToKICAgICAgICAgICAgICAgIHJldHVybiBmIkZpbGUgJ3thYnNfcGF0aH0nIGlzIGVtcHR5LiIKICAgICAgICBleGNlcHQgRXhjZXB0aW9uIGFzIGU6CiAgICAgICAgICAgIHJldHVybiBfcHJvY2Vzc19lcnJvcihWYWx1ZUVycm9yKGYnRXJyb3IgcmVhZGluZyBmaWxlIHthYnNfcGF0aH06IHtzdHIoZSl9JykpCiAgICAgICAgaWYgbm90IHBhdGhfZWxlbWVudHM6CiAgICAgICAgICAgIGlmIG1heF9saW5lcyBhbmQgbWF4X2xpbmVzID4gMDoKICAgICAgICAgICAgICAgIHJldHVybiBfYXBwbHlfc2NvcGVfYXdhcmVfdHJ1bmNhdGlvbihzb3VyY2VfY29kZSwgbWF4X2xpbmVzKQogICAgICAgICAgICByZXR1cm4gc291cmNlX2NvZGUKICAgICAgICB0cnk6CiAgICAgICAgICAgIHdyYXBwZXIgPSBjc3QuTWV0YWRhdGFXcmFwcGVyKGNzdC5wYXJzZV9tb2R1bGUoc291cmNlX2NvZGUpKQogICAgICAgIGV4Y2VwdCBFeGNlcHRpb24gYXMgZToKICAgICAgICAgICAgcmV0dXJuIF9wcm9jZXNzX2Vycm9yKFZhbHVlRXJyb3IoZidFcnJvciBwYXJzaW5nIGZpbGUge2Fic19wYXRofToge3N0cihlKX0nKSkKICAgICAgICBmaW5kZXIgPSBTY29wZUZpbmRlcihwYXRoX2VsZW1lbnRzKQogICAgICAgIHdyYXBwZXIudmlzaXQoZmluZGVyKQogICAgICAgIGlmIG5vdCBmaW5kZXIudGFyZ2V0X25vZGU6CiAgICAgICAgICAgIHJldHVybiBfcHJvY2Vzc19lcnJvcihWYWx1ZUVycm9yKGYnVGFyZ2V0IHNjb3BlIG5vdCBmb3VuZDoge3RhcmdldF9zY29wZX0nKSkKICAgICAgICByZXN1bHRfY29kZSA9IHdyYXBwZXIubW9kdWxlLmNvZGVfZm9yX25vZGUoZmluZGVyLnRhcmdldF9ub2RlKQogICAgICAgIGlmIG1heF9saW5lcyBhbmQgbWF4X2xpbmVzID4gMDoKICAgICAgICAgICAgcmV0dXJuIF9hcHBseV9zY29wZV9hd2FyZV90cnVuY2F0aW9uKHJlc3VsdF9jb2RlLCBtYXhfbGluZXMpCiAgICAgICAgcmV0dXJuIHJlc3VsdF9jb2RlCiAgICBleGNlcHQgRXhjZXB0aW9uIGFzIGU6CiAgICAgICAgcmV0dXJuIF9wcm9jZXNzX2Vycm9yKGUpCgpkZWYgX3JlYWRfZmlsZV9ib21fc2FmZShmaWxlX3BhdGg6IHN0cikgLT4gc3RyOgogICAgIiIiUmVhZCBhIGZpbGUgd2l0aCBCT00gcHJvdGVjdGlvbi4iIiIKICAgIHdpdGggb3BlbihmaWxlX3BhdGgsICdyJywgZW5jb2Rpbmc9J3V0Zi04JykgYXMgZmlsZToKICAgICAgICBjb250ZW50ID0gZmlsZS5yZWFkKCkKICAgIHJldHVybiBjbGVhbl91bmljb2RlX3N0cmluZyhjb250ZW50KQoKZGVmIF9hcHBseV9zY29wZV9hd2FyZV90cnVuY2F0aW9uKHNvdXJjZV9jb2RlOiBzdHIsIG1heF9saW5lczogaW50KSAtPiBzdHI6CiAgICAiIiJBcHBseSBzY29wZS1hd2FyZSB0cnVuY2F0aW9uIHRvIFB5dGhvbiBzb3VyY2UgY29kZS4iIiIKICAgIGlmIG5vdCBzb3VyY2VfY29kZS5zdHJpcCgpOgogICAgICAgIHJldHVybiBzb3VyY2VfY29kZQogICAgbGluZXMgPSBzb3VyY2VfY29kZS5zcGxpdGxpbmVzKCkKICAgIGlmIGxlbihsaW5lcykgPD0gbWF4X2xpbmVzOgogICAgICAgIHJldHVybiBzb3VyY2VfY29kZQogICAgaW1wb3J0IGFzdAogICAgdHJlZSA9IGFzdC5wYXJzZShzb3VyY2VfY29kZSkKICAgIHNjb3BlX2VudHJpZXMgPSBbXQogICAgX2NvbGxlY3Rfc2NvcGVfZW50cmllcyh0cmVlLCBzY29wZV9lbnRyaWVzLCAwKQogICAgbWF4X2RlcHRoID0gbWF4KChlbnRyeVsnZGVwdGgnXSBmb3IgZW50cnkgaW4gc2NvcGVfZW50cmllcyksIGRlZmF1bHQ9MCkKICAgIGZvciBjdXJyZW50X2RlcHRoX2xpbWl0IGluIHJhbmdlKG1heF9kZXB0aCwgLTEsIC0xKToKICAgICAgICByZXN1bHRfbGluZXMgPSBfY3JlYXRlX291dGxpbmVfdmlldyhzY29wZV9lbnRyaWVzLCBjdXJyZW50X2RlcHRoX2xpbWl0LCBsaW5lcykKICAgICAgICBpZiBsZW4ocmVzdWx0X2xpbmVzKSA8PSBtYXhfbGluZXM6CiAgICAgICAgICAgIHJldHVybiAnXG4nLmpvaW4ocmVzdWx0X2xpbmVzKQogICAgcmVzdWx0X2xpbmVzID0gX2NyZWF0ZV9vdXRsaW5lX3ZpZXcoc2NvcGVfZW50cmllcywgMCwgbGluZXMpCiAgICBpZiBsZW4ocmVzdWx0X2xpbmVzKSA+IG1heF9saW5lczoKICAgICAgICByZXN1bHRfbGluZXMgPSBfY3JlYXRlX3NpZ25hdHVyZV9vdXRsaW5lKHNjb3BlX2VudHJpZXMsIGxpbmVzLCBtYXhfbGluZXMpCiAgICByZXR1cm4gJ1xuJy5qb2luKHJlc3VsdF9saW5lcymUaMFoXYwJbmFtZXNwYWNllGhkjC9fX3J1bnRpbWVfXy5keW5hbWljX21vZHVsZV8tMTc1MzA1MzMzMDgwOTY2NjQ3OJSFlFKUfZQoaDdoTGg2TmhZTmhbTmhcaF1oFGhfaBVoYGgYaGFoYmhmaGdoaWg0aGtobGhuaG9ocWhyaHRodWh4aHloe2h8aH5oNWh/aIBogmiDaIRohWiGaIdoiGiJaIpoi2iPaJBokWiSaJNolGiVaJZol2iYaJlommibaJxonWieaJ9oRmhPaKBooWiiaKNopGilaKZop2ioaKtoDGisaK1ormivaLFosmi0aLVoy2jRaNJo02jUaNVo1mjXaNho2WjaaNto3GjdaN5o32jgaOFo4mjjaOuMC3B5dGhvbl9lZGl0lGizajMBAACTlIwaX2hhbmRsZV9maWxlX2VuZF9pbnNlcnRpb26UaLNqNQEAAJOUjBhfaGFuZGxlX2ZpcnN0X2RlZmluaXRpb26UaLNqNwEAAJOUjB5fY3JlYXRlX3N0YXRlbWVudF93aXRoX2NvbW1lbnSUaLNqOQEAAJOUagcBAABoAihoBChDJgICIAEEASABHAEEAQgBIgEEARoBKAEgARoB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AGo1AQAAajYBAABqNwEAAGo4AQAAajkBAABqOgEAAGoHAQAAamQBAABqVgEAAGprAQAAamwBAABqbQEAAGpRAQAAam4BAABqVAEAAGpvAQAAanABAABqcQEAAGpyAQAAanMBAABqdAEAAGp1AQAAanYBAABqdwEAAIwMX19idWlsdGluc19flGNidWlsdGlucwpfX2RpY3RfXwp1MGocAQAAKGg3aExoNk5oWU5oWk5oW05oXGhdaBRoX2gVaGBoGGhhaGJoZmhnaGloNGhraGxobmhvaHFocmh0aHVoeGh5aHtofGh+aDVof2iAaIJog2iEaIVohmiHaIhoiWiKaItoj2iQaJFokmiTaJRolWiWaJdomGiZaJpom2icaJ1onmifaEZoT2igaKFoomijaKRopWimaKdoqGiraAxorGitaK5or2ixaLJotGi1aMto0WjSaNNo1GjVaNZo12jYaNlo2mjbaNxo3WjeaN9o4GjhaOJo42jrajMBAABqNAEAAGo1AQAAajYBAABqNwEAAGo4AQAAajkBAABqOgEAAGoHAQAAamQBAABqVgEAAGprAQAAamwBAABqbQEAAGpRAQAAam4BAABqVAEAAGpvAQAAanABAABqcQEAAGpyAQAAanMBAABqdAEAAGp1AQAAanYBAABqdwEAAGp8AQAAY2J1aWx0aW5zCl9fZGljdF9fCnUwjAhidWlsdGluc5SMB2dldGF0dHKUk5SMBGRpbGyUjAVfZGlsbJSTlIwIX3NldGF0dHKUan0BAACMB3NldGF0dHKUk5SHlFKUaOiMDWNlbGxfY29udGVudHOUaiABAACHlFIwaOQoaDdoTGg2TmhZTmhaTmhbTmhcaF1oFGhfaBVoYGgYaGFoYmhmaGdoaWg0aGtobGhuaG9ocWhyaHRodWh4aHloe2h8aH5oNWh/aIBogmiDaIRohWiGaIdoiGiJaIpoi2iPaJBokWiSaJNolGiVaJZol2iYaJlommibaJxonWieaJ9oRmhPaKBooWiiaKNopGilaKZop2ioaKtoDGisaK1ormivaLFosmi0aLVoy2jRaNJo02jUaNVo1mjXaNho2WjaaNto3GjdaN5o32jgaOFo4mjjaOtqMwEAAGo0AQAAajUBAABqNgEAAGo3AQAAajgBAABqOQEAAGo6AQAAagcBAABqZAEAAGpWAQAAamsBAABqbAEAAGptAQAAalEBAABqbgEAAGpUAQAAam8BAABqcAEAAGpxAQAAanIBAABqcwEAAGp0AQAAanUBAABqdgEAAGp3AQAAanwBAABjYnVpbHRpbnMKX19kaWN0X18KdTBqMwEAAGo0AQAAajUBAABqNgEAAGo3AQAAajgBAABqOQEAAGo6AQAAagcBAABqZAEAAGpWAQAAamsBAABqbAEAAGptAQAAalEBAABqbgEAAGpUAQAAam8BAABqcAEAAGpxAQAAanIBAABqcwEAAGp0AQAAanUBAABqdgEAAGp3AQAAanwBAABjYnVpbHRpbnMKX19kaWN0X18KdTBo0WjSaNNo1GjVaNZo12jYaNlo2mjbaNxo3WjeaN9o4GjhaOJo42jrajMBAABqNAEAAGo1AQAAajYBAABqNwEAAGo4AQAAajkBAABqOgEAAGoHAQAAamQBAABqVgEAAGprAQAAamwBAABqbQEAAGpRAQAAam4BAABqVAEAAGpvAQAAanABAABqcQEAAGpyAQAAanMBAABqdAEAAGp1AQAAanYBAABqdwEAAGp8AQAAY2J1aWx0aW5zCl9fZGljdF9fCnUwLg==",
      "name": "toolify",
      "hash": "6a0866c88953588934f163d10f843da7a408377fb2783d469fb968f467d8d71e",
      "provenance": {
       "module": "dynamic_module_-1753053330809666478",
       "qualname": "toolify"
      }
     },
     "_convert_string_to_type": {
      "__helper_func__": true,
      "pickled": "gASVMwAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjBdfY29udmVydF9zdHJpbmdfdG9fdHlwZZSTlC4=",
      "name": "_convert_string_to_type",
      "hash": "024e40c56cb46e6fe9f52fe7e6e64a3effc17736268ef31195596c6a6be4c311",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "_convert_string_to_type"
      }
     },
     "_log_error_to_file": {
      "__helper_func__": true,
      "pickled": "gASVLgAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjBJfbG9nX2Vycm9yX3RvX2ZpbGWUk5Qu",
      "name": "_log_error_to_file",
      "hash": "c02546b672eb25afd5dc51ea7e1967cbb6fd264ca18ffd15c3cbeccebe4046ba",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "_log_error_to_file"
      }
     },
     "List": {
      "__imported_callable__": true,
      "pickled": "gASVEwAAAAAAAACMBnR5cGluZ5SMBExpc3SUk5Qu",
      "name": "List",
      "hash": "4177cb372f5ac2e670cf003d399db45b34278d8cf8801c6f8c592fc37176022f",
      "provenance": {
       "module": "typing",
       "qualname": "List"
      }
     },
     "Union": {
      "__imported_callable__": true,
      "pickled": "gASVFAAAAAAAAACMBnR5cGluZ5SMBVVuaW9ulJOULg==",
      "name": "Union",
      "hash": "ccd01a358f6c99cc4b7ab96256fb9d3cbc7009bdba98038d635fefdafc9a35de",
      "provenance": {
       "module": "typing",
       "qualname": "Union"
      }
     },
     "cst": {
      "__module_type__": true,
      "name": "libcst",
      "spec": "libcst"
     },
     "_process_error": {
      "__helper_func__": true,
      "pickled": "gASVKQAAAAAAAACMEmJvdHMudXRpbHMuaGVscGVyc5SMDl9wcm9jZXNzX2Vycm9ylJOULg==",
      "name": "_process_error",
      "hash": "10b62012f4c2cf25d619b19f083513ff485e28e6f2f1ab3dc952bc85a0fd31e1",
      "provenance": {
       "module": "bots.utils.helpers",
       "qualname": "_process_error"
      }
     },
     "_py_ast_to_source": {
      "__helper_func__": true,
      "pickled": "gASVLAAAAAAAAACMEmJvdHMudXRpbHMuaGVscGVyc5SMEV9weV9hc3RfdG9fc291cmNllJOULg==",
      "name": "_py_ast_to_source",
      "hash": "b4f03eb89ec6290dae99f96b4cbde39a5df78f3a58db9ae249d5cfe9d8d740c2",
      "provenance": {
       "module": "bots.utils.helpers",
       "qualname": "_py_ast_to_source"
      }
     },
     "clean_unicode_string": {
      "__imported_callable__": true,
      "pickled": "gASVNQAAAAAAAACMGGJvdHMudXRpbHMudW5pY29kZV91dGlsc5SMFGNsZWFuX3VuaWNvZGVfc3RyaW5nlJOULg==",
      "name": "clean_unicode_string",
      "hash": "2316910285c0cef615cfa77d71869e6841488cbe386a2ae90e4f7ebf187fec5e",
      "provenance": {
       "module": "bots.utils.unicode_utils",
       "qualname": "clean_unicode_string"
      }
     },
     "_make_file": {
      "__helper_func__": true,
      "pickled": "gASVKQAAAAAAAACMFmJvdHMudG9vbHMucHl0aG9uX2VkaXSUjApfbWFrZV9maWxllJOULg==",
      "name": "_make_file",
      "hash": "4980caafce08b29c235335a73acfa5d6826a8479ca8f293a6519d1f21ce13cf8",
      "provenance": {
       "module": "bots.tools.python_edit",
       "qualname": "_make_file"
      }
     },
     "_write_file_bom_safe": {
      "__helper_func__": true,
      "pickled": "gASVMwAAAAAAAACMFmJvdHMudG9vbHMucHl0aG9uX2VkaXSUjBRfd3JpdGVfZmlsZV9ib21fc2FmZZSTlC4=",
      "name": "_write_file_bom_safe",
      "hash": "5917e1b6a95df9681a769445021484cddae2e6aa77eef62fe7bfec50a1ce1cec",
      "provenance": {
       "module": "bots.tools.python_edit",
       "qualname": "_write_file_bom_safe"
      }
     },
     "_count_lines_to_be_deleted": {
      "__helper_func__": true,
      "pickled": "gASVOQAAAAAAAACMFmJvdHMudG9vbHMucHl0aG9uX2VkaXSUjBpfY291bnRfbGluZXNfdG9fYmVfZGVsZXRlZJSTlC4=",
      "name": "_count_lines_to_be_deleted",
      "hash": "0e61183048d2900e37838cae2cb6a49acb2897375fe96b424b1ba5288d2add7e",
      "provenance": {
       "module": "bots.tools.python_edit",
       "qualname": "_count_lines_to_be_deleted"
      }
     },
     "_extract_definition_names": {
      "__helper_func__": true,
      "pickled": "gASVOAAAAAAAAACMFmJvdHMudG9vbHMucHl0aG9uX2VkaXSUjBlfZXh0cmFjdF9kZWZpbml0aW9uX25hbWVzlJOULg==",
      "name": "_extract_definition_names",
      "hash": "3e6928e16414aa2b20618845a01305f68940077be884b9fe697272f44b8e78d3",
      "provenance": {
       "module": "bots.tools.python_edit",
       "qualname": "_extract_definition_names"
      }
     },
     "_check_for_duplicates": {
      "__helper_func__": true,
      "pickled": "gASVNAAAAAAAAACMFmJvdHMudG9vbHMucHl0aG9uX2VkaXSUjBVfY2hlY2tfZm9yX2R1cGxpY2F0ZXOUk5Qu",
      "name": "_check_for_duplicates",
      "hash": "68cdf2e0f8012a144cea3d64e61e657b9d1af3f3fc062cdb89cac884d0f3e385",
      "provenance": {
       "module": "bots.tools.python_edit",
       "qualname": "_check_for_duplicates"
      }
     },
     "ScopeViewer": {
      "__imported_callable__": true,
      "pickled": "gASVKgAAAAAAAACMFmJvdHMudG9vbHMucHl0aG9uX2VkaXSUjAtTY29wZVZpZXdlcpSTlC4=",
      "name": "ScopeViewer",
      "hash": "f52828d119c9f54d5da9219e39db4ad455b2c64d0f33c7377bae10512ff1130b",
      "provenance": {
       "module": "bots.tools.python_edit",
       "qualname": "ScopeViewer"
      }
     },
     "ScopeTransformer": {
      "__imported_callable__": true,
      "pickled": "gASVLwAAAAAAAACMFmJvdHMudG9vbHMucHl0aG9uX2VkaXSUjBBTY29wZVRyYW5zZm9ybWVylJOULg==",
      "name": "ScopeTransformer",
      "hash": "602d38226569839bd40707cf7bf99b94c3eab4f4f627db8a40e0d812f223a2a7",
      "provenance": {
       "module": "bots.tools.python_edit",
       "qualname": "ScopeTransformer"
      }
     },
     "GenericPatternInserter": {
      "__imported_callable__": true,
      "pickled": "gASVNQAAAAAAAACMFmJvdHMudG9vbHMucHl0aG9uX2VkaXSUjBZHZW5lcmljUGF0dGVybkluc2VydGVylJOULg==",
      "name": "GenericPatternInserter",
      "hash": "4356addd47489a79b14898f6da1bcbd4e95ab399e78db6874bff0aaa5aeabf42",
      "provenance": {
       "module": "bots.tools.python_edit",
       "qualname": "GenericPatternInserter"
      }
     },
     "ScopeFinder": {
      "__imported_callable__": true,
      "pickled": "gASVKgAAAAAAAACMFmJvdHMudG9vbHMucHl0aG9uX2VkaXSUjAtTY29wZUZpbmRlcpSTlC4=",
      "name": "ScopeFinder",
      "hash": "73232579c4cfb7ca73e4f0d56ef147b8e42210e93bff62d027f0daf399b217b0",
      "provenance": {
       "module": "bots.tools.python_edit",
       "qualname": "ScopeFinder"
      }
     },
     "ScopeReplacer": {
      "__imported_callable__": true,
      "pickled": "gASVLAAAAAAAAACMFmJvdHMudG9vbHMucHl0aG9uX2VkaXSUjA1TY29wZVJlcGxhY2VylJOULg==",
      "name": "ScopeReplacer",
      "hash": "52e7c4bec232dbfd0d363dc50069e73b709990041b0b09e5881a30f75083e012",
      "provenance": {
       "module": "bots.tools.python_edit",
       "qualname": "ScopeReplacer"
      }
     },
     "python_view": {
      "__imported_callable__": true,
      "pickled": "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biBlcnJvciBoYW5kbGluZyAocmV0dXJucyBlcnJvciBzdHJpbmdzLCBuZXZlciByYWlzZXMpCiAgICAtIEVuaGFuY2VzIGRvY3N0cmluZyBpZiBkZXNjcmlwdGlvbiBwcm92aWRlZAoKICAgIEFyZ3M6CiAgICAgICAgZGVzY3JpcHRpb24gKHN0ciwgb3B0aW9uYWwpOiBPdmVycmlkZSB0aGUgZnVuY3Rpb24ncyBkb2NzdHJpbmcKCiAgICBFeGFtcGxlOgogICAgICAgIEB0b29saWZ5KCkKICAgICAgICBkZWYgYWRkX251bWJlcnMoeDogaW50LCB5OiBpbnQgPSAwKSAtPiBpbnQ6CiAgICAgICAgICAgIHJldHVybiB4ICsgeQoKICAgICAgICBAdG9vbGlmeSgiQ2FsY3VsYXRlIHRoZSBhcmVhIG9mIGEgY2lyY2xlIikKICAgICAgICBkZWYgYXJlYShyYWRpdXM6IGZsb2F0KSAtPiBmbG9hdDoKICAgICAgICAgICAgcmV0dXJuIDMuMTQxNTkgKiByYWRpdXMgKiByYWRpdXMKICAgICIiIgoKICAgIGRlZiBkZWNvcmF0b3IoZnVuYyk6CiAgICAgICAgQGZ1bmN0b29scy53cmFwcyhmdW5jKQogICAgICAgIGRlZiB3cmFwcGVyKCphcmdzLCAqKmt3YXJncyk6CiAgICAgICAgICAgIHRyeToKICAgICAgICAgICAgICAgICMgQ29udmVydCBzdHJpbmcgaW5wdXRzIHRvIHByb3BlciB0eXBlcyB1c2luZyB0eXBlIGhpbnRzCiAgICAgICAgICAgICAgICBjb252ZXJ0ZWRfYXJncywgY29udmVydGVkX2t3YXJncyA9IF9jb252ZXJ0X3Rvb2xfaW5wdXRzKGZ1bmMsIGFyZ3MsIGt3YXJncykKCiAgICAgICAgICAgICAgICAjIENhbGwgb3JpZ2luYWwgZnVuY3Rpb24KICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmMoKmNvbnZlcnRlZF9hcmdzLCAqKmNvbnZlcnRlZF9rd2FyZ3MpCgogICAgICAgICAgICAgICAgIyBDb252ZXJ0IHJlc3VsdCB0byBzdHJpbmcKICAgICAgICAgICAgICAgIHJldHVybiBfY29udmVydF90b29sX291dHB1dChyZXN1bHQpCgogICAgICAgICAgICBleGNlcHQgS2V5Ym9hcmRJbnRlcnJ1cHQgYXMgZToKICAgICAgICAgICAgICAgICMgQ29udmVydCBLZXlib2FyZEludGVycnVwdCB0byBUb29sRXhlY3V0aW9uRXJyb3IgdG8gcHJldmVudCBpdCBmcm9tCiAgICAgICAgICAgICAgICAjIGJ1YmJsaW5nIHVwIHRvIENMSSBhbmQgYmVpbmcgdHJlYXRlZCBhcyB1c2VyIEN0cmwrQwogICAgICAgICAgICAgICAgZnJvbSBib3RzLnV0aWxzLmhlbHBlcnMgaW1wb3J0IF9wcm9jZXNzX2Vycm9yCgogICAgICAgICAgICAgICAgdG9vbF9lcnJvciA9IFRvb2xFeGVjdXRpb25FcnJvcihmIlRvb2wgZXhlY3V0aW9uIGludGVycnVwdGVkOiB7c3RyKGUpfSIpCiAgICAgICAgICAgICAgICByZXR1cm4gX3Byb2Nlc3NfZXJyb3IodG9vbF9lcnJvcikKCiAgICAgICAgICAgIGV4Y2VwdCBUeXBlRXJyb3IgYXMgZToKICAgICAgICAgICAgICAgICMgQ2hlY2sgaWYgdGhpcyBpcyBhIG1pc3NpbmcgcmVxdWlyZWQgYXJndW1lbnQgZXJyb3IKICAgICAgICAgICAgICAgIGVycm9yX21zZyA9IHN0cihlKQogICAgICAgICAgICAgICAgaWYgIm1pc3NpbmciIGluIGVycm9yX21zZyBhbmQgInJlcXVpcmVkIiBpbiBlcnJvcl9tc2cgYW5kICJhcmd1bWVudCIgaW4gZXJyb3JfbXNnOgogICAgICAgICAgICAgICAgICAgICMgQWRkIHNwZWNpYWwgbWVzc2FnZSBmb3Igb3V0cHV0IHRva2VuIGxpbWl0YXRpb24KICAgICAgICAgICAgICAgICAgICBlbmhhbmNlZF9lcnJvciA9IFR5cGVFcnJvcigKICAgICAgICAgICAgICAgICAgICAgICAgZiJ7ZXJyb3JfbXNnfVxuXG4iCiAgICAgICAgICAgICAgICAgICAgICAgIGYi4pqg77iPICBUaGlzIGVycm9yIGlzIGNvbW1vbmx5IGNhdXNlZCBieSBoaXR0aW5nIHRoZSBtYXhfdG9rZW5zIGxpbWl0IGJlZm9yZSBjb21wbGV0aW5nIHRoZSB0b29sIGNhbGwuXG4iCiAgICAgICAgICAgICAgICAgICAgICAgIGYiVGhlIHJlc3BvbnNlIHdhcyB0cnVuY2F0ZWQgbWlkLXBhcmFtZXRlciwgbWFraW5nIGl0IGFwcGVhciB0aGF0IHJlcXVpcmVkIHBhcmFtZXRlcnMgYXJlIG1pc3NpbmcuXG4iCiAgICAgICAgICAgICAgICAgICAgICAgIGYiVG8gZml4IHRoaXM6IFdvcmsgaW4gU01BTExFUiBDSFVOS1MuIEVkaXQgZmV3ZXIgbGluZXMgYXQgYSB0aW1lLCAiCiAgICAgICAgICAgICAgICAgICAgICAgIGYib3IgYnJlYWsgeW91ciB0YXNrIGludG8gbXVsdGlwbGUgc3RlcHMuIgogICAgICAgICAgICAgICAgICAgICkKICAgICAgICAgICAgICAgICAgICBmcm9tIGJvdHMudXRpbHMuaGVscGVycyBpbXBvcnQgX3Byb2Nlc3NfZXJyb3IKCiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9wcm9jZXNzX2Vycm9yKGVuaGFuY2VkX2Vycm9yKQogICAgICAgICAgICAgICAgZWxzZToKICAgICAgICAgICAgICAgICAgICBmcm9tIGJvdHMudXRpbHMuaGVscGVycyBpbXBvcnQgX3Byb2Nlc3NfZXJyb3IKCiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9wcm9jZXNzX2Vycm9yKGUpCiAgICAgICAgICAgIGV4Y2VwdCBFeGNlcHRpb24gYXMgZToKICAgICAgICAgICAgICAgIGZyb20gYm90cy51dGlscy5oZWxwZXJzIGltcG9ydCBfcHJvY2Vzc19lcnJvcgoKICAgICAgICAgICAgICAgIHJldHVybiBfcHJvY2Vzc19lcnJvcihlKQoKICAgICAgICAjIFVwZGF0ZSBkb2NzdHJpbmcgaWYgZGVzY3JpcHRpb24gcHJvdmlkZWQKICAgICAgICBpZiBkZXNjcmlwdGlvbjoKICAgICAgICAgICAgd3JhcHBlci5fX2RvY19fID0gZGVzY3JpcHRpb24KICAgICAgICBlbGlmIG5vdCB3cmFwcGVyLl9fZG9jX186CiAgICAgICAgICAgICMgR2VuZXJhdGUgbWluaW1hbCBkb2NzdHJpbmcgZnJvbSBmdW5jdGlvbiBuYW1lCiAgICAgICAgICAgIHdyYXBwZXIuX19kb2NfXyA9IGYiRXhlY3V0ZSB7ZnVuYy5fX25hbWVfXy5yZXBsYWNlKCdfJywgJyAnKX0iCgogICAgICAgIHJldHVybiB3cmFwcGVyCgogICAgcmV0dXJuIGRlY29yYXRvcgoKQHRvb2xpZnkoKQpkZWYgcHl0aG9uX3ZpZXcodGFyZ2V0X3Njb3BlOiBzdHIsIG1heF9saW5lczogc3RyPSc1MDAnKSAtPiBzdHI6CiAgICAiIiIKICAgIFZpZXcgUHl0aG9uIGNvZGUgdXNpbmcgcHl0ZXN0LXN0eWxlIHNjb3BlIHN5bnRheCB3aXRoIHNjb3BlLWF3YXJlIHRydW5jYXRpb24uCgogICAgUGFyYW1ldGVyczoKICAgIC0tLS0tLS0tLS0tCiAgICB0YXJnZXRfc2NvcGUgOiBzdHIKICAgICAgICBMb2NhdGlvbiB0byB2aWV3IGluIHB5dGVzdC1zdHlsZSBzY29wZSBzeW50YXg6CiAgICAgICAgLSAiZmlsZS5weSIgKHdob2xlIGZpbGUpCiAgICAgICAgLSAiZmlsZS5weTo6TXlDbGFzcyIgKGNsYXNzKQogICAgICAgIC0gImZpbGUucHk6Om15X2Z1bmN0aW9uIiAoZnVuY3Rpb24pCiAgICAgICAgLSAiZmlsZS5weTo6TXlDbGFzczo6bWV0aG9kIiAobWV0aG9kKQogICAgbWF4X2xpbmVzIDogaW50LCBvcHRpb25hbAogICAgICAgIE1heGltdW0gbnVtYmVyIG9mIGxpbmVzIGluIG91dHB1dC4gSWYgZXhjZWVkZWQsIGRlZXBlciBzY29wZXMgd2lsbCBiZQogICAgICAgIHByb2dyZXNzaXZlbHkgdHJ1bmNhdGVkIHRvIGNyZWF0ZSBhbiBvdXRsaW5lIHZpZXcuIERlZmF1bHQgNTAwLgoKICAgIFJldHVybnM6CiAgICAtLS0tLS0tLQogICAgc3RyCiAgICAgICAgVGhlIHNvdXJjZSBjb2RlIGF0IHRoZSBzcGVjaWZpZWQgc2NvcGUsIG9yIGVycm9yIG1lc3NhZ2UKICAgICIiIgogICAgbWF4X2xpbmVzID0gaW50KG1heF9saW5lcykKICAgIHRyeToKICAgICAgICBmaWxlX3BhdGgsICpwYXRoX2VsZW1lbnRzID0gdGFyZ2V0X3Njb3BlLnNwbGl0KCc6OicpCiAgICAgICAgaWYgbm90IGZpbGVfcGF0aC5lbmRzd2l0aCgnLnB5Jyk6CiAgICAgICAgICAgIHJldHVybiBfcHJvY2Vzc19lcnJvcihWYWx1ZUVycm9yKGYnRmlsZSBwYXRoIG11c3QgZW5kIHdpdGggLnB5OiB7ZmlsZV9wYXRofScpKQogICAgICAgIGZvciBlbGVtZW50IGluIHBhdGhfZWxlbWVudHM6CiAgICAgICAgICAgIGlmIG5vdCBlbGVtZW50LmlzaWRlbnRpZmllcigpOgogICAgICAgICAgICAgICAgcmV0dXJuIF9wcm9jZXNzX2Vycm9yKFZhbHVlRXJyb3IoZidJbnZhbGlkIGlkZW50aWZpZXIgaW4gcGF0aDoge2VsZW1lbnR9JykpCiAgICAgICAgYWJzX3BhdGggPSBvcy5wYXRoLmFic3BhdGgoZmlsZV9wYXRoKQogICAgICAgIGlmIG5vdCBvcy5wYXRoLmV4aXN0cyhhYnNfcGF0aCk6CiAgICAgICAgICAgIHJldHVybiBfcHJvY2Vzc19lcnJvcihGaWxlTm90Rm91bmRFcnJvcihmJ0ZpbGUgbm90IGZvdW5kOiB7YWJzX3BhdGh9JykpCiAgICAgICAgdHJ5OgogICAgICAgICAgICBzb3VyY2VfY29kZSA9IF9yZWFkX2ZpbGVfYm9tX3NhZmUoYWJzX3BhdGgpCiAgICAgICAgICAgIGlmIG5vdCBzb3VyY2VfY29kZS5zdHJpcCgpOgogICAgICAgICAgICAgICAgcmV0dXJuIGYiRmlsZSAne2Fic19wYXRofScgaXMgZW1wdHkuIgogICAgICAgIGV4Y2VwdCBFeGNlcHRpb24gYXMgZToKICAgICAgICAgICAgcmV0dXJuIF9wcm9jZXNzX2Vycm9yKFZhbHVlRXJyb3IoZidFcnJvciByZWFkaW5nIGZpbGUge2Fic19wYXRofToge3N0cihlKX0nKSkKICAgICAgICBpZiBub3QgcGF0aF9lbGVtZW50czoKICAgICAgICAgICAgaWYgbWF4X2xpbmVzIGFuZCBtYXhfbGluZXMgPiAwOgogICAgICAgICAgICAgICAgcmV0dXJuIF9hcHBseV9zY29wZV9hd2FyZV90cnVuY2F0aW9uKHNvdXJjZV9jb2RlLCBtYXhfbGluZXMpCiAgICAgICAgICAgIHJldHVybiBzb3VyY2VfY29kZQogICAgICAgIHRyeToKICAgICAgICAgICAgd3JhcHBlciA9IGNzdC5NZXRhZGF0YVdyYXBwZXIoY3N0LnBhcnNlX21vZHVsZShzb3VyY2VfY29kZSkpCiAgICAgICAgZXhjZXB0IEV4Y2VwdGlvbiBhcyBlOgogICAgICAgICAgICByZXR1cm4gX3Byb2Nlc3NfZXJyb3IoVmFsdWVFcnJvcihmJ0Vycm9yIHBhcnNpbmcgZmlsZSB7YWJzX3BhdGh9OiB7c3RyKGUpfScpKQogICAgICAgIGZpbmRlciA9IFNjb3BlRmluZGVyKHBhdGhfZWxlbWVudHMpCiAgICAgICAgd3JhcHBlci52aXNpdChmaW5kZXIpCiAgICAgICAgaWYgbm90IGZpbmRlci50YXJnZXRfbm9kZToKICAgICAgICAgICAgcmV0dXJuIF9wcm9jZXNzX2Vycm9yKFZhbHVlRXJyb3IoZidUYXJnZXQgc2NvcGUgbm90IGZvdW5kOiB7dGFyZ2V0X3Njb3BlfScpKQogICAgICAgIHJlc3VsdF9jb2RlID0gd3JhcHBlci5tb2R1bGUuY29kZV9mb3Jfbm9kZShmaW5kZXIudGFyZ2V0X25vZGUpCiAgICAgICAgaWYgbWF4X2xpbmVzIGFuZCBtYXhfbGluZXMgPiAwOgogICAgICAgICAgICByZXR1cm4gX2FwcGx5X3Njb3BlX2F3YXJlX3RydW5jYXRpb24ocmVzdWx0X2NvZGUsIG1heF9saW5lcykKICAgICAgICByZXR1cm4gcmVzdWx0X2NvZGUKICAgIGV4Y2VwdCBFeGNlcHRpb24gYXMgZToKICAgICAgICByZXR1cm4gX3Byb2Nlc3NfZXJyb3IoZSkKCmRlZiBfcmVhZF9maWxlX2JvbV9zYWZlKGZpbGVfcGF0aDogc3RyKSAtPiBzdHI6CiAgICAiIiJSZWFkIGEgZmlsZSB3aXRoIEJPTSBwcm90ZWN0aW9uLiIiIgogICAgd2l0aCBvcGVuKGZpbGVfcGF0aCwgJ3InLCBlbmNvZGluZz0ndXRmLTgnKSBhcyBmaWxlOgogICAgICAgIGNvbnRlbnQgPSBmaWxlLnJlYWQoKQogICAgcmV0dXJuIGNsZWFuX3VuaWNvZGVfc3RyaW5nKGNvbnRlbnQpCgpkZWYgX2FwcGx5X3Njb3BlX2F3YXJlX3RydW5jYXRpb24oc291cmNlX2NvZGU6IHN0ciwgbWF4X2xpbmVzOiBpbnQpIC0+IHN0cjoKICAgICIiIkFwcGx5IHNjb3BlLWF3YXJlIHRydW5jYXRpb24gdG8gUHl0aG9uIHNvdXJjZSBjb2RlLiIiIgogICAgaWYgbm90IHNvdXJjZV9jb2RlLnN0cmlwKCk6CiAgICAgICAgcmV0dXJuIHNvdXJjZV9jb2RlCiAgICBsaW5lcyA9IHNvdXJjZV9jb2RlLnNwbGl0bGluZXMoKQogICAgaWYgbGVuKGxpbmVzKSA8PSBtYXhfbGluZXM6CiAgICAgICAgcmV0dXJuIHNvdXJjZV9jb2RlCiAgICBpbXBvcnQgYXN0CiAgICB0cmVlID0gYXN0LnBhcnNlKHNvdXJjZV9jb2RlKQogICAgc2NvcGVfZW50cmllcyA9IFtdCiAgICBfY29sbGVjdF9zY29wZV9lbnRyaWVzKHRyZWUsIHNjb3BlX2VudHJpZXMsIDApCiAgICBtYXhfZGVwdGggPSBtYXgoKGVudHJ5WydkZXB0aCddIGZvciBlbnRyeSBpbiBzY29wZV9lbnRyaWVzKSwgZGVmYXVsdD0wKQogICAgZm9yIGN1cnJlbnRfZGVwdGhfbGltaXQgaW4gcmFuZ2UobWF4X2RlcHRoLCAtMSwgLTEpOgogICAgICAgIHJlc3VsdF9saW5lcyA9IF9jcmVhdGVfb3V0bGluZV92aWV3KHNjb3BlX2VudHJpZXMsIGN1cnJlbnRfZGVwdGhfbGltaXQsIGxpbmVzKQogICAgICAgIGlmIGxlbihyZXN1bHRfbGluZXMpIDw9IG1heF9saW5lczoKICAgICAgICAgICAgcmV0dXJuICdcbicuam9pbihyZXN1bHRfbGluZXMpCiAgICByZXN1bHRfbGluZXMgPSBfY3JlYXRlX291dGxpbmVfdmlldyhzY29wZV9lbnRyaWVzLCAwLCBsaW5lcykKICAgIGlmIGxlbihyZXN1bHRfbGluZXMpID4gbWF4X2xpbmVzOgogICAgICAgIHJlc3VsdF9saW5lcyA9IF9jcmVhdGVfc2lnbmF0dXJlX291dGxpbmUoc2NvcGVfZW50cmllcywgbGluZXMsIG1heF9saW5lcykKICAgIHJldHVybiAnXG4nLmpvaW4ocmVzdWx0X2xpbmVzKZRoX4wjZHluYW1pY19tb2R1bGVfLTMyMTc0Mjc5NDYwMjc1ODU0NDSUjAluYW1lc3BhY2WUaACMDl9pbXBvcnRfbW9kdWxllJOUjC9fX3J1bnRpbWVfXy5keW5hbWljX21vZHVsZV8tMTc1MzA1MzMzMDgwOTY2NjQ3OJSFlFKUfZQoaCxoLWhyTowLX19wYWNrYWdlX1+UTowIX19zcGVjX1+UTowIX19maWxlX1+UaIRoD4wTYm90cy5kZXYuZGVjb3JhdG9yc5RoD5OUaBBoj2gQk5RoE2iPaBOTlIwDYXN0lGiHaJOFlFKUjAhkYXRldGltZZRoh2iWhZRSlIwJZnVuY3Rvb2xzlGiHaJmFlFKUjAdpbnNwZWN0lGiHaJyFlFKUjAdsb2dnaW5nlGiHaJ+FlFKUaExoh2hMhZRSlIwDc3lzlGiHjANzeXOUhZRSlIwIdGV4dHdyYXCUaIdoqIWUUpSMCXRyYWNlYmFja5Roh2irhZRSlIwFd3JhcHOUaJlorpOUjANBbnmUjAZ0eXBpbmeUaLCTlIwIQ2FsbGFibGWUaLFos5OUjAhPcHRpb25hbJRosWi1k5SMBFR5cGWUaLFot5OUjBJyZW1vdmVfY29kZV9ibG9ja3OUaBJouZOUjAZsb2dnZXKUaJ+MCWdldExvZ2dlcpSTlGiPhZRSlIwMTm9IVFRQRmlsdGVylGiPaMCTlIwHbGF6eV9mbpRoj2jCk5SMCmxhenlfY2xhc3OUaI9oxJOUjAxfZ2V0X2NvbnRleHSUaI9oxpOUjBFfZ2V0X3B5X2ludGVyZmFjZZRoj2jIk5SMBGxhenmUaI9oypOUjA5kZWJ1Z19vbl9lcnJvcpRoj2jMk5SMCmxvZ19lcnJvcnOUaI9ozpOUjAd0b29saWZ5lGgCKGgEKEMEBBYK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uWi6aLtov2jAaMFowmjDaMRoxWjGaMdoyGjJaMpoy2jMaM1ozmjPaNBo72j0aPVo9mj3aPho+Wj6aPtoVGj+aAdo/2oAAQAAagEBAABqAgEAAGoEAQAAagUBAABqBwEAAGhRahwBAABqIQEAAGoiAQAAaiMBAABqJAEAAGolAQAAaiYBAABqJwEAAGooAQAAaikBAABqKgEAAGorAQAAaiwBAABqLQEAAGouAQAAaFdqLwEAAGowAQAAajEBAABoLmg1ajIBAABqMwEAAGo0AQAAajUBAABqNgEAAGo3AQAAajgBAABqOQEAAGhTamMBAABqVQEAAGpqAQAAamsBAABqbAEAAGpQAQAAam0BAABqUwEAAGpuAQAAam8BAABqcAEAAGpxAQAAanIBAABqcwEAAGp0AQAAanUBAABqdgEAAGp8AQAAY2J1aWx0aW5zCl9fZGljdF9fCnUwaOwoaCxoLWhyTmiMTmp7AQAATmiNTmiOaIRoD2iQaBBokWgTaJJok2iVaJZomGiZaJtonGieaJ9ooWhMaKNopGinaKhoqmiraK1ormivaLBosmizaLRotWi2aLdouGi5aLpou2i/aMBowWjCaMNoxGjFaMZox2jIaMloymjLaMxozWjOaM9o0GjvaPRo9Wj2aPdo+Gj5aPpo+2hUaP5oB2j/agABAABqAQEAAGoCAQAAagQBAABqBQEAAGoHAQAAaFFqHAEAAGohAQAAaiIBAABqIwEAAGokAQAAaiUBAABqJgEAAGonAQAAaigBAABqKQEAAGoqAQAAaisBAABqLAEAAGotAQAAai4BAABoV2ovAQAAajABAABqMQEAAGguaDVqMgEAAGozAQAAajQBAABqNQEAAGo2AQAAajcBAABqOAEAAGo5AQAAaFNqYwEAAGpVAQAAamoBAABqawEAAGpsAQAAalABAABqbQEAAGpTAQAAam4BAABqbwEAAGpwAQAAanEBAABqcgEAAGpzAQAAanQBAABqdQEAAGp2AQAAanwBAABjYnVpbHRpbnMKX19kaWN0X18KdTBoayhoLGgtaHJOaIxOansBAABOaI1OaI5ohGgPaJBoEGiRaBNokmiTaJVolmiYaJlom2icaJ5on2ihaExoo2ikaKdoqGiqaKtorWiuaK9osGiyaLNotGi1aLZot2i4aLloumi7aL9owGjBaMJow2jEaMVoxmjHaMhoyWjKaMtozGjNaM5oz2jQaO9o9Gj1aPZo92j4aPlo+mj7aFRo/mgHaP9qAAEAAGoBAQAAagIBAABqBAEAAGoFAQAAagcBAABoUWocAQAAaiEBAABqIgEAAGojAQAAaiQBAABqJQEAAGomAQAAaicBAABqKAEAAGopAQAAaioBAABqKwEAAGosAQAAai0BAABqLgEAAGhXai8BAABqMAEAAGoxAQAAaC5oNWoyAQAAajMBAABqNAEAAGo1AQAAajYBAABqNwEAAGo4AQAAajkBAABoU2pjAQAAalUBAABqagEAAGprAQAAamwBAABqUAEAAGptAQAAalMBAABqbgEAAGpvAQAAanABAABqcQEAAGpyAQAAanMBAABqdAEAAGp1AQAAanYBAABqfAEAAGNidWlsdGlucwpfX2RpY3RfXwp1MIwIYnVpbHRpbnOUjAdnZXRhdHRylJOUjARkaWxslIwFX2RpbGyUk5SMCF9zZXRhdHRylGp9AQAAjAdzZXRhdHRylJOUh5RSlGgyjA1jZWxsX2NvbnRlbnRzlGhvh5RSMGgrKGgsaC1ock5ojE5qewEAAE5ojU5ojmiEaA9okGgQaJFoE2iSaJNolWiWaJhomWibaJxonmifaKFoTGijaKRop2ioaKpoq2itaK5or2iwaLJos2i0aLVotmi3aLhouWi6aLtov2jAaMFowmjDaMRoxWjGaMdoyGjJaMpoy2jMaM1ozmjPaNBo72j0aPVo9mj3aPho+Wj6aPtoVGj+aAdo/2oAAQAAagEBAABqAgEAAGoEAQAAagUBAABqBwEAAGhRahwBAABqIQEAAGoiAQAAaiMBAABqJAEAAGolAQAAaiYBAABqJwEAAGooAQAAaikBAABqKgEAAGorAQAAaiwBAABqLQEAAGouAQAAaFdqLwEAAGowAQAAajEBAABoLmg1ajIBAABqMwEAAGo0AQAAajUBAABqNgEAAGo3AQAAajgBAABqOQEAAGhTamMBAABqVQEAAGpqAQAAamsBAABqbAEAAGpQAQAAam0BAABqUwEAAGpuAQAAam8BAABqcAEAAGpxAQAAanIBAABqcwEAAGp0AQAAanUBAABqdgEAAGp8AQAAY2J1aWx0aW5zCl9fZGljdF9fCnUwLg==",
      "name": "python_view",
      "hash": "691c5c891febfc9728d10cba24d83b7953a373b942780c3d56949579ae351059",
      "provenance": {
       "module": "dynamic_module_-1753053330809666478",
       "qualname": "python_view"
      }
     },
     "python_edit": {
      "__imported_callable__": true,
      "pickled": "gASVKgAAAAAAAACMFmJvdHMudG9vbHMucHl0aG9uX2VkaXSUjAtweXRob25fZWRpdJSTlC4=",
      "name": "python_edit",
      "hash": "668f01839237a287004942168b9cd81765ed09c083dc60d3f16b5c26e0e41db7",
      "provenance": {
       "module": "bots.tools.python_edit",
       "qualname": "python_edit"
      }
     },
     "_handle_file_end_insertion": {
      "__helper_func__": true,
      "pickled": "gASVOQAAAAAAAACMFmJvdHMudG9vbHMucHl0aG9uX2VkaXSUjBpfaGFuZGxlX2ZpbGVfZW5kX2luc2VydGlvbpSTlC4=",
      "name": "_handle_file_end_insertion",
      "hash": "dae548a452fc7999275bbbe984eb9391f90eb0eda782778c968cc88983dcab92",
      "provenance": {
       "module": "bots.tools.python_edit",
       "qualname": "_handle_file_end_insertion"
      }
     },
     "_handle_first_definition": {
      "__helper_func__": true,
      "pickled": "gASVNwAAAAAAAACMFmJvdHMudG9vbHMucHl0aG9uX2VkaXSUjBhfaGFuZGxlX2ZpcnN0X2RlZmluaXRpb26Uk5Qu",
      "name": "_handle_first_definition",
      "hash": "0c158a8d191989d1698854e79c8a3e872047d559a5d73ede5bc6a5b1e567d5fd",
      "provenance": {
       "module": "bots.tools.python_edit",
       "qualname": "_handle_first_definition"
      }
     },
     "_create_statement_with_comment": {
      "__helper_func__": true,
      "pickled": "gASVPQAAAAAAAACMFmJvdHMudG9vbHMucHl0aG9uX2VkaXSUjB5fY3JlYXRlX3N0YXRlbWVudF93aXRoX2NvbW1lbnSUk5Qu",
      "name": "_create_statement_with_comment",
      "hash": "1ebe141dd72ef4f88c1d88c56ed615dbae80611281e3abf2a227897fd7743bf9",
      "provenance": {
       "module": "bots.tools.python_edit",
       "qualname": "_create_statement_with_comment"
      }
     },
     "_create_signature_outline": {
      "__helper_func__": true,
      "pickled": "gASVOAAAAAAAAACMFmJvdHMudG9vbHMucHl0aG9uX2VkaXSUjBlfY3JlYXRlX3NpZ25hdHVyZV9vdXRsaW5llJOULg==",
      "name": "_create_signature_outline",
      "hash": "73cf1e4a4eb078fcae58b84f436b653a8e45f1be1bd987ac7958ecfad1ecd930",
      "provenance": {
       "module": "bots.tools.python_edit",
       "qualname": "_create_signature_outline"
      }
     },
     "_get_module_name": {
      "__helper_func__": true,
      "pickled": "gASVLwAAAAAAAACMFmJvdHMudG9vbHMucHl0aG9uX2VkaXSUjBBfZ2V0X21vZHVsZV9uYW1llJOULg==",
      "name": "_get_module_name",
      "hash": "30805f5c244780f1466652f5f126fa0b79de16e5b7acda9775eb4044ec1e5f6a",
      "provenance": {
       "module": "bots.tools.python_edit",
       "qualname": "_get_module_name"
      }
     },
     "_collect_scope_entries": {
      "__helper_func__": true,
      "pickled": "gASVNQAAAAAAAACMFmJvdHMudG9vbHMucHl0aG9uX2VkaXSUjBZfY29sbGVjdF9zY29wZV9lbnRyaWVzlJOULg==",
      "name": "_collect_scope_entries",
      "hash": "e9ce6f3a1146633cfc54be3623da8d3084e5b4f8e6cb27eebd616b1dd0ba509e",
      "provenance": {
       "module": "bots.tools.python_edit",
       "qualname": "_collect_scope_entries"
      }
     },
     "_create_outline_view": {
      "__helper_func__": true,
      "pickled": "gASVMwAAAAAAAACMFmJvdHMudG9vbHMucHl0aG9uX2VkaXSUjBRfY3JlYXRlX291dGxpbmVfdmlld5STlC4=",
      "name": "_create_outline_view",
      "hash": "5603f55056e2cd9e4430dd855b431bd668b6b10a5c672070e618302459afbe78",
      "provenance": {
       "module": "bots.tools.python_edit",
       "qualname": "_create_outline_view"
      }
     },
     "_handle_file_start_insertion": {
      "__helper_func__": true,
      "pickled": "gASVOwAAAAAAAACMFmJvdHMudG9vbHMucHl0aG9uX2VkaXSUjBxfaGFuZGxlX2ZpbGVfc3RhcnRfaW5zZXJ0aW9ulJOULg==",
      "name": "_handle_file_start_insertion",
      "hash": "02cf9682d65cb57165cb74a382fe654b304ebbb6bdc9329680440d39c4472c75",
      "provenance": {
       "module": "bots.tools.python_edit",
       "qualname": "_handle_file_start_insertion"
      }
     },
     "_handle_file_level_insertion": {
      "__helper_func__": true,
      "pickled": "gASVOwAAAAAAAACMFmJvdHMudG9vbHMucHl0aG9uX2VkaXSUjBxfaGFuZGxlX2ZpbGVfbGV2ZWxfaW5zZXJ0aW9ulJOULg==",
      "name": "_handle_file_level_insertion",
      "hash": "6209689d6b2193f1724c399f6cc7cfb8116b78f0d6048c7baa5b76708ecdfa57",
      "provenance": {
       "module": "bots.tools.python_edit",
       "qualname": "_handle_file_level_insertion"
      }
     },
     "_handle_deletion": {
      "__helper_func__": true,
      "pickled": "gASVLwAAAAAAAACMFmJvdHMudG9vbHMucHl0aG9uX2VkaXSUjBBfaGFuZGxlX2RlbGV0aW9ulJOULg==",
      "name": "_handle_deletion",
      "hash": "f2221cfd8e3b5f3ab5816060c70817c0a00d6aba9829dec03c59a5647155bad0",
      "provenance": {
       "module": "bots.tools.python_edit",
       "qualname": "_handle_deletion"
      }
     },
     "ScopeDeleter": {
      "__imported_callable__": true,
      "pickled": "gASVKwAAAAAAAACMFmJvdHMudG9vbHMucHl0aG9uX2VkaXSUjAxTY29wZURlbGV0ZXKUk5Qu",
      "name": "ScopeDeleter",
      "hash": "2e1797a54f6a4c4a737cf4b4afdd26d0427eae05984c9621a292238566decc39",
      "provenance": {
       "module": "bots.tools.python_edit",
       "qualname": "ScopeDeleter"
      }
     }
    }
   },
   "dynamic_module_3472951775955387811": {
    "name": "dynamic_module_2613328873078327977",
    "source": "from bots.utils.helpers import _process_error\nfrom typing import Any, Callable\nfrom functools import wraps\n\ndef toolify(description: str = None):\n    \"\"\"\n    Convert any function into a bot tool with string-in, string-out interface.\n\n    - Converts string inputs to proper types using type hints\n    - Ensures string output (JSON for complex types)\n    - Wraps in error handling (returns error strings, never raises)\n    - Enhances docstring if description provided\n\n    Args:\n        description (str, optional): Override the function's docstring\n\n    Example:\n        @toolify()\n        def add_numbers(x: int, y: int = 0) -> int:\n            return x + y\n\n        @toolify(\"Calculate the area of a circle\")\n        def area(radius: float) -> float:\n            return 3.14159 * radius * radius\n    \"\"\"\n\n    def decorator(func):\n        @functools.wraps(func)\n        def wrapper(*args, **kwargs):\n            try:\n                # Convert string inputs to proper types using type hints\n                converted_args, converted_kwargs = _convert_tool_inputs(func, args, kwargs)\n\n                # Call original function\n                result = func(*converted_args, **converted_kwargs)\n\n                # Convert result to string\n                return _convert_tool_output(result)\n\n            except KeyboardInterrupt as e:\n                # Convert KeyboardInterrupt to ToolExecutionError to prevent it from\n                # bubbling up to CLI and being treated as user Ctrl+C\n\n                tool_error = ToolExecutionError(f\"Tool execution interrupted: {str(e)}\")\n                return _process_error(tool_error)\n\n            except TypeError as e:\n                # Check if this is a missing required argument error\n                error_msg = str(e)\n                if \"missing\" in error_msg and \"required\" in error_msg and \"argument\" in error_msg:\n                    # Add special message for output token limitation\n                    enhanced_error = TypeError(\n                        f\"{error_msg}\\n\\n\"\n                        f\"\u26a0\ufe0f  This error is commonly caused by hitting the max_tokens limit before completing the tool call.\\n\"\n                        f\"The response was truncated mid-parameter, making it appear that required parameters are missing.\\n\"\n                        f\"To fix this: Work in SMALLER CHUNKS. Edit fewer lines at a time, \"\n                        f\"or break your task into multiple steps.\"\n                    )\n\n                    return _process_error(enhanced_error)\n                else:\n\n                    return _process_error(e)\n            except Exception as e:\n\n                return _process_error(e)\n\n        # Update docstring if description provided\n        if description:\n            wrapper.__doc__ = description\n        elif not wrapper.__doc__:\n            # Generate minimal docstring from function name\n            wrapper.__doc__ = f\"Execute {func.__name__.replace('_', ' ')}\"\n\n        return wrapper\n\n    return decorator\n\ndef log_errors(func: Callable) -> Callable:\n    \"\"\"Decorator that logs errors to a file when a function raises an exception or returns an error message.\n\n    This decorator captures both exceptions and return values that contain \"Error\" in the first few words,\n    logging them to 'error_log.txt' in the same directory as this decorators file.\n\n    Parameters:\n        func (Callable): The function to wrap with error logging capabilities\n\n    Returns:\n        Callable: A wrapped version of the function that logs errors\n\n    Example:\n        @log_errors\n        def risky_function():\n            # Any exceptions or \"Error\" messages will be logged\n            return \"Error: Something went wrong\"\n    \"\"\"\n\n    @wraps(func)\n    def wrapper(*args: Any, **kwargs: Any) -> Any:\n        try:\n            result = func(*args, **kwargs)\n\n            # Check if result is a string that starts with \"Tool Failed:\" (the specific format from handle_errors)\n            if isinstance(result, str) and result.startswith(\"Tool Failed:\"):\n                _log_error_to_file(func.__name__, f\"Function returned error message: {result}\", args, kwargs)\n\n            return result\n\n        except Exception as e:\n            # Log the exception\n            error_msg = f\"Exception in {func.__name__}: {str(e)}\\nTraceback:\\n{traceback.format_exc()}\"\n            _log_error_to_file(func.__name__, error_msg, args, kwargs)\n            # Re-raise the exception\n            raise\n\n    return wrapper\n\n@log_errors\n@toolify()\ndef execute_powershell(command: str, output_length_limit: str='1000', timeout: str='60') -> str:\n    \"\"\"\n    Executes PowerShell commands in a stateful environment with automatic BOM removal\n\n    Use when you need to run PowerShell commands and capture their output. If\n    you have other tools available, you should use this as a fallback when the\n    other tools fail. Coerces to utf-8 (no BOM).\n\n    Potential use cases:\n    - git commands\n    - gh cli\n    - other cli (which you may need to install using this tool)\n\n    Parameters:\n    - command (str): PowerShell command to execute.\n    - output_length_limit (int, optional): Maximum number of lines in the output.\n      If set, output exceeding this limit will be truncated. Default 200.\n\n    Returns:\n        str: The complete output from the command execution\n    \"\"\"\n    manager = PowerShellManager.get_instance()\n    output = ''.join(manager.execute(command, int(output_length_limit), float(timeout)))\n    return output",
    "file_path": "dynamic_module_3472951775955387811",
    "code_hash": "de147486342af7637692925f3531aa84",
    "globals": {
     "_log_error_to_file": {
      "__helper_func__": true,
      "pickled": "gASVLgAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjBJfbG9nX2Vycm9yX3RvX2ZpbGWUk5Qu",
      "name": "_log_error_to_file",
      "hash": "c02546b672eb25afd5dc51ea7e1967cbb6fd264ca18ffd15c3cbeccebe4046ba",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "_log_error_to_file"
      }
     },
     "traceback": {
      "__module_type__": true,
      "name": "traceback",
      "spec": "traceback"
     },
     "ast": {
      "__module_type__": true,
      "name": "ast",
      "spec": "ast"
     },
     "datetime": {
      "__module_type__": true,
      "name": "datetime",
      "spec": "datetime"
     },
     "functools": {
      "__module_type__": true,
      "name": "functools",
      "spec": "functools"
     },
     "inspect": {
      "__module_type__": true,
      "name": "inspect",
      "spec": "inspect"
     },
     "logging": {
      "__module_type__": true,
      "name": "logging",
      "spec": "logging"
     },
     "os": {
      "__module_type__": true,
      "name": "os",
      "spec": "os"
     },
     "sys": {
      "__module_type__": true,
      "name": "sys",
      "spec": "sys"
     },
     "textwrap": {
      "__module_type__": true,
      "name": "textwrap",
      "spec": "textwrap"
     },
     "wraps": {
      "__imported_callable__": true,
      "pickled": "gASVFwAAAAAAAACMCWZ1bmN0b29sc5SMBXdyYXBzlJOULg==",
      "name": "wraps",
      "hash": "4c7c8f91a978a903bce2515f7fe83cb09b7074259dabad02b312209312f718ed",
      "provenance": {
       "module": "functools",
       "qualname": "wraps"
      }
     },
     "Any": {
      "__imported_callable__": true,
      "pickled": "gASVEgAAAAAAAACMBnR5cGluZ5SMA0FueZSTlC4=",
      "name": "Any",
      "hash": "fbf19bc6bf716a555ce7094664e2bc898734e4acfc2cd6d9ee399edef2e5c02b",
      "provenance": {
       "module": "typing",
       "qualname": "Any"
      }
     },
     "Callable": {
      "__imported_callable__": true,
      "pickled": "gASVFwAAAAAAAACMBnR5cGluZ5SMCENhbGxhYmxllJOULg==",
      "name": "Callable",
      "hash": "17cf7f09b805961290dccb95aa11199df32c246cb879f355ffa1a31d6285edad",
      "provenance": {
       "module": "typing",
       "qualname": "Callable"
      }
     },
     "Optional": {
      "__imported_callable__": true,
      "pickled": "gASVFwAAAAAAAACMBnR5cGluZ5SMCE9wdGlvbmFslJOULg==",
      "name": "Optional",
      "hash": "d69b63c158dd563d1537447d9d3a68afdda0efb70794ab11c234d01e2e593e56",
      "provenance": {
       "module": "typing",
       "qualname": "Optional"
      }
     },
     "Type": {
      "__imported_callable__": true,
      "pickled": "gASVEwAAAAAAAACMBnR5cGluZ5SMBFR5cGWUk5Qu",
      "name": "Type",
      "hash": "9e98fdb991d3addb0aad6e13cd94b21998f5d97e9f30b15f9c697afe5cde1832",
      "provenance": {
       "module": "typing",
       "qualname": "Type"
      }
     },
     "remove_code_blocks": {
      "__imported_callable__": true,
      "pickled": "gASVLQAAAAAAAACMEmJvdHMudXRpbHMuaGVscGVyc5SMEnJlbW92ZV9jb2RlX2Jsb2Nrc5STlC4=",
      "name": "remove_code_blocks",
      "hash": "44524fda389310a2a28f80da99409efd110baefaa9ea50345d092a634c89fc1d",
      "provenance": {
       "module": "bots.utils.helpers",
       "qualname": "remove_code_blocks"
      }
     },
     "ToolExecutionError": {
      "__imported_callable__": true,
      "pickled": "gASVLgAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjBJUb29sRXhlY3V0aW9uRXJyb3KUk5Qu",
      "name": "ToolExecutionError",
      "hash": "e3f136f46cc3014d1b1a8ac6716adb9da7db1dd83f2ed8529e090d97ae0db998",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "ToolExecutionError"
      }
     },
     "NoHTTPFilter": {
      "__imported_callable__": true,
      "pickled": "gASVKAAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjAxOb0hUVFBGaWx0ZXKUk5Qu",
      "name": "NoHTTPFilter",
      "hash": "9f920bc687c51afef3dea517f9b64393473ed37dac3fda0cedd01a655b483a52",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "NoHTTPFilter"
      }
     },
     "lazy_fn": {
      "__imported_callable__": true,
      "pickled": "gASVIwAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjAdsYXp5X2ZulJOULg==",
      "name": "lazy_fn",
      "hash": "a1737e2cf8adde594f0dd0b3f17ffaad4c126dcf16906e82cb07f18c13d8b7a2",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "lazy_fn"
      }
     },
     "lazy_class": {
      "__imported_callable__": true,
      "pickled": "gASVJgAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjApsYXp5X2NsYXNzlJOULg==",
      "name": "lazy_class",
      "hash": "d1883fc4e7eb2d64f47b4e90b4b6b69d0c5be0d0e3175787058ad631d122e4c6",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "lazy_class"
      }
     },
     "_get_context": {
      "__helper_func__": true,
      "pickled": "gASVKAAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjAxfZ2V0X2NvbnRleHSUk5Qu",
      "name": "_get_context",
      "hash": "979ef249cdc1f76f4020d948ffc352f7c667afb0d89f221770156eebd7717c7a",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "_get_context"
      }
     },
     "_get_py_interface": {
      "__helper_func__": true,
      "pickled": "gASVLQAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjBFfZ2V0X3B5X2ludGVyZmFjZZSTlC4=",
      "name": "_get_py_interface",
      "hash": "d45b0506fb8815e8d9c3a9217b0ca101dac4fb9f51c8546285cf68a95ab027e7",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "_get_py_interface"
      }
     },
     "lazy": {
      "__imported_callable__": true,
      "pickled": "gASVIAAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjARsYXp5lJOULg==",
      "name": "lazy",
      "hash": "6e25446d8765ac65a5518c01582ddf52784eb90c51d57e224c94823d5b7c55cd",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "lazy"
      }
     },
     "debug_on_error": {
      "__imported_callable__": true,
      "pickled": "gASVKgAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjA5kZWJ1Z19vbl9lcnJvcpSTlC4=",
      "name": "debug_on_error",
      "hash": "06d89d594519c41c1dae666437441d4fd4aeeea959f1c905694940a50ae4ddfe",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "debug_on_error"
      }
     },
     "log_errors": {
      "__imported_callable__": true,
      "pickled": "gASVLDkAAAAAAACMCmRpbGwuX2RpbGyUjBBfY3JlYXRlX2Z1bmN0aW9ulJOUKGgAjAxfY3JlYXRlX2NvZGWUk5QoQwoEExQBLv8IAQIRlEsBSwBLAEsCSwdLA0NUhwCXAHQBAAAAAAAAAACJAKsBAAAAAAAAZAF0AgAAAAAAAAAAZAJ0AgAAAAAAAAAAZAN0AgAAAAAAAAAAZgaIAGYBZASEDKsAAAAAAAAAfQF8AVMAlChYjAIAAERlY29yYXRvciB0aGF0IGxvZ3MgZXJyb3JzIHRvIGEgZmlsZSB3aGVuIGEgZnVuY3Rpb24gcmFpc2VzIGFuIGV4Y2VwdGlvbiBvciByZXR1cm5zIGFuIGVycm9yIG1lc3NhZ2UuCgogICAgVGhpcyBkZWNvcmF0b3IgY2FwdHVyZXMgYm90aCBleGNlcHRpb25zIGFuZCByZXR1cm4gdmFsdWVzIHRoYXQgY29udGFpbiAiRXJyb3IiIGluIHRoZSBmaXJzdCBmZXcgd29yZHMsCiAgICBsb2dnaW5nIHRoZW0gdG8gJ2Vycm9yX2xvZy50eHQnIGluIHRoZSBzYW1lIGRpcmVjdG9yeSBhcyB0aGlzIGRlY29yYXRvcnMgZmlsZS4KCiAgICBQYXJhbWV0ZXJzOgogICAgICAgIGZ1bmMgKENhbGxhYmxlKTogVGhlIGZ1bmN0aW9uIHRvIHdyYXAgd2l0aCBlcnJvciBsb2dnaW5nIGNhcGFiaWxpdGllcwoKICAgIFJldHVybnM6CiAgICAgICAgQ2FsbGFibGU6IEEgd3JhcHBlZCB2ZXJzaW9uIG9mIHRoZSBmdW5jdGlvbiB0aGF0IGxvZ3MgZXJyb3JzCgogICAgRXhhbXBsZToKICAgICAgICBAbG9nX2Vycm9ycwogICAgICAgIGRlZiByaXNreV9mdW5jdGlvbigpOgogICAgICAgICAgICAjIEFueSBleGNlcHRpb25zIG9yICJFcnJvciIgbWVzc2FnZXMgd2lsbCBiZSBsb2dnZWQKICAgICAgICAgICAgcmV0dXJuICJFcnJvcjogU29tZXRoaW5nIHdlbnQgd3JvbmciCiAgICCUjARhcmdzlIwGa3dhcmdzlIwGcmV0dXJulGgEKEMUBAICARADQgE2AgYCEAJgATACCvuUSwBLAEsASwVLCEsfQkYBAACVAZcACQACAIkFfABpAHwBpAGOAX0CdAEAAAAAAAAAAHwCdAIAAAAAAAAAAKsCAAAAAAAAcix8AmoFAAAAAAAAAAAAAAAAAAAAAAAAZAGrAQAAAAAAAHIbdAcAAAAAAAAAAIkFaggAAAAAAAAAAAAAAAAAAAAAAABkAnwCmwCdAnwAfAGrBAAAAAAAAAEAfAJTACMAdAoAAAAAAAAAACQAck59A2QDiQVqCAAAAAAAAAAAAAAAAAAAAAAAAJsAZAR0AwAAAAAAAAAAfAOrAQAAAAAAAJsAZAV0DAAAAAAAAAAAag8AAAAAAAAAAAAAAAAAAAAAAACrAAAAAAAAAJsAnQZ9BHQHAAAAAAAAAACJBWoIAAAAAAAAAAAAAAAAAAAAAAAAfAR8AHwBqwQAAAAAAAABAIIAZAB9A34DdwF3AHgDWQB3AZQoTowMVG9vbCBGYWlsZWQ6lIwhRnVuY3Rpb24gcmV0dXJuZWQgZXJyb3IgbWVzc2FnZToglIwNRXhjZXB0aW9uIGluIJSMAjoglIwMClRyYWNlYmFjazoKlHSUKIwKaXNpbnN0YW5jZZSMA3N0cpSMCnN0YXJ0c3dpdGiUjBJfbG9nX2Vycm9yX3RvX2ZpbGWUjAhfX25hbWVfX5SMCUV4Y2VwdGlvbpSMCXRyYWNlYmFja5SMCmZvcm1hdF9leGOUdJQoaAhoCYwGcmVzdWx0lIwBZZSMCWVycm9yX21zZ5R0lIwIPHN0cmluZz6UjAd3cmFwcGVylIwbbG9nX2Vycm9ycy48bG9jYWxzPi53cmFwcGVylEtiQ6L4gADwBA4JEtkVGZg00BUqoDbRFSqIRvQGABAamCakI9QPJqg21ys80Ss8uF7UK0zcECKgNKc9oT3QNFXQVlzQVV3QMl7QYGTQZmzUEG3gExmITfjkDxjyAAUJEuAaJ6gErw2pDaB/sGK8E7hRuxa4CMAOzHnXT2PRT2PTT2XQTmbQGGeISdwMHph0n32ZfahpuBS4dtQMRuAMEfvwCwUJEvqUQxmDQQVBCQDBCQlCIAPBEkEJQhsDwhsFQiADlIwEZnVuY5SFlCl0lFKUdJSMBXdyYXBzlIwDQW55lIaUaCVoIYaUaCCMCmxvZ19lcnJvcnOUaC5LT0M3+IAA9CYABguININb8AIPBRKUc/AADwUSpGPwAA8FEqxj9AAPBRLzAwAGEfACDwUS8CIADBOATpRDAJQpaCWFlHSUUpR9lGgXjBNib3RzLmRldi5kZWNvcmF0b3JzlHNoLk5OdJRSlH2UfZQojAdfX2RvY19flGgHjA9fX2Fubm90YXRpb25zX1+UfZQoaCWMBnR5cGluZ5SMCENhbGxhYmxllJOUaApoP3V1hpRiaDQoaBdoNWg6TowLX19wYWNrYWdlX1+UTowKX19sb2FkZXJfX5ROjAhfX3NwZWNfX5ROjAhfX2ZpbGVfX5SMImR5bmFtaWNfbW9kdWxlXzM0NzI5NTE3NzU5NTUzODc4MTGUaBZoNWgWk5RoGWgAjA5faW1wb3J0X21vZHVsZZSTlGgZhZRSlIwDYXN0lGhIaEuFlFKUjAhkYXRldGltZZRoSGhOhZRSlIwJZnVuY3Rvb2xzlGhIaFGFlFKUjAdpbnNwZWN0lGhIaFSFlFKUjAdsb2dnaW5nlGhIaFeFlFKUjAJvc5RoSGhahZRSlIwDc3lzlGhIjANzeXOUhZRSlIwIdGV4dHdyYXCUaEhoYYWUUpRoKmhRaCqTlGgraD1oK5OUaD5oP4wIT3B0aW9uYWyUaD1oZpOUjARUeXBllGg9aGiTlIwScmVtb3ZlX2NvZGVfYmxvY2tzlIwSYm90cy51dGlscy5oZWxwZXJzlGhqk5SMElRvb2xFeGVjdXRpb25FcnJvcpRoNWhtk5SMBmxvZ2dlcpRoV4wJZ2V0TG9nZ2VylJOUaDWFlFKUjAxOb0hUVFBGaWx0ZXKUaDVodJOUjAdsYXp5X2ZulGg1aHaTlIwKbGF6eV9jbGFzc5RoNWh4k5SMDF9nZXRfY29udGV4dJRoNWh6k5SMEV9nZXRfcHlfaW50ZXJmYWNllGg1aHyTlIwEbGF6eZRoNWh+k5SMDmRlYnVnX29uX2Vycm9ylGg1aICTlGguaDeMB3Rvb2xpZnmUaAIoaAQoQwQEFgo2lEsBSwBLAEsCSwJLA0MShwCXAIgAZgFkAYQIfQF8AVMAlFiIAgAACiAgICBDb252ZXJ0IGFueSBmdW5jdGlvbiBpbnRvIGEgYm90IHRvb2wgd2l0aCBzdHJpbmctaW4sIHN0cmluZy1vdXQgaW50ZXJmYWNlLgoKICAgIC0gQ29udmVydHMgc3RyaW5nIGlucHV0cyB0byBwcm9wZXIgdHlwZXMgdXNp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KToKICAgICIiIgogICAgQ29udmVydCBhbnkgZnVuY3Rpb24gaW50byBhIGJvdCB0b29sIHdpdGggc3RyaW5nLWluLCBzdHJpbmctb3V0IGludGVyZmFjZS4KCiAgICAtIENvbnZlcnRzIHN0cmluZyBpbnB1dHMgdG8gcHJvcGVyIHR5cGVzIHVzaW5nIHR5cGUgaGludHMKICAgIC0gRW5zdXJlcyBzdHJpbmcgb3V0cHV0IChKU09OIGZvciBjb21wbGV4IHR5cGVzKQogICAgLSBXcmFwcyBpbiBlcnJvciBoYW5kbGluZyAocmV0dXJucyBlcnJvciBzdHJpbmdzLCBuZXZlciByYWlzZXMpCiAgICAtIEVuaGFuY2VzIGRvY3N0cmluZyBpZiBkZXNjcmlwdGlvbiBwcm92aWRlZAoKICAgIEFyZ3M6CiAgICAgICAgZGVzY3JpcHRpb24gKHN0ciwgb3B0aW9uYWwpOiBPdmVycmlkZSB0aGUgZnVuY3Rpb24ncyBkb2NzdHJpbmcKCiAgICBFeGFtcGxlOgogICAgICAgIEB0b29saWZ5KCkKICAgICAgICBkZWYgYWRkX251bWJlcnMoeDogaW50LCB5OiBpbnQgPSAwKSAtPiBpbnQ6CiAgICAgICAgICAgIHJldHVybiB4ICsgeQoKICAgICAgICBAdG9vbGlmeSgiQ2FsY3VsYXRlIHRoZSBhcmVhIG9mIGEgY2lyY2xlIikKICAgICAgICBkZWYgYXJlYShyYWRpdXM6IGZsb2F0KSAtPiBmbG9hdDoKICAgICAgICAgICAgcmV0dXJuIDMuMTQxNTkgKiByYWRpdXMgKiByYWRpdXMKICAgICIiIgoKICAgIGRlZiBkZWNvcmF0b3IoZnVuYyk6CiAgICAgICAgQGZ1bmN0b29scy53cmFwcyhmdW5jKQogICAgICAgIGRlZiB3cmFwcGVyKCphcmdzLCAqKmt3YXJncyk6CiAgICAgICAgICAgIHRyeToKICAgICAgICAgICAgICAgICMgQ29udmVydCBzdHJpbmcgaW5wdXRzIHRvIHByb3BlciB0eXBlcyB1c2luZyB0eXBlIGhpbnRzCiAgICAgICAgICAgICAgICBjb252ZXJ0ZWRfYXJncywgY29udmVydGVkX2t3YXJncyA9IF9jb252ZXJ0X3Rvb2xfaW5wdXRzKGZ1bmMsIGFyZ3MsIGt3YXJncykKCiAgICAgICAgICAgICAgICAjIENhbGwgb3JpZ2luYWwgZnVuY3Rpb24KICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmMoKmNvbnZlcnRlZF9hcmdzLCAqKmNvbnZlcnRlZF9rd2FyZ3MpCgogICAgICAgICAgICAgICAgIyBDb252ZXJ0IHJlc3VsdCB0byBzdHJpbmcKICAgICAgICAgICAgICAgIHJldHVybiBfY29udmVydF90b29sX291dHB1dChyZXN1bHQpCgogICAgICAgICAgICBleGNlcHQgS2V5Ym9hcmRJbnRlcnJ1cHQgYXMgZToKICAgICAgICAgICAgICAgICMgQ29udmVydCBLZXlib2FyZEludGVycnVwdCB0byBUb29sRXhlY3V0aW9uRXJyb3IgdG8gcHJldmVudCBpdCBmcm9tCiAgICAgICAgICAgICAgICAjIGJ1YmJsaW5nIHVwIHRvIENMSSBhbmQgYmVpbmcgdHJlYXRlZCBhcyB1c2VyIEN0cmwrQwogICAgICAgICAgICAgICAgZnJvbSBib3RzLnV0aWxzLmhlbHBlcnMgaW1wb3J0IF9wcm9jZXNzX2Vycm9yCgogICAgICAgICAgICAgICAgdG9vbF9lcnJvciA9IFRvb2xFeGVjdXRpb25FcnJvcihmIlRvb2wgZXhlY3V0aW9uIGludGVycnVwdGVkOiB7c3RyKGUpfSIpCiAgICAgICAgICAgICAgICByZXR1cm4gX3Byb2Nlc3NfZXJyb3IodG9vbF9lcnJvcikKCiAgICAgICAgICAgIGV4Y2VwdCBUeXBlRXJyb3IgYXMgZToKICAgICAgICAgICAgICAgICMgQ2hlY2sgaWYgdGhpcyBpcyBhIG1pc3NpbmcgcmVxdWlyZWQgYXJndW1lbnQgZXJyb3IKICAgICAgICAgICAgICAgIGVycm9yX21zZyA9IHN0cihlKQogICAgICAgICAgICAgICAgaWYgIm1pc3NpbmciIGluIGVycm9yX21zZyBhbmQgInJlcXVpcmVkIiBpbiBlcnJvcl9tc2cgYW5kICJhcmd1bWVudCIgaW4gZXJyb3JfbXNnOgogICAgICAgICAgICAgICAgICAgICMgQWRkIHNwZWNpYWwgbWVzc2FnZSBmb3Igb3V0cHV0IHRva2VuIGxpbWl0YXRpb24KICAgICAgICAgICAgICAgICAgICBlbmhhbmNlZF9lcnJvciA9IFR5cGVFcnJvcigKICAgICAgICAgICAgICAgICAgICAgICAgZiJ7ZXJyb3JfbXNnfVxuXG4iCiAgICAgICAgICAgICAgICAgICAgICAgIGYi4pqg77iPICBUaGlzIGVycm9yIGlzIGNvbW1vbmx5IGNhdXNlZCBieSBoaXR0aW5nIHRoZSBtYXhfdG9rZW5zIGxpbWl0IGJlZm9yZSBjb21wbGV0aW5nIHRoZSB0b29sIGNhbGwuXG4iCiAgICAgICAgICAgICAgICAgICAgICAgIGYiVGhlIHJlc3BvbnNlIHdhcyB0cnVuY2F0ZWQgbWlkLXBhcmFtZXRlciwgbWFraW5nIGl0IGFwcGVhciB0aGF0IHJlcXVpcmVkIHBhcmFtZXRlcnMgYXJlIG1pc3NpbmcuXG4iCiAgICAgICAgICAgICAgICAgICAgICAgIGYiVG8gZml4IHRoaXM6IFdvcmsgaW4gU01BTExFUiBDSFVOS1MuIEVkaXQgZmV3ZXIgbGluZXMgYXQgYSB0aW1lLCAiCiAgICAgICAgICAgICAgICAgICAgICAgIGYib3IgYnJlYWsgeW91ciB0YXNrIGludG8gbXVsdGlwbGUgc3RlcHMuIgogICAgICAgICAgICAgICAgICAgICkKICAgICAgICAgICAgICAgICAgICBmcm9tIGJvdHMudXRpbHMuaGVscGVycyBpbXBvcnQgX3Byb2Nlc3NfZXJyb3IKCiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9wcm9jZXNzX2Vycm9yKGVuaGFuY2VkX2Vycm9yKQogICAgICAgICAgICAgICAgZWxzZToKICAgICAgICAgICAgICAgICAgICBmcm9tIGJvdHMudXRpbHMuaGVscGVycyBpbXBvcnQgX3Byb2Nlc3NfZXJyb3IKCiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9wcm9jZXNzX2Vycm9yKGUpCiAgICAgICAgICAgIGV4Y2VwdCBFeGNlcHRpb24gYXMgZToKICAgICAgICAgICAgICAgIGZyb20gYm90cy51dGlscy5oZWxwZXJzIGltcG9ydCBfcHJvY2Vzc19lcnJvcgoKICAgICAgICAgICAgICAgIHJldHVybiBfcHJvY2Vzc19lcnJvcihlKQoKICAgICAgICAjIFVwZGF0ZSBkb2NzdHJpbmcgaWYgZGVzY3JpcHRpb24gcHJvdmlkZWQKICAgICAgICBpZiBkZXNjcmlwdGlvbjoKICAgICAgICAgICAgd3JhcHBlci5fX2RvY19fID0gZGVzY3JpcHRpb24KICAgICAgICBlbGlmIG5vdCB3cmFwcGVyLl9fZG9jX186CiAgICAgICAgICAgICMgR2VuZXJhdGUgbWluaW1hbCBkb2NzdHJpbmcgZnJvbSBmdW5jdGlvbiBuYW1lCiAgICAgICAgICAgIHdyYXBwZXIuX19kb2NfXyA9IGYiRXhlY3V0ZSB7ZnVuYy5fX25hbWVfXy5yZXBsYWNlKCdfJywgJyAnKX0iCgogICAgICAgIHJldHVybiB3cmFwcGVyCgogICAgcmV0dXJuIGRlY29yYXRvcgoKZGVmIGxvZ19lcnJvcnMoZnVuYzogQ2FsbGFibGUpIC0+IENhbGxhYmxlOgogICAgIiIiRGVjb3JhdG9yIHRoYXQgbG9ncyBlcnJvcnMgdG8gYSBmaWxlIHdoZW4gYSBmdW5jdGlvbiByYWlzZXMgYW4gZXhjZXB0aW9uIG9yIHJldHVybnMgYW4gZXJyb3IgbWVzc2FnZS4KCiAgICBUaGlzIGRlY29yYXRvciBjYXB0dXJlcyBib3RoIGV4Y2VwdGlvbnMgYW5kIHJldHVybiB2YWx1ZXMgdGhhdCBjb250YWluICJFcnJvciIgaW4gdGhlIGZpcnN0IGZldyB3b3JkcywKICAgIGxvZ2dpbmcgdGhlbSB0byAnZXJyb3JfbG9nLnR4dCcgaW4gdGhlIHNhbWUgZGlyZWN0b3J5IGFzIHRoaXMgZGVjb3JhdG9ycyBmaWxlLgoKICAgIFBhcmFtZXRlcnM6CiAgICAgICAgZnVuYyAoQ2FsbGFibGUpOiBUaGUgZnVuY3Rpb24gdG8gd3JhcCB3aXRoIGVycm9yIGxvZ2dpbmcgY2FwYWJpbGl0aWVzCgogICAgUmV0dXJuczoKICAgICAgICBDYWxsYWJsZTogQSB3cmFwcGVkIHZlcnNpb24gb2YgdGhlIGZ1bmN0aW9uIHRoYXQgbG9ncyBlcnJvcnMKCiAgICBFeGFtcGxlOgogICAgICAgIEBsb2dfZXJyb3JzCiAgICAgICAgZGVmIHJpc2t5X2Z1bmN0aW9uKCk6CiAgICAgICAgICAgICMgQW55IGV4Y2VwdGlvbnMgb3IgIkVycm9yIiBtZXNzYWdlcyB3aWxsIGJlIGxvZ2dlZAogICAgICAgICAgICByZXR1cm4gIkVycm9yOiBTb21ldGhpbmcgd2VudCB3cm9uZyIKICAgICIiIgoKICAgIEB3cmFwcyhmdW5jKQogICAgZGVmIHdyYXBwZXIoKmFyZ3M6IEFueSwgKiprd2FyZ3M6IEFueSkgLT4gQW55OgogICAgICAgIHRyeToKICAgICAgICAgICAgcmVzdWx0ID0gZnVuYygqYXJncywgKiprd2FyZ3MpCgogICAgICAgICAgICAjIENoZWNrIGlmIHJlc3VsdCBpcyBhIHN0cmluZyB0aGF0IHN0YXJ0cyB3aXRoICJUb29sIEZhaWxlZDoiICh0aGUgc3BlY2lmaWMgZm9ybWF0IGZyb20gaGFuZGxlX2Vycm9ycykKICAgICAgICAgICAgaWYgaXNpbnN0YW5jZShyZXN1bHQsIHN0cikgYW5kIHJlc3VsdC5zdGFydHN3aXRoKCJUb29sIEZhaWxlZDoiKToKICAgICAgICAgICAgICAgIF9sb2dfZXJyb3JfdG9fZmlsZShmdW5jLl9fbmFtZV9fLCBmIkZ1bmN0aW9uIHJldHVybmVkIGVycm9yIG1lc3NhZ2U6IHtyZXN1bHR9IiwgYXJncywga3dhcmdzKQoKICAgICAgICAgICAgcmV0dXJuIHJlc3VsdAoKICAgICAgICBleGNlcHQgRXhjZXB0aW9uIGFzIGU6CiAgICAgICAgICAgICMgTG9nIHRoZSBleGNlcHRpb24KICAgICAgICAgICAgZXJyb3JfbXNnID0gZiJFeGNlcHRpb24gaW4ge2Z1bmMuX19uYW1lX199OiB7c3RyKGUpfVxuVHJhY2ViYWNrOlxue3RyYWNlYmFjay5mb3JtYXRfZXhjKCl9IgogICAgICAgICAgICBfbG9nX2Vycm9yX3RvX2ZpbGUoZnVuYy5fX25hbWVfXywgZXJyb3JfbXNnLCBhcmdzLCBrd2FyZ3MpCiAgICAgICAgICAgICMgUmUtcmFpc2UgdGhlIGV4Y2VwdGlvbgogICAgICAgICAgICByYWlzZQoKICAgIHJldHVybiB3cmFwcGVyCgpAbG9nX2Vycm9ycwpAdG9vbGlmeSgpCmRlZiBleGVjdXRlX3Bvd2Vyc2hlbGwoY29tbWFuZDogc3RyLCBvdXRwdXRfbGVuZ3RoX2xpbWl0OiBzdHI9JzEwMDAnLCB0aW1lb3V0OiBzdHI9JzYwJykgLT4gc3RyOgogICAgIiIiCiAgICBFeGVjdXRlcyBQb3dlclNoZWxsIGNvbW1hbmRzIGluIGEgc3RhdGVmdWwgZW52aXJvbm1lbnQgd2l0aCBhdXRvbWF0aWMgQk9NIHJlbW92YWwKCiAgICBVc2Ugd2hlbiB5b3UgbmVlZCB0byBydW4gUG93ZXJTaGVsbCBjb21tYW5kcyBhbmQgY2FwdHVyZSB0aGVpciBvdXRwdXQuIElmCiAgICB5b3UgaGF2ZSBvdGhlciB0b29scyBhdmFpbGFibGUsIHlvdSBzaG91bGQgdXNlIHRoaXMgYXMgYSBmYWxsYmFjayB3aGVuIHRoZQogICAgb3RoZXIgdG9vbHMgZmFpbC4gQ29lcmNlcyB0byB1dGYtOCAobm8gQk9NKS4KCiAgICBQb3RlbnRpYWwgdXNlIGNhc2VzOgogICAgLSBnaXQgY29tbWFuZHMKICAgIC0gZ2ggY2xpCiAgICAtIG90aGVyIGNsaSAod2hpY2ggeW91IG1heSBuZWVkIHRvIGluc3RhbGwgdXNpbmcgdGhpcyB0b29sKQoKICAgIFBhcmFtZXRlcnM6CiAgICAtIGNvbW1hbmQgKHN0cik6IFBvd2VyU2hlbGwgY29tbWFuZCB0byBleGVjdXRlLgogICAgLSBvdXRwdXRfbGVuZ3RoX2xpbWl0IChpbnQsIG9wdGlvbmFsKTogTWF4aW11bSBudW1iZXIgb2YgbGluZXMgaW4gdGhlIG91dHB1dC4KICAgICAgSWYgc2V0LCBvdXRwdXQgZXhjZWVkaW5nIHRoaXMgbGltaXQgd2lsbCBiZSB0cnVuY2F0ZWQuIERlZmF1bHQgMjAwLgoKICAgIFJldHVybnM6CiAgICAgICAgc3RyOiBUaGUgY29tcGxldGUgb3V0cHV0IGZyb20gdGhlIGNvbW1hbmQgZXhlY3V0aW9uCiAgICAiIiIKICAgIG1hbmFnZXIgPSBQb3dlclNoZWxsTWFuYWdlci5nZXRfaW5zdGFuY2UoKQogICAgb3V0cHV0ID0gJycuam9pbihtYW5hZ2VyLmV4ZWN1dGUoY29tbWFuZCwgaW50KG91dHB1dF9sZW5ndGhfbGltaXQpLCBmbG9hdCh0aW1lb3V0KSkpCiAgICByZXR1cm4gb3V0cHV0lIwJZmlsZV9wYXRolGhFjAluYW1lc3BhY2WUaEiMH19fcnVudGltZV9fLmJvdHMuZGV2LmRlY29yYXRvcnOUhZRSlH2UKGgXaDVoOk5oQU5oQ05oRGhFaBZoRmgZaEpoS2hNaE5oUGhRaFNoVGhWaFdoWWhaaFxoXWhgaGFoY2gqaGRoK2hlaD5oP2hmaGdoaGhpaGpobGhtaG5ob2hzaHRodWh2aHdoeGh5aHpoe2h8aH1ofmh/aIBogWguaDdogmi6aJJow2jEaMVok2jGaMdoyWjKaMxozWjPaNBo0mjTaNVo1mjZaNpo3GjdaOBo4WjiaONo5mjnaOho6WjqaOto7GjtaO9o8Gj4jBFQb3dlclNoZWxsU2Vzc2lvbpRo7mozAQAAk5RqBwEAAGjuagcBAACTlIwUX2dldF9hY3RpdmVfc2Vzc2lvbnOUaO5qNgEAAJOUjBFfcHJvY2Vzc19jb21tYW5kc5Ro7mo4AQAAk5SMIl9yZW1vdmVfYm9tX2Zyb21fY3VycmVudF9kaXJlY3RvcnmUaO5qOgEAAJOUjBVyZW1vdmVfYm9tX2Zyb21fZmlsZXOUaO5qPAEAAJOUjBNjaGVja19maWxlc19mb3JfYm9tlGjuaj4BAACTlHVijAljb2RlX2hhc2iUjCBjMTdjZWY2OGVmMTc0Zjg3NDE0ZDQ4ZWExNDU1M2MxZJR1YnV9lChoOmoEAQAAaDtqHwEAAHWGlGJqFwEAAChoF2g1aDpOaEFOaEJOaENOaERoRWgWaEZoGWhKaEtoTWhOaFBoUWhTaFRoVmhXaFloWmhcaF1oYGhhaGNoKmhkaCtoZWg+aD9oZmhnaGhoaWhqaGxobWhuaG9oc2h0aHVodmh3aHhoeWh6aHtofGh9aH5of2iAaIFoLmg3aIJoumiSaMNoxGjFaJNoxmjHaMloymjMaM1oz2jQaNJo02jVaNZo2WjaaNxo3WjgaOFo4mjjaOZo52joaOlo6mjraOxo7WjvaPBo+GozAQAAajQBAABqBwEAAGo1AQAAajYBAABqNwEAAGo4AQAAajkBAABqOgEAAGo7AQAAajwBAABqPQEAAGo+AQAAaj8BAACMDF9fYnVpbHRpbnNfX5RjYnVpbHRpbnMKX19kaWN0X18KdTCMCGJ1aWx0aW5zlIwHZ2V0YXR0cpSTlIwEZGlsbJSMBV9kaWxslJOUjAhfc2V0YXR0cpRqRQEAAIwHc2V0YXR0cpSTlIeUUpRo/YwNY2VsbF9jb250ZW50c5RqHAEAAIeUUjBo+yhoF2g1aDpOaEFOaEJOaENOaERoRWgWaEZoGWhKaEtoTWhOaFBoUWhTaFRoVmhXaFloWmhcaF1oYGhhaGNoKmhkaCtoZWg+aD9oZmhnaGhoaWhqaGxobWhuaG9oc2h0aHVodmh3aHhoeWh6aHtofGh9aH5of2iAaIFoLmg3aIJoumiSaMNoxGjFaJNoxmjHaMloymjMaM1oz2jQaNJo02jVaNZo2WjaaNxo3WjgaOFo4mjjaOZo52joaOlo6mjraOxo7WjvaPBo+GozAQAAajQBAABqBwEAAGo1AQAAajYBAABqNwEAAGo4AQAAajkBAABqOgEAAGo7AQAAajwBAABqPQEAAGo+AQAAaj8BAABqRAEAAGNidWlsdGlucwpfX2RpY3RfXwp1MGpPAQAAaPVqUAEAAGoAAQAAh5RSMGjxKGgXaDVoOk5oQU5oQk5oQ05oRGhFaBZoRmgZaEpoS2hNaE5oUGhRaFNoVGhWaFdoWWhaaFxoXWhgaGFoY2gqaGRoK2hlaD5oP2hmaGdoaGhpaGpobGhtaG5ob2hzaHRodWh2aHdoeGh5aHpoe2h8aH1ofmh/aIBogWguaDdogmi6aJJow2jEaMVok2jGaMdoyWjKaMxozWjPaNBo0mjTaNVo1mjZaNpo3GjdaOBo4WjiaONo5mjnaOho6WjqaOto7GjtaO9o8Gj4ajMBAABqNAEAAGoHAQAAajUBAABqNgEAAGo3AQAAajgBAABqOQEAAGo6AQAAajsBAABqPAEAAGo9AQAAaj4BAABqPwEAAGpEAQAAY2J1aWx0aW5zCl9fZGljdF9fCnUwajMBAABqNAEAAGoHAQAAajUBAABqNgEAAGo3AQAAajgBAABqOQEAAGo6AQAAajsBAABqPAEAAGo9AQAAaj4BAABqPwEAAGpEAQAAY2J1aWx0aW5zCl9fZGljdF9fCnUwaJJow2jEaMVok2jGaMdoyWjKaMxozWjPaNBo0mjTaNVo1mjZaNpo3GjdaOBo4WjiaONo5mjnaOho6WjqaOto7GjtaO9o8Gj4ajMBAABqNAEAAGoHAQAAajUBAABqNgEAAGo3AQAAajgBAABqOQEAAGo6AQAAajsBAABqPAEAAGo9AQAAaj4BAABqPwEAAGpEAQAAY2J1aWx0aW5zCl9fZGljdF9fCnUwLg==",
      "name": "log_errors",
      "hash": "1216175487f0471e69bc13de08702576b80ba481ccc5925f31aeee329ebe7986",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "log_errors"
      }
     },
     "toolify": {
      "__imported_callable__": true,
      "pickled": "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UG90ZW50aWFsIHVzZSBjYXNlczoKICAgIC0gZ2l0IGNvbW1hbmRzCiAgICAtIGdoIGNsaQogICAgLSBvdGhlciBjbGkgKHdoaWNoIHlvdSBtYXkgbmVlZCB0byBpbnN0YWxsIHVzaW5nIHRoaXMgdG9vbCkKCiAgICBQYXJhbWV0ZXJzOgogICAgLSBjb21tYW5kIChzdHIpOiBQb3dlclNoZWxsIGNvbW1hbmQgdG8gZXhlY3V0ZS4KICAgIC0gb3V0cHV0X2xlbmd0aF9saW1pdCAoaW50LCBvcHRpb25hbCk6IE1heGltdW0gbnVtYmVyIG9mIGxpbmVzIGluIHRoZSBvdXRwdXQuCiAgICAgIElmIHNldCwgb3V0cHV0IGV4Y2VlZGluZyB0aGlzIGxpbWl0IHdpbGwgYmUgdHJ1bmNhdGVkLiBEZWZhdWx0IDIwMC4KCiAgICBSZXR1cm5zOgogICAgICAgIHN0cjogVGhlIGNvbXBsZXRlIG91dHB1dCBmcm9tIHRoZSBjb21tYW5kIGV4ZWN1dGlvbgogICAglIwAlIaUKIwRUG93ZXJTaGVsbE1hbmFnZXKUjAxnZXRfaW5zdGFuY2WUjARqb2lulIwHZXhlY3V0ZZSMA2ludJSMBWZsb2F0lHSUKIwHY29tbWFuZJSME291dHB1dF9sZW5ndGhfbGltaXSUjAd0aW1lb3V0lIwHbWFuYWdlcpSMBm91dHB1dJR0lGgnaPBo8Et2QzyAAPQuAA8g1w4s0Q4s0w4ugEfYDQ+PV4lXkFeXX5FfoFesY9AyRdMuRswFyGfLDtMVV9MNWIBG2AsRgE2UaD4pKXSUUpR9lGg3aExzaPCMBDEwMDCUjAI2MJSGlE50lFKUfZR9lChoNmoEAQAAaFJ9lChqDgEAAGhXag8BAABoV2oQAQAAaFdooWhXdXWGlGJzfZQoaDZqBAEAAGhSah8BAAB1hpRijBJfX21vZHVsZV9jb250ZXh0X1+UjBRib3RzLmZvdW5kYXRpb24uYmFzZZSMDU1vZHVsZUNvbnRleHSUk5QpgZR9lCiMBG5hbWWUjCJkeW5hbWljX21vZHVsZV8yNjEzMzI4ODczMDc4MzI3OTc3lIwGc291cmNllFgBFgAAZGVmIHRvb2xpZnkoZGVzY3JpcHRpb246IHN0ciA9IE5vbmUpOgogICAgIiIiCiAgICBDb252ZXJ0IGFueSBmdW5jdGlvbiBpbnRvIGEgYm90IHRvb2wgd2l0aCBzdHJpbmctaW4sIHN0cmluZy1vdXQgaW50ZXJmYWNlLgoKICAgIC0gQ29udmVydHMgc3RyaW5nIGlucHV0cyB0byBwcm9wZXIgdHlwZXMgdXNpbmcgdHlwZSBoaW50cwogICAgLSBFbnN1cmVzIHN0cmluZyBvdXRwdXQgKEpTT04gZm9yIGNvbXBsZXggdHlwZXMpCiAgICAtIFdyYXBzIGluIGVycm9yIGhhbmRsaW5nIChyZXR1cm5zIGVycm9yIHN0cmluZ3MsIG5ldmVyIHJhaXNlcykKICAgIC0gRW5oYW5jZXMgZG9jc3RyaW5nIGlmIGRlc2NyaXB0aW9uIHByb3ZpZGVkCgogICAgQXJnczoKICAgICAgICBkZXNjcmlwdGlvbiAoc3RyLCBvcHRpb25hbCk6IE92ZXJyaWRlIHRoZSBmdW5jdGlvbidzIGRvY3N0cmluZwoKICAgIEV4YW1wbGU6CiAgICAgICAgQHRvb2xpZnkoKQogICAgICAgIGRlZiBhZGRfbnVtYmVycyh4OiBpbnQsIHk6IGludCA9IDApIC0+IGludDoKICAgICAgICAgICAgcmV0dXJuIHggKyB5CgogICAgICAgIEB0b29saWZ5KCJDYWxjdWxhdGUgdGhlIGFyZWEgb2YgYSBjaXJjbGUiKQogICAgICAgIGRlZiBhcmVhKHJhZGl1czogZmxvYXQpIC0+IGZsb2F0OgogICAgICAgICAgICByZXR1cm4gMy4xNDE1OSAqIHJhZGl1cyAqIHJhZGl1cwogICAgIiIiCgogICAgZGVmIGRlY29yYXRvcihmdW5jKToKICAgICAgICBAZnVuY3Rvb2xzLndyYXBzKGZ1bmMpCiAgICAgICAgZGVmIHdyYXBwZXIoKmFyZ3MsICoqa3dhcmdzKToKICAgICAgICAgICAgdHJ5OgogICAgICAgICAgICAgICAgIyBDb252ZXJ0IHN0cmluZyBpbnB1dHMgdG8gcHJvcGVyIHR5cGVzIHVzaW5nIHR5cGUgaGludHMKICAgICAgICAgICAgICAgIGNvbnZlcnRlZF9hcmdzLCBjb252ZXJ0ZWRfa3dhcmdzID0gX2NvbnZlcnRfdG9vbF9pbnB1dHMoZnVuYywgYXJncywga3dhcmdzKQoKICAgICAgICAgICAgICAgICMgQ2FsbCBvcmlnaW5hbCBmdW5jdGlvbgogICAgICAgICAgICAgICAgcmVzdWx0ID0gZnVuYygqY29udmVydGVkX2FyZ3MsICoqY29udmVydGVkX2t3YXJncykKCiAgICAgICAgICAgICAgICAjIENvbnZlcnQgcmVzdWx0IHRvIHN0cmluZwogICAgICAgICAgICAgICAgcmV0dXJuIF9jb252ZXJ0X3Rvb2xfb3V0cHV0KHJlc3VsdCkKCiAgICAgICAgICAgIGV4Y2VwdCBLZXlib2FyZEludGVycnVwdCBhcyBlOgogICAgICAgICAgICAgICAgIyBDb252ZXJ0IEtleWJvYXJkSW50ZXJydXB0IHRvIFRvb2xFeGVjdXRpb25FcnJvciB0byBwcmV2ZW50IGl0IGZyb20KICAgICAgICAgICAgICAgICMgYnViYmxpbmcgdXAgdG8gQ0xJIGFuZCBiZWluZyB0cmVhdGVkIGFzIHVzZXIgQ3RybCtDCiAgICAgICAgICAgICAgICBmcm9tIGJvdHMudXRpbHMuaGVscGVycyBpbXBvcnQgX3Byb2Nlc3NfZXJyb3IKCiAgICAgICAgICAgICAgICB0b29sX2Vycm9yID0gVG9vbEV4ZWN1dGlvbkVycm9yKGYiVG9vbCBleGVjdXRpb24gaW50ZXJydXB0ZWQ6IHtzdHIoZSl9IikKICAgICAgICAgICAgICAgIHJldHVybiBfcHJvY2Vzc19lcnJvcih0b29sX2Vycm9yKQoKICAgICAgICAgICAgZXhjZXB0IFR5cGVFcnJvciBhcyBlOgogICAgICAgICAgICAgICAgIyBDaGVjayBpZiB0aGlzIGlzIGEgbWlzc2luZyByZXF1aXJlZCBhcmd1bWVudCBlcnJvcgogICAgICAgICAgICAgICAgZXJyb3JfbXNnID0gc3RyKGUpCiAgICAgICAgICAgICAgICBpZiAibWlzc2luZyIgaW4gZXJyb3JfbXNnIGFuZCAicmVxdWlyZWQiIGluIGVycm9yX21zZyBhbmQgImFyZ3VtZW50IiBpbiBlcnJvcl9tc2c6CiAgICAgICAgICAgICAgICAgICAgIyBBZGQgc3BlY2lhbCBtZXNzYWdlIGZvciBvdXRwdXQgdG9rZW4gbGltaXRhdGlvbgogICAgICAgICAgICAgICAgICAgIGVuaGFuY2VkX2Vycm9yID0gVHlwZUVycm9yKAogICAgICAgICAgICAgICAgICAgICAgICBmIntlcnJvcl9tc2d9XG5cbiIKICAgICAgICAgICAgICAgICAgICAgICAgZiLimqDvuI8gIFRoaXMgZXJyb3IgaXMgY29tbW9ubHkgY2F1c2VkIGJ5IGhpdHRpbmcgdGhlIG1heF90b2tlbnMgbGltaXQgYmVmb3JlIGNvbXBsZXRpbmcgdGhlIHRvb2wgY2FsbC5cbiIKICAgICAgICAgICAgICAgICAgICAgICAgZiJUaGUgcmVzcG9uc2Ugd2FzIHRydW5jYXRlZCBtaWQtcGFyYW1ldGVyLCBtYWtpbmcgaXQgYXBwZWFyIHRoYXQgcmVxdWlyZWQgcGFyYW1ldGVycyBhcmUgbWlzc2luZy5cbiIKICAgICAgICAgICAgICAgICAgICAgICAgZiJUbyBmaXggdGhpczogV29yayBpbiBTTUFMTEVSIENIVU5LUy4gRWRpdCBmZXdlciBsaW5lcyBhdCBhIHRpbWUsICIKICAgICAgICAgICAgICAgICAgICAgICAgZiJvciBicmVhayB5b3VyIHRhc2sgaW50byBtdWx0aXBsZSBzdGVwcy4iCiAgICAgICAgICAgICAgICAgICAgKQogICAgICAgICAgICAgICAgICAgIGZyb20gYm90cy51dGlscy5oZWxwZXJzIGltcG9ydCBfcHJvY2Vzc19lcnJvcgoKICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3Byb2Nlc3NfZXJyb3IoZW5oYW5jZWRfZXJyb3IpCiAgICAgICAgICAgICAgICBlbHNlOgogICAgICAgICAgICAgICAgICAgIGZyb20gYm90cy51dGlscy5oZWxwZXJzIGltcG9ydCBfcHJvY2Vzc19lcnJvcgoKICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3Byb2Nlc3NfZXJyb3IoZSkKICAgICAgICAgICAgZXhjZXB0IEV4Y2VwdGlvbiBhcyBlOgogICAgICAgICAgICAgICAgZnJvbSBib3RzLnV0aWxzLmhlbHBlcnMgaW1wb3J0IF9wcm9jZXNzX2Vycm9yCgogICAgICAgICAgICAgICAgcmV0dXJuIF9wcm9jZXNzX2Vycm9yKGUpCgogICAgICAgICMgVXBkYXRlIGRvY3N0cmluZyBpZiBkZXNjcmlwdGlvbiBwcm92aWRlZAogICAgICAgIGlmIGRlc2NyaXB0aW9uOgogICAgICAgICAgICB3cmFwcGVyLl9fZG9jX18gPSBkZXNjcmlwdGlvbgogICAgICAgIGVsaWYgbm90IHdyYXBwZXIuX19kb2NfXzoKICAgICAgICAgICAgIyBHZW5lcmF0ZSBtaW5pbWFsIGRvY3N0cmluZyBmcm9tIGZ1bmN0aW9uIG5hbWUKICAgICAgICAgICAgd3JhcHBlci5fX2RvY19fID0gZiJFeGVjdXRlIHtmdW5jLl9fbmFtZV9fLnJlcGxhY2UoJ18nLCAnICcpfSIKCiAgICAgICAgcmV0dXJuIHdyYXBwZXIKCiAgICByZXR1cm4gZGVjb3JhdG9yCgpkZWYgbG9nX2Vycm9ycyhmdW5jOiBDYWxsYWJsZSkgLT4gQ2FsbGFibGU6CiAgICAiIiJEZWNvcmF0b3IgdGhhdCBsb2dzIGVycm9ycyB0byBhIGZpbGUgd2hlbiBhIGZ1bmN0aW9uIHJhaXNlcyBhbiBleGNlcHRpb24gb3IgcmV0dXJucyBhbiBlcnJvciBtZXNzYWdlLgoKICAgIFRoaXMgZGVjb3JhdG9yIGNhcHR1cmVzIGJvdGggZXhjZXB0aW9ucyBhbmQgcmV0dXJuIHZhbHVlcyB0aGF0IGNvbnRhaW4gIkVycm9yIiBpbiB0aGUgZmlyc3QgZmV3IHdvcmRzLAogICAgbG9nZ2luZyB0aGVtIHRvICdlcnJvcl9sb2cudHh0JyBpbiB0aGUgc2FtZSBkaXJlY3RvcnkgYXMgdGhpcyBkZWNvcmF0b3JzIGZpbGUuCgogICAgUGFyYW1ldGVyczoKICAgICAgICBmdW5jIChDYWxsYWJsZSk6IFRoZSBmdW5jdGlvbiB0byB3cmFwIHdpdGggZXJyb3IgbG9nZ2luZyBjYXBhYmlsaXRpZXMKCiAgICBSZXR1cm5zOgogICAgICAgIENhbGxhYmxlOiBBIHdyYXBwZWQgdmVyc2lvbiBvZiB0aGUgZnVuY3Rpb24gdGhhdCBsb2dzIGVycm9ycwoKICAgIEV4YW1wbGU6CiAgICAgICAgQGxvZ19lcnJvcnMKICAgICAgICBkZWYgcmlza3lfZnVuY3Rpb24oKToKICAgICAgICAgICAgIyBBbnkgZXhjZXB0aW9ucyBvciAiRXJyb3IiIG1lc3NhZ2VzIHdpbGwgYmUgbG9nZ2VkCiAgICAgICAgICAgIHJldHVybiAiRXJyb3I6IFNvbWV0aGluZyB3ZW50IHdyb25nIgogICAgIiIiCgogICAgQHdyYXBzKGZ1bmMpCiAgICBkZWYgd3JhcHBlcigqYXJnczogQW55LCAqKmt3YXJnczogQW55KSAtPiBBbnk6CiAgICAgICAgdHJ5OgogICAgICAgICAgICByZXN1bHQgPSBmdW5jKCphcmdzLCAqKmt3YXJncykKCiAgICAgICAgICAgICMgQ2hlY2sgaWYgcmVzdWx0IGlzIGEgc3RyaW5nIHRoYXQgc3RhcnRzIHdpdGggIlRvb2wgRmFpbGVkOiIgKHRoZSBzcGVjaWZpYyBmb3JtYXQgZnJvbSBoYW5kbGVfZXJyb3JzKQogICAgICAgICAgICBpZiBpc2luc3RhbmNlKHJlc3VsdCwgc3RyKSBhbmQgcmVzdWx0LnN0YXJ0c3dpdGgoIlRvb2wgRmFpbGVkOiIpOgogICAgICAgICAgICAgICAgX2xvZ19lcnJvcl90b19maWxlKGZ1bmMuX19uYW1lX18sIGYiRnVuY3Rpb24gcmV0dXJuZWQgZXJyb3IgbWVzc2FnZToge3Jlc3VsdH0iLCBhcmdzLCBrd2FyZ3MpCgogICAgICAgICAgICByZXR1cm4gcmVzdWx0CgogICAgICAgIGV4Y2VwdCBFeGNlcHRpb24gYXMgZToKICAgICAgICAgICAgIyBMb2cgdGhlIGV4Y2VwdGlvbgogICAgICAgICAgICBlcnJvcl9tc2cgPSBmIkV4Y2VwdGlvbiBpbiB7ZnVuYy5fX25hbWVfX306IHtzdHIoZSl9XG5UcmFjZWJhY2s6XG57dHJhY2ViYWNrLmZvcm1hdF9leGMoKX0iCiAgICAgICAgICAgIF9sb2dfZXJyb3JfdG9fZmlsZShmdW5jLl9fbmFtZV9fLCBlcnJvcl9tc2csIGFyZ3MsIGt3YXJncykKICAgICAgICAgICAgIyBSZS1yYWlzZSB0aGUgZXhjZXB0aW9uCiAgICAgICAgICAgIHJhaXNlCgogICAgcmV0dXJuIHdyYXBwZXIKCkBsb2dfZXJyb3JzCkB0b29saWZ5KCkKZGVmIGV4ZWN1dGVfcG93ZXJzaGVsbChjb21tYW5kOiBzdHIsIG91dHB1dF9sZW5ndGhfbGltaXQ6IHN0cj0nMTAwMCcsIHRpbWVvdXQ6IHN0cj0nNjAnKSAtPiBzdHI6CiAgICAiIiIKICAgIEV4ZWN1dGVzIFBvd2VyU2hlbGwgY29tbWFuZHMgaW4gYSBzdGF0ZWZ1bCBlbnZpcm9ubWVudCB3aXRoIGF1dG9tYXRpYyBCT00gcmVtb3ZhbAoKICAgIFVzZSB3aGVuIHlvdSBuZWVkIHRvIHJ1biBQb3dlclNoZWxsIGNvbW1hbmRzIGFuZCBjYXB0dXJlIHRoZWlyIG91dHB1dC4gSWYKICAgIHlvdSBoYXZlIG90aGVyIHRvb2xzIGF2YWlsYWJsZSwgeW91IHNob3VsZCB1c2UgdGhpcyBhcyBhIGZhbGxiYWNrIHdoZW4gdGhlCiAgICBvdGhlciB0b29scyBmYWlsLiBDb2VyY2VzIHRvIHV0Zi04IChubyBCT00pLgoKICAgIFBvdGVudGlhbCB1c2UgY2FzZXM6CiAgICAtIGdpdCBjb21tYW5kcwogICAgLSBnaCBjbGkKICAgIC0gb3RoZXIgY2xpICh3aGljaCB5b3UgbWF5IG5lZWQgdG8gaW5zdGFsbCB1c2luZyB0aGlzIHRvb2wpCgogICAgUGFyYW1ldGVyczoKICAgIC0gY29tbWFuZCAoc3RyKTogUG93ZXJTaGVsbCBjb21tYW5kIHRvIGV4ZWN1dGUuCiAgICAtIG91dHB1dF9sZW5ndGhfbGltaXQgKGludCwgb3B0aW9uYWwpOiBNYXhpbXVtIG51bWJlciBvZiBsaW5lcyBpbiB0aGUgb3V0cHV0LgogICAgICBJZiBzZXQsIG91dHB1dCBleGNlZWRpbmcgdGhpcyBsaW1pdCB3aWxsIGJlIHRydW5jYXRlZC4gRGVmYXVsdCAyMDAuCgogICAgUmV0dXJuczoKICAgICAgICBzdHI6IFRoZSBjb21wbGV0ZSBvdXRwdXQgZnJvbSB0aGUgY29tbWFuZCBleGVjdXRpb24KICAgICIiIgogICAgbWFuYWdlciA9IFBvd2VyU2hlbGxNYW5hZ2VyLmdldF9pbnN0YW5jZSgpCiAgICBvdXRwdXQgPSAnJy5qb2luKG1hbmFnZXIuZXhlY3V0ZShjb21tYW5kLCBpbnQob3V0cHV0X2xlbmd0aF9saW1pdCksIGZsb2F0KHRpbWVvdXQpKSkKICAgIHJldHVybiBvdXRwdXSUjAlmaWxlX3BhdGiUaF2MCW5hbWVzcGFjZZRoYowfX19ydW50aW1lX18uYm90cy5kZXYuZGVjb3JhdG9yc5SFlFKUfZQoaDdoTGg2TmhZTmhbTmhcaF1oXmhfaGBoZGhlaGdoaGhqaDRobGhtaG9ocGhyaHNodWh2aHloemh8aDVofWh+aIBogWiCaINohGiFaIZoh2iIaBhoiWiKaI5oj2iQaJFokmiTaJRolWiWaJdomGiZaJpom2icaJ1ovmhGaE9oFGjDaMRoxWgVaMZox2jJaMpozGjNaM9o0GjSaNNo1WjWaNlo2mjcaN1o4GjhaOJo42jmaOdo6GjpaOpo62jsaO1o72jwaPiMEVBvd2VyU2hlbGxTZXNzaW9ulGjuajMBAACTlGoHAQAAaO5qBwEAAJOUjBRfZ2V0X2FjdGl2ZV9zZXNzaW9uc5Ro7mo2AQAAk5SMEV9wcm9jZXNzX2NvbW1hbmRzlGjuajgBAACTlIwiX3JlbW92ZV9ib21fZnJvbV9jdXJyZW50X2RpcmVjdG9yeZRo7mo6AQAAk5SMFXJlbW92ZV9ib21fZnJvbV9maWxlc5Ro7mo8AQAAk5SME2NoZWNrX2ZpbGVzX2Zvcl9ib22UaO5qPgEAAJOUdWKMCWNvZGVfaGFzaJSMIGMxN2NlZjY4ZWYxNzRmODc0MTRkNDhlYTE0NTUzYzFklHVidX2UKGg2agQBAABoUmofAQAAdYaUYmoXAQAAKGg3aExoNk5oWU5oWk5oW05oXGhdaF5oX2hgaGRoZWhnaGhoamg0aGxobWhvaHBocmhzaHVodmh5aHpofGg1aH1ofmiAaIFogmiDaIRohWiGaIdoiGgYaIloimiOaI9okGiRaJJok2iUaJVolmiXaJhomWiaaJtonGidaL5oRmhPaBRow2jEaMVoFWjGaMdoyWjKaMxozWjPaNBo0mjTaNVo1mjZaNpo3GjdaOBo4WjiaONo5mjnaOho6WjqaOto7GjtaO9o8Gj4ajMBAABqNAEAAGoHAQAAajUBAABqNgEAAGo3AQAAajgBAABqOQEAAGo6AQAAajsBAABqPAEAAGo9AQAAaj4BAABqPwEAAIwMX19idWlsdGluc19flGNidWlsdGlucwpfX2RpY3RfXwp1MIwIYnVpbHRpbnOUjAdnZXRhdHRylJOUjARkaWxslIwFX2RpbGyUk5SMCF9zZXRhdHRylGpFAQAAjAdzZXRhdHRylJOUh5RSlGj9jA1jZWxsX2NvbnRlbnRzlGocAQAAh5RSMGj7KGg3aExoNk5oWU5oWk5oW05oXGhdaF5oX2hgaGRoZWhnaGhoamg0aGxobWhvaHBocmhzaHVodmh5aHpofGg1aH1ofmiAaIFogmiDaIRohWiGaIdoiGgYaIloimiOaI9okGiRaJJok2iUaJVolmiXaJhomWiaaJtonGidaL5oRmhPaBRow2jEaMVoFWjGaMdoyWjKaMxozWjPaNBo0mjTaNVo1mjZaNpo3GjdaOBo4WjiaONo5mjnaOho6WjqaOto7GjtaO9o8Gj4ajMBAABqNAEAAGoHAQAAajUBAABqNgEAAGo3AQAAajgBAABqOQEAAGo6AQAAajsBAABqPAEAAGo9AQAAaj4BAABqPwEAAGpEAQAAY2J1aWx0aW5zCl9fZGljdF9fCnUwak8BAABo9WpQAQAAagABAACHlFIwaPEoaDdoTGg2TmhZTmhaTmhbTmhcaF1oXmhfaGBoZGhlaGdoaGhqaDRobGhtaG9ocGhyaHNodWh2aHloemh8aDVofWh+aIBogWiCaINohGiFaIZoh2iIaBhoiWiKaI5oj2iQaJFokmiTaJRolWiWaJdomGiZaJpom2icaJ1ovmhGaE9oFGjDaMRoxWgVaMZox2jJaMpozGjNaM9o0GjSaNNo1WjWaNlo2mjcaN1o4GjhaOJo42jmaOdo6GjpaOpo62jsaO1o72jwaPhqMwEAAGo0AQAAagcBAABqNQEAAGo2AQAAajcBAABqOAEAAGo5AQAAajoBAABqOwEAAGo8AQAAaj0BAABqPgEAAGo/AQAAakQBAABjYnVpbHRpbnMKX19kaWN0X18KdTBqMwEAAGo0AQAAagcBAABqNQEAAGo2AQAAajcBAABqOAEAAGo5AQAAajoBAABqOwEAAGo8AQAAaj0BAABqPgEAAGo/AQAAakQBAABjYnVpbHRpbnMKX19kaWN0X18KdTBoRmhPaBRow2jEaMVoFWjGaMdoyWjKaMxozWjPaNBo0mjTaNVo1mjZaNpo3GjdaOBo4WjiaONo5mjnaOho6WjqaOto7GjtaO9o8Gj4ajMBAABqNAEAAGoHAQAAajUBAABqNgEAAGo3AQAAajgBAABqOQEAAGo6AQAAajsBAABqPAEAAGo9AQAAaj4BAABqPwEAAGpEAQAAY2J1aWx0aW5zCl9fZGljdF9fCnUwLg==",
      "name": "toolify",
      "hash": "55073bf64a366fdb7151510ba60ea9dee1692554d98d61f1d8a7e665fc74bbdd",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "toolify"
      }
     },
     "_convert_tool_inputs": {
      "__helper_func__": true,
      "pickled": "gASVMAAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjBRfY29udmVydF90b29sX2lucHV0c5STlC4=",
      "name": "_convert_tool_inputs",
      "hash": "8bc4aba1c7d69350a812d8553b6a7ff0cd23ae5c818f3b9533752a69e91acf2e",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "_convert_tool_inputs"
      }
     },
     "_convert_string_to_type": {
      "__helper_func__": true,
      "pickled": "gASVMwAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjBdfY29udmVydF9zdHJpbmdfdG9fdHlwZZSTlC4=",
      "name": "_convert_string_to_type",
      "hash": "024e40c56cb46e6fe9f52fe7e6e64a3effc17736268ef31195596c6a6be4c311",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "_convert_string_to_type"
      }
     },
     "_convert_tool_output": {
      "__helper_func__": true,
      "pickled": "gASVMAAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjBRfY29udmVydF90b29sX291dHB1dJSTlC4=",
      "name": "_convert_tool_output",
      "hash": "6c85767d30db1c50646d25d2b954c893aed15774f97345f9b8c99674c59cf928",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "_convert_tool_output"
      }
     },
     "codecs": {
      "__module_type__": true,
      "name": "codecs",
      "spec": "codecs"
     },
     "glob": {
      "__module_type__": true,
      "name": "glob",
      "spec": "glob"
     },
     "subprocess": {
      "__module_type__": true,
      "name": "subprocess",
      "spec": "subprocess"
     },
     "threading": {
      "__module_type__": true,
      "name": "threading",
      "spec": "threading"
     },
     "time": {
      "__module_type__": true,
      "name": "time",
      "spec": "time"
     },
     "Empty": {
      "__imported_callable__": true,
      "pickled": "gASVFAAAAAAAAACMBl9xdWV1ZZSMBUVtcHR5lJOULg==",
      "name": "Empty",
      "hash": "6284f82b3f54af8203c859c56e48dcebb3e648a1baa98af9d71426fe28424740",
      "provenance": {
       "module": "_queue",
       "qualname": "Empty"
      }
     },
     "Queue": {
      "__imported_callable__": true,
      "pickled": "gASVEwAAAAAAAACMBXF1ZXVllIwFUXVldWWUk5Qu",
      "name": "Queue",
      "hash": "f1d061c6b70a1f20c274e8b7fc63ec8028e89818784dc92ac0031afe5e399464",
      "provenance": {
       "module": "queue",
       "qualname": "Queue"
      }
     },
     "Lock": {
      "__imported_callable__": true,
      "pickled": "gASVHQAAAAAAAACMB190aHJlYWSUjA1hbGxvY2F0ZV9sb2NrlJOULg==",
      "name": "allocate_lock",
      "hash": "f874808af7a5f917e94ce1343dc9223f4e60c24bea0f76a02f42fe229ac60456",
      "provenance": {
       "module": "_thread",
       "qualname": "allocate_lock"
      }
     },
     "Thread": {
      "__imported_callable__": true,
      "pickled": "gASVGAAAAAAAAACMCXRocmVhZGluZ5SMBlRocmVhZJSTlC4=",
      "name": "Thread",
      "hash": "8461d8a5aea74146052f63f89376db77d2a5fd35a009e5e8eb4a790561fc15a3",
      "provenance": {
       "module": "threading",
       "qualname": "Thread"
      }
     },
     "local": {
      "__imported_callable__": true,
      "pickled": "gASVFgAAAAAAAACMB190aHJlYWSUjAZfbG9jYWyUk5Qu",
      "name": "_local",
      "hash": "11743ff718f925f5d27c840777f78abc0b08f28e85dc248ff1efd09ee502b2ca",
      "provenance": {
       "module": "_thread",
       "qualname": "_local"
      }
     },
     "Dict": {
      "__imported_callable__": true,
      "pickled": "gASVEwAAAAAAAACMBnR5cGluZ5SMBERpY3SUk5Qu",
      "name": "Dict",
      "hash": "bec4a922065e1b0bf660dfda0816ae51f353562e1a25f08b06316760adc0d302",
      "provenance": {
       "module": "typing",
       "qualname": "Dict"
      }
     },
     "Generator": {
      "__imported_callable__": true,
      "pickled": "gASVGAAAAAAAAACMBnR5cGluZ5SMCUdlbmVyYXRvcpSTlC4=",
      "name": "Generator",
      "hash": "c48dcefd39a0f04631c2b8ed89e39f7b752b60ff51f1c86de7a870cfdf2bfc27",
      "provenance": {
       "module": "typing",
       "qualname": "Generator"
      }
     },
     "List": {
      "__imported_callable__": true,
      "pickled": "gASVEwAAAAAAAACMBnR5cGluZ5SMBExpc3SUk5Qu",
      "name": "List",
      "hash": "4177cb372f5ac2e670cf003d399db45b34278d8cf8801c6f8c592fc37176022f",
      "provenance": {
       "module": "typing",
       "qualname": "List"
      }
     },
     "BOMRemover": {
      "__imported_callable__": true,
      "pickled": "gASVLAAAAAAAAACMGWJvdHMudG9vbHMudGVybWluYWxfdG9vbHOUjApCT01SZW1vdmVylJOULg==",
      "name": "BOMRemover",
      "hash": "5ef3ce8a09ad3378ef1efe1e6e1aa4f625fe2f206ae2cb061dc909f4b9a5c48c",
      "provenance": {
       "module": "bots.tools.terminal_tools",
       "qualname": "BOMRemover"
      }
     },
     "execute_powershell": {
      "__imported_callable__": true,
      "pickled": "gASVLTsAAAAAAACMCmRpbGwuX2RpbGyUjBBfY3JlYXRlX2Z1bmN0aW9ulJOUKGgAjAxfY3JlYXRlX2NvZGWUk5QoQxQEAgIBEANCATYCBgIQAmABMAIK+5RLAEsASwBLBUsISx9CRgEAAJUBlwAJAAIAiQV8AGkAfAGkAY4BfQJ0AQAAAAAAAAAAfAJ0AgAAAAAAAAAAqwIAAAAAAAByLHwCagUAAAAAAAAAAAAAAAAAAAAAAABkAasBAAAAAAAAcht0BwAAAAAAAAAAiQVqCAAAAAAAAAAAAAAAAAAAAAAAAGQCfAKbAJ0CfAB8AasEAAAAAAAAAQB8AlMAIwB0CgAAAAAAAAAAJAByTn0DZAOJBWoIAAAAAAAAAAAAAAAAAAAAAAAAmwBkBHQDAAAAAAAAAAB8A6sBAAAAAAAAmwBkBXQMAAAAAAAAAABqDwAAAAAAAAAAAAAAAAAAAAAAAKsAAAAAAAAAmwCdBn0EdAcAAAAAAAAAAIkFaggAAAAAAAAAAAAAAAAAAAAAAAB8BHwAfAGrBAAAAAAAAAEAggBkAH0DfgN3AXcAeANZAHcBlChOjAxUb29sIEZhaWxlZDqUjCFGdW5jdGlvbiByZXR1cm5lZCBlcnJvciBtZXNzYWdlOiCUjA1FeGNlcHRpb24gaW4glIwCOiCUjAwKVHJhY2ViYWNrOgqUdJQojAppc2luc3RhbmNllIwDc3RylIwKc3RhcnRzd2l0aJSMEl9sb2dfZXJyb3JfdG9fZmlsZZSMCF9fbmFtZV9flIwJRXhjZXB0aW9ulIwJdHJhY2ViYWNrlIwKZm9ybWF0X2V4Y5R0lCiMBGFyZ3OUjAZrd2FyZ3OUjAZyZXN1bHSUjAFllIwJZXJyb3JfbXNnlHSUjAg8c3RyaW5nPpSMB3dyYXBwZXKUjBtsb2dfZXJyb3JzLjxsb2NhbHM+LndyYXBwZXKUS2JDoviAAPAEDgkS2RUZmDTQFSqgNtEVKohG9AYAEBqYJqQj1A8mqDbXKzzRKzy4XtQrTNwQIqA0pz2hPdA0VdBWXNBVXdAyXtBgZNBmbNQQbeATGYhN+OQPGPIABQkS4BonqASvDakNoH+wYrwTuFG7FrgIwA7MeddPY9FPY9NPZdBOZtAYZ4hJ3AwemHSffZl9qGm4FLh21AxG4AwR+/ALBQkS+pRDGYNBBUEJAMEJCUIgA8ESQQlCGwPCGwVCIAOUjARmdW5jlIWUKXSUUpR9lGgRjBNib3RzLmRldi5kZWNvcmF0b3JzlHOMEmV4ZWN1dGVfcG93ZXJzaGVsbJROaACMDF9jcmVhdGVfY2VsbJSTlE6FlFKUhZR0lFKUfZQojAtfX3dyYXBwZWRfX5RoAihoBChDLAQCAgIgAxADGAIQAwwCLgEiAhACFgEYAgoBCP8KBwwCGgIMAiIBEAEMAiL9lEsASwBLAEsKSwdLH0KuAQAAlQGXAAkAdAEAAAAAAAAAAIkKfAB8AasDAAAAAAAAXAIAAH0CfQMCAIkKfAJpAHwDpAGOAX0EdAMAAAAAAAAAAHwEqwEAAAAAAABTACMAdAQAAAAAAAAAACQAci99BWQBZAJsA20EfQYBAHQLAAAAAAAAAABkA3QNAAAAAAAAAAB8BasBAAAAAAAAmwCdAqsBAAAAAAAAfQcCAHwGfAerAQAAAAAAAGMCWQBkAH0FfgVTAGQAfQV+BXcBdA4AAAAAAAAAACQAclB9BXQNAAAAAAAAAAB8BasBAAAAAAAAfQhkBHwIdgByKWQFfAh2AHIlZAZ8CHYAciF0DwAAAAAAAAAAfAibAGQHnQKrAQAAAAAAAH0JZAFkAmwDbQR9BgEAAgB8BnwJqwEAAAAAAABjAlkAZAB9BX4FUwBkAWQCbANtBH0GAQACAHwGfAWrAQAAAAAAAGMCWQBkAH0FfgVTAGQAfQV+BXcBdBAAAAAAAAAAACQAchh9BWQBZAJsA20EfQYBAAIAfAZ8BasBAAAAAAAAYwJZAGQAfQV+BVMAZAB9BX4FdwF3AHgDWQB3AZQoTksAjA5fcHJvY2Vzc19lcnJvcpSFlIwcVG9vbCBleGVjdXRpb24gaW50ZXJydXB0ZWQ6IJSMB21pc3NpbmeUjAhyZXF1aXJlZJSMCGFyZ3VtZW50lFgyAQAACgrimqDvuI8gIFRoaXMgZXJyb3IgaXMgY29tbW9ubHkgY2F1c2VkIGJ5IGhpdHRpbmcgdGhlIG1heF90b2tlbnMgbGltaXQgYmVmb3JlIGNvbXBsZXRpbmcgdGhlIHRvb2wgY2FsbC4KVGhlIHJlc3BvbnNlIHdhcyB0cnVuY2F0ZWQgbWlkLXBhcmFtZXRlciwgbWFraW5nIGl0IGFwcGVhciB0aGF0IHJlcXVpcmVkIHBhcmFtZXRlcnMgYXJlIG1pc3NpbmcuClRvIGZpeCB0aGlzOiBXb3JrIGluIFNNQUxMRVIgQ0hVTktTLiBFZGl0IGZld2VyIGxpbmVzIGF0IGEgdGltZSwgb3IgYnJlYWsgeW91ciB0YXNrIGludG8gbXVsdGlwbGUgc3RlcHMulHSUKIwUX2NvbnZlcnRfdG9vbF9pbnB1dHOUjBRfY29udmVydF90b29sX291dHB1dJSMEUtleWJvYXJkSW50ZXJydXB0lIwSYm90cy51dGlscy5oZWxwZXJzlGgzjBJUb29sRXhlY3V0aW9uRXJyb3KUaA6MCVR5cGVFcnJvcpRoEnSUKGgWaBeMDmNvbnZlcnRlZF9hcmdzlIwQY29udmVydGVkX2t3YXJnc5RoGGgZaDOMCnRvb2xfZXJyb3KUaBqMDmVuaGFuY2VkX2Vycm9ylHSUaBxoHYwrdG9vbGlmeS48bG9jYWxzPi5kZWNvcmF0b3IuPGxvY2Fscz4ud3JhcHBlcpRLGEPt+IAA8AQoDSnkM0fIBMhk0FRa0zNb0RAwkA7QIDDxBgAaHph+0BlC0DFB0RlCkAb0BgAYLKhG0xcz0BAz+OQTJPIABg0y9QYAET7kHS/QMk7Mc9BTVMt2yGjQMFfTHViQCtkXJaBq0xcx1RAx++QTHPIAEg0t5BwfoAGbRpAJ2BMcoAnREymoarhJ0S5FyCrQWGHRSmHkJS7YGySYK/AABCZCAfAABBlDAfMDBiYWkE71DgAVQgHhGymoLtMbOdUUOeUUQeEbKagh0xss1RQs+9wTHPIAAw0p3RA94RcloGHTFyjVECj78AcDDSn6lENKgyImAKYJQxQDryRBGQPBEwFDFAPBGQxDFAPBJTJCMAPCFwFDFAPCHQ1CMAPCKgFDFAPCMAxDFAPCPA1DDwPDCQFDFAPDDwVDFAOUaCGFlCl0lFKUfZRoEWgmc2gnTmgpToWUUpSFlHSUUpR9lGgwaAIoaAQoQwYCFygBaAGUSwNLAEsASwVLCUsDQ5aXAHQAAAAAAAAAAABqAwAAAAAAAAAAAAAAAAAAAAAAAKsAAAAAAAAAfQNkAWoFAAAAAAAAAAAAAAAAAAAAAAAAfANqBwAAAAAAAAAAAAAAAAAAAAAAAHwAdAkAAAAAAAAAAHwBqwEAAAAAAAB0CwAAAAAAAAAAfAKrAQAAAAAAAKsDAAAAAAAAqwEAAAAAAAB9BHwEUwCUWM8CAAAKICAgIEV4ZWN1dGVzIFBvd2VyU2hlbGwgY29tbWFuZHMgaW4gYSBzdGF0ZWZ1bCBlbnZpcm9ubWVudCB3aXRoIGF1dG9tYXRpYyBCT00gcmVtb3ZhbAoKICAgIFVzZSB3aGVuIHlvdSBuZWVkIHRvIHJ1biBQb3dlclNoZWxsIGNvbW1hbmRzIGFuZCBjYXB0dXJlIHRoZWlyIG91dHB1dC4gSWYKICAgIHlvdSBoYXZlIG90aGVyIHRvb2xzIGF2YWlsYWJsZSwgeW91IHNob3VsZCB1c2UgdGhpcyBhcyBhIGZhbGxiYWNrIHdoZW4gdGhlCiAgICBvdGhlciB0b29scyBmYWlsLiBDb2VyY2VzIHRvIHV0Zi04IChubyBCT00pLgoKICAgIFBvdGVudGlhbCB1c2UgY2FzZXM6CiAgICAtIGdpdCBjb21tYW5kcwogICAgLSBnaCBjbGkKICAgIC0gb3RoZXIgY2xpICh3aGljaCB5b3UgbWF5IG5lZWQgdG8gaW5zdGFsbCB1c2luZyB0aGlzIHRvb2wpCgogICAgUGFyYW1ldGVyczoKICAgIC0gY29tbWFuZCAoc3RyKTogUG93ZXJTaGVsbCBjb21tYW5kIHRvIGV4ZWN1dGUuCiAgICAtIG91dHB1dF9sZW5ndGhfbGltaXQgKGludCwgb3B0aW9uYWwpOiBNYXhpbXVtIG51bWJlciBvZiBsaW5lcyBpbiB0aGUgb3V0cHV0LgogICAgICBJZiBzZXQsIG91dHB1dCBleGNlZWRpbmcgdGhpcyBsaW1pdCB3aWxsIGJlIHRydW5jYXRlZC4gRGVmYXVsdCAyMDAuCgogICAgUmV0dXJuczoKICAgICAgICBzdHI6IFRoZSBjb21wbGV0ZSBvdXRwdXQgZnJvbSB0aGUgY29tbWFuZCBleGVjdXRpb24KICAgIJSMAJSGlCiMEVBvd2VyU2hlbGxNYW5hZ2VylIwMZ2V0X2luc3RhbmNllIwEam9pbpSMB2V4ZWN1dGWUjANpbnSUjAVmbG9hdJR0lCiMB2NvbW1hbmSUjBNvdXRwdXRfbGVuZ3RoX2xpbWl0lIwHdGltZW91dJSMB21hbmFnZXKUjAZvdXRwdXSUdJRoHGgnaCdLdkM8gAD0LgAPINcOLNEOLNMOLoBH2A0Pj1eJV5BXl1+RX6BXrGPQMkXTLkbMBchnyw7TFVfTDViARtgLEYBNlEMAlCkpdJRSlH2UaBFoJnNoJ4wEMTAwMJSMAjYwlIaUTnSUUpR9lH2UKIwHX19kb2NfX5RoVowPX19hbm5vdGF0aW9uc19flH2UKGhgaACMCl9sb2FkX3R5cGWUk5RoDoWUUpRoYWh4aGJoeIwGcmV0dXJulGh4dXWGlGJzfZQoaHJoVmhzaHR1hpRijBJfX21vZHVsZV9jb250ZXh0X1+UjBRib3RzLmZvdW5kYXRpb24uYmFzZZSMDU1vZHVsZUNvbnRleHSUk5QpgZR9lCiMBG5hbWWUjCJkeW5hbWljX21vZHVsZV8yNjEzMzI4ODczMDc4MzI3OTc3lIwGc291cmNllFgBFgAAZGVmIHRvb2xpZnkoZGVzY3JpcHRpb246IHN0ciA9IE5vbmUpOgogICAgIiIiCiAgICBDb252ZXJ0IGFueSBmdW5jdGlvbiBpbnRvIGEgYm90IHRvb2wgd2l0aCBzdHJpbmctaW4sIHN0cmluZy1vdXQgaW50ZXJmYWNlLgoKICAgIC0gQ29udmVydHMgc3RyaW5nIGlucHV0cyB0byBwcm9wZXIgdHlwZXMgdXNpbmcgdHlwZSBoaW50cwogICAgLSBFbnN1cmVzIHN0cmluZyBvdXRwdXQgKEpTT04gZm9yIGNvbXBsZXggdHlwZXMpCiAgICAtIFdyYXBzIGluIGVycm9yIGhhbmRsaW5nIChyZXR1cm5zIGVycm9yIHN0cmluZ3MsIG5ldmVyIHJhaXNlcykKICAgIC0gRW5oYW5jZXMgZG9jc3RyaW5nIGlmIGRlc2NyaXB0aW9uIHByb3ZpZGVkCgogICAgQXJnczoKICAgICAgICBkZXNjcmlwdGlvbiAoc3RyLCBvcHRpb25hbCk6IE92ZXJyaWRlIHRoZSBmdW5jdGlvbidzIGRvY3N0cmluZwoKICAgIEV4YW1wbGU6CiAgICAgICAgQHRvb2xpZnkoKQogICAgICAgIGRlZiBhZGRfbnVtYmVycyh4OiBpbnQsIHk6IGludCA9IDApIC0+IGludDoKICAgICAgICAgICAgcmV0dXJuIHggKyB5CgogICAgICAgIEB0b29saWZ5KCJDYWxjdWxhdGUgdGhlIGFyZWEgb2YgYSBjaXJjbGUiKQogICAgICAgIGRlZiBhcmVhKHJhZGl1czogZmxvYXQpIC0+IGZsb2F0OgogICAgICAgICAgICByZXR1cm4gMy4xNDE1OSAqIHJhZGl1cyAqIHJhZGl1cwogICAgIiIiCgogICAgZGVmIGRlY29yYXRvcihmdW5jKToKICAgICAgICBAZnVuY3Rvb2xzLndyYXBzKGZ1bmMpCiAgICAgICAgZGVmIHdyYXBwZXIoKmFyZ3MsICoqa3dhcmdzKToKICAgICAgICAgICAgdHJ5OgogICAgICAgICAgICAgICAgIyBDb252ZXJ0IHN0cmluZyBpbnB1dHMgdG8gcHJvcGVyIHR5cGVzIHVzaW5nIHR5cGUgaGludHMKICAgICAgICAgICAgICAgIGNvbnZlcnRlZF9hcmdzLCBjb252ZXJ0ZWRfa3dhcmdzID0gX2NvbnZlcnRfdG9vbF9pbnB1dHMoZnVuYywgYXJncywga3dhcmdzKQoKICAgICAgICAgICAgICAgICMgQ2FsbCBvcmlnaW5hbCBmdW5jdGlvbgogICAgICAgICAgICAgICAgcmVzdWx0ID0gZnVuYygqY29udmVydGVkX2FyZ3MsICoqY29udmVydGVkX2t3YXJncykKCiAgICAgICAgICAgICAgICAjIENvbnZlcnQgcmVzdWx0IHRvIHN0cmluZwogICAgICAgICAgICAgICAgcmV0dXJuIF9jb252ZXJ0X3Rvb2xfb3V0cHV0KHJlc3VsdCkKCiAgICAgICAgICAgIGV4Y2VwdCBLZXlib2FyZEludGVycnVwdCBhcyBlOgogICAgICAgICAgICAgICAgIyBDb252ZXJ0IEtleWJvYXJkSW50ZXJydXB0IHRvIFRvb2xFeGVjdXRpb25FcnJvciB0byBwcmV2ZW50IGl0IGZyb20KICAgICAgICAgICAgICAgICMgYnViYmxpbmcgdXAgdG8gQ0xJIGFuZCBiZWluZyB0cmVhdGVkIGFzIHVzZXIgQ3RybCtDCiAgICAgICAgICAgICAgICBmcm9tIGJvdHMudXRpbHMuaGVscGVycyBpbXBvcnQgX3Byb2Nlc3NfZXJyb3IKCiAgICAgICAgICAgICAgICB0b29sX2Vycm9yID0gVG9vbEV4ZWN1dGlvbkVycm9yKGYiVG9vbCBleGVjdXRpb24gaW50ZXJydXB0ZWQ6IHtzdHIoZSl9IikKICAgICAgICAgICAgICAgIHJldHVybiBfcHJvY2Vzc19lcnJvcih0b29sX2Vycm9yKQoKICAgICAgICAgICAgZXhjZXB0IFR5cGVFcnJvciBhcyBlOgogICAgICAgICAgICAgICAgIyBDaGVjayBpZiB0aGlzIGlzIGEgbWlzc2luZyByZXF1aXJlZCBhcmd1bWVudCBlcnJvcgogICAgICAgICAgICAgICAgZXJyb3JfbXNnID0gc3RyKGUpCiAgICAgICAgICAgICAgICBpZiAibWlzc2luZyIgaW4gZXJyb3JfbXNnIGFuZCAicmVxdWlyZWQiIGluIGVycm9yX21zZyBhbmQgImFyZ3VtZW50IiBpbiBlcnJvcl9tc2c6CiAgICAgICAgICAgICAgICAgICAgIyBBZGQgc3BlY2lhbCBtZXNzYWdlIGZvciBvdXRwdXQgdG9rZW4gbGltaXRhdGlvbgogICAgICAgICAgICAgICAgICAgIGVuaGFuY2VkX2Vycm9yID0gVHlwZUVycm9yKAogICAgICAgICAgICAgICAgICAgICAgICBmIntlcnJvcl9tc2d9XG5cbiIKICAgICAgICAgICAgICAgICAgICAgICAgZiLimqDvuI8gIFRoaXMgZXJyb3IgaXMgY29tbW9ubHkgY2F1c2VkIGJ5IGhpdHRpbmcgdGhlIG1heF90b2tlbnMgbGltaXQgYmVmb3JlIGNvbXBsZXRpbmcgdGhlIHRvb2wgY2FsbC5cbiIKICAgICAgICAgICAgICAgICAgICAgICAgZiJUaGUgcmVzcG9uc2Ugd2FzIHRydW5jYXRlZCBtaWQtcGFyYW1ldGVyLCBtYWtpbmcgaXQgYXBwZWFyIHRoYXQgcmVxdWlyZWQgcGFyYW1ldGVycyBhcmUgbWlzc2luZy5cbiIKICAgICAgICAgICAgICAgICAgICAgICAgZiJUbyBmaXggdGhpczogV29yayBpbiBTTUFMTEVSIENIVU5LUy4gRWRpdCBmZXdlciBsaW5lcyBhdCBhIHRpbWUsICIKICAgICAgICAgICAgICAgICAgICAgICAgZiJvciBicmVhayB5b3VyIHRhc2sgaW50byBtdWx0aXBsZSBzdGVwcy4iCiAgICAgICAgICAgICAgICAgICAgKQogICAgICAgICAgICAgICAgICAgIGZyb20gYm90cy51dGlscy5oZWxwZXJzIGltcG9ydCBfcHJvY2Vzc19lcnJvcgoKICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3Byb2Nlc3NfZXJyb3IoZW5oYW5jZWRfZXJyb3IpCiAgICAgICAgICAgICAgICBlbHNlOgogICAgICAgICAgICAgICAgICAgIGZyb20gYm90cy51dGlscy5oZWxwZXJzIGltcG9ydCBfcHJvY2Vzc19lcnJvcgoKICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3Byb2Nlc3NfZXJyb3IoZSkKICAgICAgICAgICAgZXhjZXB0IEV4Y2VwdGlvbiBhcyBlOgogICAgICAgICAgICAgICAgZnJvbSBib3RzLnV0aWxzLmhlbHBlcnMgaW1wb3J0IF9wcm9jZXNzX2Vycm9yCgogICAgICAgICAgICAgICAgcmV0dXJuIF9wcm9jZXNzX2Vycm9yKGUpCgogICAgICAgICMgVXBkYXRlIGRvY3N0cmluZyBpZiBkZXNjcmlwdGlvbiBwcm92aWRlZAogICAgICAgIGlmIGRlc2NyaXB0aW9uOgogICAgICAgICAgICB3cmFwcGVyLl9fZG9jX18gPSBkZXNjcmlwdGlvbgogICAgICAgIGVsaWYgbm90IHdyYXBwZXIuX19kb2NfXzoKICAgICAgICAgICAgIyBHZW5lcmF0ZSBtaW5pbWFsIGRvY3N0cmluZyBmcm9tIGZ1bmN0aW9uIG5hbWUKICAgICAgICAgICAgd3JhcHBlci5fX2RvY19fID0gZiJFeGVjdXRlIHtmdW5jLl9fbmFtZV9fLnJlcGxhY2UoJ18nLCAnICcpfSIKCiAgICAgICAgcmV0dXJuIHdyYXBwZXIKCiAgICByZXR1cm4gZGVjb3JhdG9yCgpkZWYgbG9nX2Vycm9ycyhmdW5jOiBDYWxsYWJsZSkgLT4gQ2FsbGFibGU6CiAgICAiIiJEZWNvcmF0b3IgdGhhdCBsb2dzIGVycm9ycyB0byBhIGZpbGUgd2hlbiBhIGZ1bmN0aW9uIHJhaXNlcyBhbiBleGNlcHRpb24gb3IgcmV0dXJucyBhbiBlcnJvciBtZXNzYWdlLgoKICAgIFRoaXMgZGVjb3JhdG9yIGNhcHR1cmVzIGJvdGggZXhjZXB0aW9ucyBhbmQgcmV0dXJuIHZhbHVlcyB0aGF0IGNvbnRhaW4gIkVycm9yIiBpbiB0aGUgZmlyc3QgZmV3IHdvcmRzLAogICAgbG9nZ2luZyB0aGVtIHRvICdlcnJvcl9sb2cudHh0JyBpbiB0aGUgc2FtZSBkaXJlY3RvcnkgYXMgdGhpcyBkZWNvcmF0b3JzIGZpbGUuCgogICAgUGFyYW1ldGVyczoKICAgICAgICBmdW5jIChDYWxsYWJsZSk6IFRoZSBmdW5jdGlvbiB0byB3cmFwIHdpdGggZXJyb3IgbG9nZ2luZyBjYXBhYmlsaXRpZXMKCiAgICBSZXR1cm5zOgogICAgICAgIENhbGxhYmxlOiBBIHdyYXBwZWQgdmVyc2lvbiBvZiB0aGUgZnVuY3Rpb24gdGhhdCBsb2dzIGVycm9ycwoKICAgIEV4YW1wbGU6CiAgICAgICAgQGxvZ19lcnJvcnMKICAgICAgICBkZWYgcmlza3lfZnVuY3Rpb24oKToKICAgICAgICAgICAgIyBBbnkgZXhjZXB0aW9ucyBvciAiRXJyb3IiIG1lc3NhZ2VzIHdpbGwgYmUgbG9nZ2VkCiAgICAgICAgICAgIHJldHVybiAiRXJyb3I6IFNvbWV0aGluZyB3ZW50IHdyb25nIgogICAgIiIiCgogICAgQHdyYXBzKGZ1bmMpCiAgICBkZWYgd3JhcHBlcigqYXJnczogQW55LCAqKmt3YXJnczogQW55KSAtPiBBbnk6CiAgICAgICAgdHJ5OgogICAgICAgICAgICByZXN1bHQgPSBmdW5jKCphcmdzLCAqKmt3YXJncykKCiAgICAgICAgICAgICMgQ2hlY2sgaWYgcmVzdWx0IGlzIGEgc3RyaW5nIHRoYXQgc3RhcnRzIHdpdGggIlRvb2wgRmFpbGVkOiIgKHRoZSBzcGVjaWZpYyBmb3JtYXQgZnJvbSBoYW5kbGVfZXJyb3JzKQogICAgICAgICAgICBpZiBpc2luc3RhbmNlKHJlc3VsdCwgc3RyKSBhbmQgcmVzdWx0LnN0YXJ0c3dpdGgoIlRvb2wgRmFpbGVkOiIpOgogICAgICAgICAgICAgICAgX2xvZ19lcnJvcl90b19maWxlKGZ1bmMuX19uYW1lX18sIGYiRnVuY3Rpb24gcmV0dXJuZWQgZXJyb3IgbWVzc2FnZToge3Jlc3VsdH0iLCBhcmdzLCBrd2FyZ3MpCgogICAgICAgICAgICByZXR1cm4gcmVzdWx0CgogICAgICAgIGV4Y2VwdCBFeGNlcHRpb24gYXMgZToKICAgICAgICAgICAgIyBMb2cgdGhlIGV4Y2VwdGlvbgogICAgICAgICAgICBlcnJvcl9tc2cgPSBmIkV4Y2VwdGlvbiBpbiB7ZnVuYy5fX25hbWVfX306IHtzdHIoZSl9XG5UcmFjZWJhY2s6XG57dHJhY2ViYWNrLmZvcm1hdF9leGMoKX0iCiAgICAgICAgICAgIF9sb2dfZXJyb3JfdG9fZmlsZShmdW5jLl9fbmFtZV9fLCBlcnJvcl9tc2csIGFyZ3MsIGt3YXJncykKICAgICAgICAgICAgIyBSZS1yYWlzZSB0aGUgZXhjZXB0aW9uCiAgICAgICAgICAgIHJhaXNlCgogICAgcmV0dXJuIHdyYXBwZXIKCkBsb2dfZXJyb3JzCkB0b29saWZ5KCkKZGVmIGV4ZWN1dGVfcG93ZXJzaGVsbChjb21tYW5kOiBzdHIsIG91dHB1dF9sZW5ndGhfbGltaXQ6IHN0cj0nMTAwMCcsIHRpbWVvdXQ6IHN0cj0nNjAnKSAtPiBzdHI6CiAgICAiIiIKICAgIEV4ZWN1dGVzIFBvd2VyU2hlbGwgY29tbWFuZHMgaW4gYSBzdGF0ZWZ1bCBlbnZpcm9ubWVudCB3aXRoIGF1dG9tYXRpYyBCT00gcmVtb3ZhbAoKICAgIFVzZSB3aGVuIHlvdSBuZWVkIHRvIHJ1biBQb3dlclNoZWxsIGNvbW1hbmRzIGFuZCBjYXB0dXJlIHRoZWlyIG91dHB1dC4gSWYKICAgIHlvdSBoYXZlIG90aGVyIHRvb2xzIGF2YWlsYWJsZSwgeW91IHNob3VsZCB1c2UgdGhpcyBhcyBhIGZhbGxiYWNrIHdoZW4gdGhlCiAgICBvdGhlciB0b29scyBmYWlsLiBDb2VyY2VzIHRvIHV0Zi04IChubyBCT00pLgoKICAgIFBvdGVudGlhbCB1c2UgY2FzZXM6CiAgICAtIGdpdCBjb21tYW5kcwogICAgLSBnaCBjbGkKICAgIC0gb3RoZXIgY2xpICh3aGljaCB5b3UgbWF5IG5lZWQgdG8gaW5zdGFsbCB1c2luZyB0aGlzIHRvb2wpCgogICAgUGFyYW1ldGVyczoKICAgIC0gY29tbWFuZCAoc3RyKTogUG93ZXJTaGVsbCBjb21tYW5kIHRvIGV4ZWN1dGUuCiAgICAtIG91dHB1dF9sZW5ndGhfbGltaXQgKGludCwgb3B0aW9uYWwpOiBNYXhpbXVtIG51bWJlciBvZiBsaW5lcyBpbiB0aGUgb3V0cHV0LgogICAgICBJZiBzZXQsIG91dHB1dCBleGNlZWRpbmcgdGhpcyBsaW1pdCB3aWxsIGJlIHRydW5jYXRlZC4gRGVmYXVsdCAyMDAuCgogICAgUmV0dXJuczoKICAgICAgICBzdHI6IFRoZSBjb21wbGV0ZSBvdXRwdXQgZnJvbSB0aGUgY29tbWFuZCBleGVjdXRpb24KICAgICIiIgogICAgbWFuYWdlciA9IFBvd2VyU2hlbGxNYW5hZ2VyLmdldF9pbnN0YW5jZSgpCiAgICBvdXRwdXQgPSAnJy5qb2luKG1hbmFnZXIuZXhlY3V0ZShjb21tYW5kLCBpbnQob3V0cHV0X2xlbmd0aF9saW1pdCksIGZsb2F0KHRpbWVvdXQpKSkKICAgIHJldHVybiBvdXRwdXSUjAlmaWxlX3BhdGiUjCJkeW5hbWljX21vZHVsZV8zNDcyOTUxNzc1OTU1Mzg3ODExlIwJbmFtZXNwYWNllGgAjA5faW1wb3J0X21vZHVsZZSTlIwfX19ydW50aW1lX18uYm90cy5kZXYuZGVjb3JhdG9yc5SFlFKUfZQoaBFoJmhyTowLX19wYWNrYWdlX1+UTowIX19zcGVjX1+UTowIX19maWxlX1+UaIhoEGgmaBCTlGgTaItoE4WUUpSMA2FzdJRoi2iWhZRSlIwIZGF0ZXRpbWWUaItomYWUUpSMCWZ1bmN0b29sc5Roi2ichZRSlIwHaW5zcGVjdJRoi2ifhZRSlIwHbG9nZ2luZ5Roi2iihZRSlIwCb3OUaItopYWUUpSMA3N5c5Roi4wDc3lzlIWUUpSMCHRleHR3cmFwlGiLaKyFlFKUjAV3cmFwc5RonGivk5SMA0FueZSMBnR5cGluZ5RosZOUjAhDYWxsYWJsZZRosmi0k5SMCE9wdGlvbmFslGiyaLaTlIwEVHlwZZRosmi4k5SMEnJlbW92ZV9jb2RlX2Jsb2Nrc5RoPmi6k5RoP2gmaD+TlIwGbG9nZ2VylGiijAlnZXRMb2dnZXKUk5RoJoWUUpSMDE5vSFRUUEZpbHRlcpRoJmjCk5SMB2xhenlfZm6UaCZoxJOUjApsYXp5X2NsYXNzlGgmaMaTlIwMX2dldF9jb250ZXh0lGgmaMiTlIwRX2dldF9weV9pbnRlcmZhY2WUaCZoypOUjARsYXp5lGgmaMyTlIwOZGVidWdfb25fZXJyb3KUaCZozpOUjApsb2dfZXJyb3JzlGgCKGgEKEMKBBMUAS7/CAECEZRLAUsASwBLAksHSwNDVIcAlwB0AQAAAAAAAAAAiQCrAQAAAAAAAGQBdAIAAAAAAAAAAGQCdAIAAAAAAAAAAGQDdAIAAAAAAAAAAGYGiABmAWQEhAyrAAAAAAAAAH0BfAFTAJQoWIwCAABEZWNvcmF0b3IgdGhhdCBsb2dzIGVycm9ycyB0byBhIGZpbGUgd2hlbiBhIGZ1bmN0aW9uIHJhaXNlcyBhbiBleGNlcHRpb24gb3IgcmV0dXJucyBhbiBlcnJvciBtZXNzYWdlLgoKICAgIFRoaXMgZGVjb3JhdG9yIGNhcHR1cmVzIGJvdGggZXhjZXB0aW9ucyBhbmQgcmV0dXJuIHZhbHVlcyB0aGF0IGNvbnRhaW4gIkVycm9yIiBpbiB0aGUgZmlyc3QgZmV3IHdvcmRzLAogICAgbG9nZ2luZyB0aGVtIHRvICdlcnJvcl9sb2cudHh0JyBpbiB0aGUgc2FtZSBkaXJlY3RvcnkgYXMgdGhpcyBkZWNvcmF0b3JzIGZpbGUuCgogICAgUGFyYW1ldGVyczoKICAgICAgICBmdW5jIChDYWxsYWJsZSk6IFRoZSBmdW5jdGlvbiB0byB3cmFwIHdpdGggZXJyb3IgbG9nZ2luZyBjYXBhYmlsaXRpZXMKCiAgICBSZXR1cm5zOgogICAgICAgIENhbGxhYmxlOiBBIHdyYXBwZWQgdmVyc2lvbiBvZiB0aGUgZnVuY3Rpb24gdGhhdCBsb2dzIGVycm9ycwoKICAgIEV4YW1wbGU6CiAgICAgICAg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n2ihaKJopGilaKdoqGiraKxormivaLBosWizaLRotWi2aLdouGi5aLpou2g/aLxovWjBaMJow2jEaMVoxmjHaMhoyWjKaMtozGjNaM5oz2jQaN1o4moAAQAAaDtqBQEAAGoGAQAAagcBAABoPGoIAQAAagkBAABqCwEAAGoMAQAAag4BAABqDwEAAGoRAQAAahIBAABqFAEAAGoVAQAAahcBAABqGAEAAGobAQAAahwBAABqHgEAAGofAQAAaiIBAABqIwEAAGokAQAAaiUBAABqKAEAAGopAQAAaioBAABqKwEAAGosAQAAai0BAABqLgEAAGovAQAAajEBAABoJ2guajIBAABqMwEAAGhZajQBAABqNQEAAGo2AQAAajcBAABqOAEAAGo5AQAAajoBAABqOwEAAGo8AQAAaj0BAABqPgEAAGpEAQAAY2J1aWx0aW5zCl9fZGljdF9fCnUwaGooaBFoJmhyTmiQTmpDAQAATmiRTmiSaIhoEGiTaBNolWiWaJhomWibaJxonmifaKFoomikaKVop2ioaKtorGiuaK9osGixaLNotGi1aLZot2i4aLloumi7aD9ovGi9aMFowmjDaMRoxWjGaMdoyGjJaMpoy2jMaM1ozmjPaNBo3WjiagABAABoO2oFAQAAagYBAABqBwEAAGg8aggBAABqCQEAAGoLAQAAagwBAABqDgEAAGoPAQAAahEBAABqEgEAAGoUAQAAahUBAABqFwEAAGoYAQAAahsBAABqHAEAAGoeAQAAah8BAABqIgEAAGojAQAAaiQBAABqJQEAAGooAQAAaikBAABqKgEAAGorAQAAaiwBAABqLQEAAGouAQAAai8BAABqMQEAAGgnaC5qMgEAAGozAQAAaFlqNAEAAGo1AQAAajYBAABqNwEAAGo4AQAAajkBAABqOgEAAGo7AQAAajwBAABqPQEAAGo+AQAAakQBAABjYnVpbHRpbnMKX19kaWN0X18KdTCMCGJ1aWx0aW5zlIwHZ2V0YXR0cpSTlIwEZGlsbJSMBV9kaWxslJOUjAhfc2V0YXR0cpRqRQEAAIwHc2V0YXR0cpSTlIeUUpRoT4wNY2VsbF9jb250ZW50c5Rob4eUUjBoTShoEWgmaHJOaJBOakMBAABOaJFOaJJoiGgQaJNoE2iVaJZomGiZaJtonGieaJ9ooWiiaKRopWinaKhoq2isaK5or2iwaLFos2i0aLVotmi3aLhouWi6aLtoP2i8aL1owWjCaMNoxGjFaMZox2jIaMloymjLaMxozWjOaM9o0GjdaOJqAAEAAGg7agUBAABqBgEAAGoHAQAAaDxqCAEAAGoJAQAAagsBAABqDAEAAGoOAQAAag8BAABqEQEAAGoSAQAAahQBAABqFQEAAGoXAQAAahgBAABqGwEAAGocAQAAah4BAABqHwEAAGoiAQAAaiMBAABqJAEAAGolAQAAaigBAABqKQEAAGoqAQAAaisBAABqLAEAAGotAQAAai4BAABqLwEAAGoxAQAAaCdoLmoyAQAAajMBAABoWWo0AQAAajUBAABqNgEAAGo3AQAAajgBAABqOQEAAGo6AQAAajsBAABqPAEAAGo9AQAAaj4BAABqRAEAAGNidWlsdGlucwpfX2RpY3RfXwp1MGpPAQAAaCtqUAEAAGhSh5RSMGglKGgRaCZock5okE5qQwEAAE5okU5okmiIaBBok2gTaJVolmiYaJlom2icaJ5on2ihaKJopGilaKdoqGiraKxormivaLBosWizaLRotWi2aLdouGi5aLpou2g/aLxovWjBaMJow2jEaMVoxmjHaMhoyWjKaMtozGjNaM5oz2jQaN1o4moAAQAAaDtqBQEAAGoGAQAAagcBAABoPGoIAQAAagkBAABqCwEAAGoMAQAAag4BAABqDwEAAGoRAQAAahIBAABqFAEAAGoVAQAAahcBAABqGAEAAGobAQAAahwBAABqHgEAAGofAQAAaiIBAABqIwEAAGokAQAAaiUBAABqKAEAAGopAQAAaioBAABqKwEAAGosAQAAai0BAABqLgEAAGovAQAAajEBAABoJ2guajIBAABqMwEAAGhZajQBAABqNQEAAGo2AQAAajcBAABqOAEAAGo5AQAAajoBAABqOwEAAGo8AQAAaj0BAABqPgEAAGpEAQAAY2J1aWx0aW5zCl9fZGljdF9fCnUwLg==",
      "name": "execute_powershell",
      "hash": "4b7bac72d5520ed937a8999d1f29152efecc0fce928f1a5e3e52a8bc568845e2",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "execute_powershell"
      }
     },
     "PowerShellSession": {
      "__imported_callable__": true,
      "pickled": "gASVMwAAAAAAAACMGWJvdHMudG9vbHMudGVybWluYWxfdG9vbHOUjBFQb3dlclNoZWxsU2Vzc2lvbpSTlC4=",
      "name": "PowerShellSession",
      "hash": "01b8e3b21818613847d121569f5112ca97ec3f0e23973b48ce7347e31ea0564a",
      "provenance": {
       "module": "bots.tools.terminal_tools",
       "qualname": "PowerShellSession"
      }
     },
     "PowerShellManager": {
      "__imported_callable__": true,
      "pickled": "gASVMwAAAAAAAACMGWJvdHMudG9vbHMudGVybWluYWxfdG9vbHOUjBFQb3dlclNoZWxsTWFuYWdlcpSTlC4=",
      "name": "PowerShellManager",
      "hash": "9c68ed98b55f763326966f8046505821e36229db5f829c492a8fb442f900cf3c",
      "provenance": {
       "module": "bots.tools.terminal_tools",
       "qualname": "PowerShellManager"
      }
     },
     "_get_active_sessions": {
      "__helper_func__": true,
      "pickled": "gASVNgAAAAAAAACMGWJvdHMudG9vbHMudGVybWluYWxfdG9vbHOUjBRfZ2V0X2FjdGl2ZV9zZXNzaW9uc5STlC4=",
      "name": "_get_active_sessions",
      "hash": "3ab2939a085c40e73b2a10b5cfffaf6e1ed00a03c7cb9b8c565c95c8d08645bc",
      "provenance": {
       "module": "bots.tools.terminal_tools",
       "qualname": "_get_active_sessions"
      }
     },
     "_process_commands": {
      "__helper_func__": true,
      "pickled": "gASVMwAAAAAAAACMGWJvdHMudG9vbHMudGVybWluYWxfdG9vbHOUjBFfcHJvY2Vzc19jb21tYW5kc5STlC4=",
      "name": "_process_commands",
      "hash": "2690bcad3722d1896b7b850a99929494103a5cd09f59017f465096b15c0f2ce8",
      "provenance": {
       "module": "bots.tools.terminal_tools",
       "qualname": "_process_commands"
      }
     },
     "_remove_bom_from_current_directory": {
      "__helper_func__": true,
      "pickled": "gASVRAAAAAAAAACMGWJvdHMudG9vbHMudGVybWluYWxfdG9vbHOUjCJfcmVtb3ZlX2JvbV9mcm9tX2N1cnJlbnRfZGlyZWN0b3J5lJOULg==",
      "name": "_remove_bom_from_current_directory",
      "hash": "a824aea21f6b54fd11cda7a4eec45cb0d83b7e3c27f1ffb7b173a6d39da0dc55",
      "provenance": {
       "module": "bots.tools.terminal_tools",
       "qualname": "_remove_bom_from_current_directory"
      }
     },
     "remove_bom_from_files": {
      "__imported_callable__": true,
      "pickled": "gASVNwAAAAAAAACMGWJvdHMudG9vbHMudGVybWluYWxfdG9vbHOUjBVyZW1vdmVfYm9tX2Zyb21fZmlsZXOUk5Qu",
      "name": "remove_bom_from_files",
      "hash": "b0082fc2b63a07e22593be3efe748bf549969cd7ba7bccd4437409274ced1f77",
      "provenance": {
       "module": "bots.tools.terminal_tools",
       "qualname": "remove_bom_from_files"
      }
     },
     "check_files_for_bom": {
      "__imported_callable__": true,
      "pickled": "gASVNQAAAAAAAACMGWJvdHMudG9vbHMudGVybWluYWxfdG9vbHOUjBNjaGVja19maWxlc19mb3JfYm9tlJOULg==",
      "name": "check_files_for_bom",
      "hash": "0912378a8c57a516719b202caf37d8be02ff69fe9a28578e48e0b0001be8dc92",
      "provenance": {
       "module": "bots.tools.terminal_tools",
       "qualname": "check_files_for_bom"
      }
     }
    }
   },
   "dynamic_module_-1285900034110763988": {
    "name": "dynamic_module_-734266969691794093",
    "source": "from bots.utils.helpers import _process_error\n\ndef toolify(description: str = None):\n    \"\"\"\n    Convert any function into a bot tool with string-in, string-out interface.\n\n    - Converts string inputs to proper types using type hints\n    - Ensures string output (JSON for complex types)\n    - Wraps in error handling (returns error strings, never raises)\n    - Enhances docstring if description provided\n\n    Args:\n        description (str, optional): Override the function's docstring\n\n    Example:\n        @toolify()\n        def add_numbers(x: int, y: int = 0) -> int:\n            return x + y\n\n        @toolify(\"Calculate the area of a circle\")\n        def area(radius: float) -> float:\n            return 3.14159 * radius * radius\n    \"\"\"\n\n    def decorator(func):\n        @functools.wraps(func)\n        def wrapper(*args, **kwargs):\n            try:\n                # Convert string inputs to proper types using type hints\n                converted_args, converted_kwargs = _convert_tool_inputs(func, args, kwargs)\n\n                # Call original function\n                result = func(*converted_args, **converted_kwargs)\n\n                # Convert result to string\n                return _convert_tool_output(result)\n\n            except KeyboardInterrupt as e:\n                # Convert KeyboardInterrupt to ToolExecutionError to prevent it from\n                # bubbling up to CLI and being treated as user Ctrl+C\n\n                tool_error = ToolExecutionError(f\"Tool execution interrupted: {str(e)}\")\n                return _process_error(tool_error)\n\n            except TypeError as e:\n                # Check if this is a missing required argument error\n                error_msg = str(e)\n                if \"missing\" in error_msg and \"required\" in error_msg and \"argument\" in error_msg:\n                    # Add special message for output token limitation\n                    enhanced_error = TypeError(\n                        f\"{error_msg}\\n\\n\"\n                        f\"\u26a0\ufe0f  This error is commonly caused by hitting the max_tokens limit before completing the tool call.\\n\"\n                        f\"The response was truncated mid-parameter, making it appear that required parameters are missing.\\n\"\n                        f\"To fix this: Work in SMALLER CHUNKS. Edit fewer lines at a time, \"\n                        f\"or break your task into multiple steps.\"\n                    )\n\n                    return _process_error(enhanced_error)\n                else:\n\n                    return _process_error(e)\n            except Exception as e:\n\n                return _process_error(e)\n\n        # Update docstring if description provided\n        if description:\n            wrapper.__doc__ = description\n        elif not wrapper.__doc__:\n            # Generate minimal docstring from function name\n            wrapper.__doc__ = f\"Execute {func.__name__.replace('_', ' ')}\"\n\n        return wrapper\n\n    return decorator\n\n@toolify()\ndef execute_python(code: str, timeout: int=300) -> str:\n    \"\"\"\n    Executes python code in a stateless environment with cross-platform\n    timeout handling.\n    Parameters:\n    - code (str): Syntactically correct python code\n    - timeout (int): Maximum execution time in seconds (default: 300)\n    Returns stdout or an error message.\n    cost: varies\n    \"\"\"\n\n    def create_wrapper_ast():\n        wrapper_code = textwrap.dedent('\\n            import os\\n            import sys\\n            import traceback\\n            import time\\n            sys.path.append(os.path.dirname(os.path.dirname(\\n                os.path.abspath(__file__))))\\n            if sys.platform == \\'win32\\':\\n                import codecs\\n                sys.stdout = codecs.getwriter(\\'utf-8\\')(\\n                    sys.stdout.buffer, \\'strict\\')\\n                sys.stderr = codecs.getwriter(\\'utf-8\\')(\\n                    sys.stderr.buffer, \\'strict\\')\\n            def main():\\n                pass  # Placeholder for user code\\n            if __name__ == \\'__main__\\':\\n                try:\\n                    main()\\n                except Exception as error:\\n                    print(f\"An error occurred: {str(error)}\", file=sys.stderr)\\n                    traceback.print_exc(file=sys.stderr)\\n                    sys.exit(1)\\n            ')\n        return ast.parse(wrapper_code)\n\n    def insert_code_into_wrapper(wrapper_ast, code_ast, timeout_value):\n\n        def is_main_func(node):\n            return isinstance(node, ast.FunctionDef) and node.name == 'main'\n        nodes = wrapper_ast.body\n        main_func = next((node for node in nodes if is_main_func(node)))\n        main_func.body = code_ast.body\n        return wrapper_ast\n    if not isinstance(timeout, int) or timeout <= 0:\n        raise ValueError('Timeout must be a positive integer')\n    clean_code = textwrap.dedent(code).strip()\n    code_ast = ast.parse(clean_code)\n    wrapper_ast = create_wrapper_ast()\n    combined_ast = insert_code_into_wrapper(wrapper_ast, code_ast, timeout)\n    final_code = _py_ast_to_source(combined_ast)\n    temp_file_name = os.path.join(tempfile.gettempdir(), _get_unique_filename('temp_script', 'py'))\n    with open(temp_file_name, 'w', encoding='utf-8') as temp_file:\n        temp_file.write(final_code)\n        temp_file.flush()\n        os.fsync(temp_file.fileno())\n    env = os.environ.copy()\n    env['PYTHONIOENCODING'] = 'utf-8'\n    process = subprocess.Popen(['python', temp_file_name], stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, encoding='utf-8', creationflags=subprocess.CREATE_NO_WINDOW if os.name == 'nt' else 0, env=env)\n    stdout, stderr = process.communicate(timeout=timeout)\n    if os.path.exists(temp_file_name):\n        os.remove(temp_file_name)\n    if process.returncode != 0:\n        return stderr or 'Process failed with no error message'\n    return stdout + stderr\n\ndef _get_unique_filename(base_name, extension=''):\n    \"\"\"Generate a unique filename using process ID and timestamp.\"\"\"\n    timestamp = int(time.time() * 1000)\n    pid = os.getpid()\n    if extension and (not extension.startswith('.')):\n        extension = '.' + extension\n    return f'{base_name}_{pid}_{timestamp}{extension}'",
    "file_path": "dynamic_module_-1285900034110763988",
    "code_hash": "7e43ec6046f9ffdfd26df51982410922",
    "globals": {
     "_convert_tool_inputs": {
      "__helper_func__": true,
      "pickled": "gASVMAAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjBRfY29udmVydF90b29sX2lucHV0c5STlC4=",
      "name": "_convert_tool_inputs",
      "hash": "8bc4aba1c7d69350a812d8553b6a7ff0cd23ae5c818f3b9533752a69e91acf2e",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "_convert_tool_inputs"
      }
     },
     "_convert_tool_output": {
      "__helper_func__": true,
      "pickled": "gASVMAAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjBRfY29udmVydF90b29sX291dHB1dJSTlC4=",
      "name": "_convert_tool_output",
      "hash": "6c85767d30db1c50646d25d2b954c893aed15774f97345f9b8c99674c59cf928",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "_convert_tool_output"
      }
     },
     "ToolExecutionError": {
      "__imported_callable__": true,
      "pickled": "gASVLgAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjBJUb29sRXhlY3V0aW9uRXJyb3KUk5Qu",
      "name": "ToolExecutionError",
      "hash": "e3f136f46cc3014d1b1a8ac6716adb9da7db1dd83f2ed8529e090d97ae0db998",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "ToolExecutionError"
      }
     },
     "ast": {
      "__module_type__": true,
      "name": "ast",
      "spec": "ast"
     },
     "datetime": {
      "__module_type__": true,
      "name": "datetime",
      "spec": "datetime"
     },
     "functools": {
      "__module_type__": true,
      "name": "functools",
      "spec": "functools"
     },
     "inspect": {
      "__module_type__": true,
      "name": "inspect",
      "spec": "inspect"
     },
     "logging": {
      "__module_type__": true,
      "name": "logging",
      "spec": "logging"
     },
     "os": {
      "__module_type__": true,
      "name": "os",
      "spec": "os"
     },
     "sys": {
      "__module_type__": true,
      "name": "sys",
      "spec": "sys"
     },
     "textwrap": {
      "__module_type__": true,
      "name": "textwrap",
      "spec": "textwrap"
     },
     "traceback": {
      "__module_type__": true,
      "name": "traceback",
      "spec": "traceback"
     },
     "wraps": {
      "__imported_callable__": true,
      "pickled": "gASVFwAAAAAAAACMCWZ1bmN0b29sc5SMBXdyYXBzlJOULg==",
      "name": "wraps",
      "hash": "4c7c8f91a978a903bce2515f7fe83cb09b7074259dabad02b312209312f718ed",
      "provenance": {
       "module": "functools",
       "qualname": "wraps"
      }
     },
     "Any": {
      "__imported_callable__": true,
      "pickled": "gASVEgAAAAAAAACMBnR5cGluZ5SMA0FueZSTlC4=",
      "name": "Any",
      "hash": "fbf19bc6bf716a555ce7094664e2bc898734e4acfc2cd6d9ee399edef2e5c02b",
      "provenance": {
       "module": "typing",
       "qualname": "Any"
      }
     },
     "Callable": {
      "__imported_callable__": true,
      "pickled": "gASVFwAAAAAAAACMBnR5cGluZ5SMCENhbGxhYmxllJOULg==",
      "name": "Callable",
      "hash": "17cf7f09b805961290dccb95aa11199df32c246cb879f355ffa1a31d6285edad",
      "provenance": {
       "module": "typing",
       "qualname": "Callable"
      }
     },
     "Optional": {
      "__imported_callable__": true,
      "pickled": "gASVFwAAAAAAAACMBnR5cGluZ5SMCE9wdGlvbmFslJOULg==",
      "name": "Optional",
      "hash": "d69b63c158dd563d1537447d9d3a68afdda0efb70794ab11c234d01e2e593e56",
      "provenance": {
       "module": "typing",
       "qualname": "Optional"
      }
     },
     "Type": {
      "__imported_callable__": true,
      "pickled": "gASVEwAAAAAAAACMBnR5cGluZ5SMBFR5cGWUk5Qu",
      "name": "Type",
      "hash": "9e98fdb991d3addb0aad6e13cd94b21998f5d97e9f30b15f9c697afe5cde1832",
      "provenance": {
       "module": "typing",
       "qualname": "Type"
      }
     },
     "remove_code_blocks": {
      "__imported_callable__": true,
      "pickled": "gASVLQAAAAAAAACMEmJvdHMudXRpbHMuaGVscGVyc5SMEnJlbW92ZV9jb2RlX2Jsb2Nrc5STlC4=",
      "name": "remove_code_blocks",
      "hash": "44524fda389310a2a28f80da99409efd110baefaa9ea50345d092a634c89fc1d",
      "provenance": {
       "module": "bots.utils.helpers",
       "qualname": "remove_code_blocks"
      }
     },
     "NoHTTPFilter": {
      "__imported_callable__": true,
      "pickled": "gASVKAAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjAxOb0hUVFBGaWx0ZXKUk5Qu",
      "name": "NoHTTPFilter",
      "hash": "9f920bc687c51afef3dea517f9b64393473ed37dac3fda0cedd01a655b483a52",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "NoHTTPFilter"
      }
     },
     "lazy_fn": {
      "__imported_callable__": true,
      "pickled": "gASVIwAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjAdsYXp5X2ZulJOULg==",
      "name": "lazy_fn",
      "hash": "a1737e2cf8adde594f0dd0b3f17ffaad4c126dcf16906e82cb07f18c13d8b7a2",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "lazy_fn"
      }
     },
     "lazy_class": {
      "__imported_callable__": true,
      "pickled": "gASVJgAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjApsYXp5X2NsYXNzlJOULg==",
      "name": "lazy_class",
      "hash": "d1883fc4e7eb2d64f47b4e90b4b6b69d0c5be0d0e3175787058ad631d122e4c6",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "lazy_class"
      }
     },
     "_get_context": {
      "__helper_func__": true,
      "pickled": "gASVKAAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjAxfZ2V0X2NvbnRleHSUk5Qu",
      "name": "_get_context",
      "hash": "979ef249cdc1f76f4020d948ffc352f7c667afb0d89f221770156eebd7717c7a",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "_get_context"
      }
     },
     "_get_py_interface": {
      "__helper_func__": true,
      "pickled": "gASVLQAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjBFfZ2V0X3B5X2ludGVyZmFjZZSTlC4=",
      "name": "_get_py_interface",
      "hash": "d45b0506fb8815e8d9c3a9217b0ca101dac4fb9f51c8546285cf68a95ab027e7",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "_get_py_interface"
      }
     },
     "lazy": {
      "__imported_callable__": true,
      "pickled": "gASVIAAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjARsYXp5lJOULg==",
      "name": "lazy",
      "hash": "6e25446d8765ac65a5518c01582ddf52784eb90c51d57e224c94823d5b7c55cd",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "lazy"
      }
     },
     "debug_on_error": {
      "__imported_callable__": true,
      "pickled": "gASVKgAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjA5kZWJ1Z19vbl9lcnJvcpSTlC4=",
      "name": "debug_on_error",
      "hash": "06d89d594519c41c1dae666437441d4fd4aeeea959f1c905694940a50ae4ddfe",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "debug_on_error"
      }
     },
     "log_errors": {
      "__imported_callable__": true,
      "pickled": "gASVJgAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjApsb2dfZXJyb3JzlJOULg==",
      "name": "log_errors",
      "hash": "f9446c0ae11aa5bb7726b83da744e8dc707a91edc91085abbca1cefd1897d829",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "log_errors"
      }
     },
     "toolify": {
      "__imported_callable__": true,
      "pickled": "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lE50lFKUfZR9lChoNmjXaFJ9lChqOQEAAGhXaiEBAABoVWi1hZRSlIwGcmV0dXJulGhXdXWGlGKMEl9fbW9kdWxlX2NvbnRleHRfX5SMFGJvdHMuZm91bmRhdGlvbi5iYXNllIwNTW9kdWxlQ29udGV4dJSTlCmBlH2UKGjuaEyMBnNvdXJjZZRY8hgAAGRlZiB0b29saWZ5KGRlc2NyaXB0aW9uOiBzdHIgPSBOb25lKToKICAgICIiIgogICAgQ29udmVydCBhbnkgZnVuY3Rpb24gaW50byBhIGJvdCB0b29sIHdpdGggc3RyaW5nLWluLCBzdHJpbmctb3V0IGludGVyZmFjZS4KCiAgICAtIENvbnZlcnRzIHN0cmluZyBpbnB1dHMgdG8gcHJvcGVyIHR5cGVzIHVzaW5nIHR5cGUgaGludHMKICAgIC0gRW5zdXJlcyBzdHJpbmcgb3V0cHV0IChKU09OIGZvciBjb21wbGV4IHR5cGVzKQogICAgLSBXcmFwcyBpbiBlcnJvciBoYW5kbGluZyAocmV0dXJucyBlcnJvciBzdHJpbmdzLCBuZXZlciByYWlzZXMpCiAgICAtIEVuaGFuY2VzIGRvY3N0cmluZyBpZiBkZXNjcmlwdGlvbiBwcm92aWRlZAoKICAgIEFyZ3M6CiAgICAgICAgZGVzY3JpcHRpb24gKHN0ciwgb3B0aW9uYWwpOiBPdmVycmlkZSB0aGUgZnVuY3Rpb24ncyBkb2NzdHJpbmcKCiAgICBFeGFtcGxlOgogICAgICAgIEB0b29saWZ5KCkKICAgICAgICBkZWYgYWRkX251bWJlcnMoeDogaW50LCB5OiBpbnQgPSAwKSAtPiBpbnQ6CiAgICAgICAgICAgIHJldHVybiB4ICsgeQoKICAgICAgICBAdG9vbGlmeSgiQ2FsY3VsYXRlIHRoZSBhcmVhIG9mIGEgY2lyY2xlIikKICAgICAgICBkZWYgYXJlYShyYWRpdXM6IGZsb2F0KSAtPiBmbG9hdDoKICAgICAgICAgICAgcmV0dXJuIDMuMTQxNTkgKiByYWRpdXMgKiByYWRpdXMKICAgICIiIgoKICAgIGRlZiBkZWNvcmF0b3IoZnVuYyk6CiAgICAgICAgQGZ1bmN0b29scy53cmFwcyhmdW5jKQogICAgICAgIGRlZiB3cmFwcGVyKCphcmdzLCAqKmt3YXJncyk6CiAgICAgICAgICAgIHRyeToKICAgICAgICAgICAgICAgICMgQ29udmVydCBzdHJpbmcgaW5wdXRzIHRvIHByb3BlciB0eXBlcyB1c2luZyB0eXBlIGhpbnRzCiAgICAgICAgICAgICAgICBjb252ZXJ0ZWRfYXJncywgY29udmVydGVkX2t3YXJncyA9IF9jb252ZXJ0X3Rvb2xfaW5wdXRzKGZ1bmMsIGFyZ3MsIGt3YXJncykKCiAgICAgICAgICAgICAgICAjIENhbGwgb3JpZ2luYWwgZnVuY3Rpb24KICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmMoKmNvbnZlcnRlZF9hcmdzLCAqKmNvbnZlcnRlZF9rd2FyZ3MpCgogICAgICAgICAgICAgICAgIyBDb252ZXJ0IHJlc3VsdCB0byBzdHJpbmcKICAgICAgICAgICAgICAgIHJldHVybiBfY29udmVydF90b29sX291dHB1dChyZXN1bHQpCgogICAgICAgICAgICBleGNlcHQgS2V5Ym9hcmRJbnRlcnJ1cHQgYXMgZToKICAgICAgICAgICAgICAgICMgQ29udmVydCBLZXlib2FyZEludGVycnVwdCB0byBUb29sRXhlY3V0aW9uRXJyb3IgdG8gcHJldmVudCBpdCBmcm9tCiAgICAgICAgICAgICAgICAjIGJ1YmJsaW5nIHVwIHRvIENMSSBhbmQgYmVpbmcgdHJlYXRlZCBhcyB1c2VyIEN0cmwrQwogICAgICAgICAgICAgICAgZnJvbSBib3RzLnV0aWxzLmhlbHBlcnMgaW1wb3J0IF9wcm9jZXNzX2Vycm9yCgogICAgICAgICAgICAgICAgdG9vbF9lcnJvciA9IFRvb2xFeGVjdXRpb25FcnJvcihmIlRvb2wgZXhlY3V0aW9uIGludGVycnVwdGVkOiB7c3RyKGUpfSIpCiAgICAgICAgICAgICAgICByZXR1cm4gX3Byb2Nlc3NfZXJyb3IodG9vbF9lcnJvcikKCiAgICAgICAgICAgIGV4Y2VwdCBUeXBlRXJyb3IgYXMgZToKICAgICAgICAgICAgICAgICMgQ2hlY2sgaWYgdGhpcyBpcyBhIG1pc3NpbmcgcmVxdWlyZWQgYXJndW1lbnQgZXJyb3IKICAgICAgICAgICAgICAgIGVycm9yX21zZyA9IHN0cihlKQogICAgICAgICAgICAgICAgaWYgIm1pc3NpbmciIGluIGVycm9yX21zZyBhbmQgInJlcXVpcmVkIiBpbiBlcnJvcl9tc2cgYW5kICJhcmd1bWVudCIgaW4gZXJyb3JfbXNnOgogICAgICAgICAgICAgICAgICAgICMgQWRkIHNwZWNpYWwgbWVzc2FnZSBmb3Igb3V0cHV0IHRva2VuIGxpbWl0YXRpb24KICAgICAgICAgICAgICAgICAgICBlbmhhbmNlZF9lcnJvciA9IFR5cGVFcnJvcigKICAgICAgICAgICAgICAgICAgICAgICAgZiJ7ZXJyb3JfbXNnfVxuXG4iCiAgICAgICAgICAgICAgICAgICAgICAgIGYi4pqg77iPICBUaGlzIGVycm9yIGlzIGNvbW1vbmx5IGNhdXNlZCBieSBoaXR0aW5nIHRoZSBtYXhfdG9rZW5zIGxpbWl0IGJlZm9yZSBjb21wbGV0aW5nIHRoZSB0b29sIGNhbGwuXG4iCiAgICAgICAgICAgICAgICAgICAgICAgIGYiVGhlIHJlc3BvbnNlIHdhcyB0cnVuY2F0ZWQgbWlkLXBhcmFtZXRlciwgbWFraW5nIGl0IGFwcGVhciB0aGF0IHJlcXVpcmVkIHBhcmFtZXRlcnMgYXJlIG1pc3NpbmcuXG4iCiAgICAgICAgICAgICAgICAgICAgICAgIGYiVG8gZml4IHRoaXM6IFdvcmsgaW4gU01BTExFUiBDSFVOS1MuIEVkaXQgZmV3ZXIgbGluZXMgYXQgYSB0aW1lLCAiCiAgICAgICAgICAgICAgICAgICAgICAgIGYib3IgYnJlYWsgeW91ciB0YXNrIGludG8gbXVsdGlwbGUgc3RlcHMuIgogICAgICAgICAgICAgICAgICAgICkKICAgICAgICAgICAgICAgICAgICBmcm9tIGJvdHMudXRpbHMuaGVscGVycyBpbXBvcnQgX3Byb2Nlc3NfZXJyb3IKCiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9wcm9jZXNzX2Vycm9yKGVuaGFuY2VkX2Vycm9yKQogICAgICAgICAgICAgICAgZWxzZToKICAgICAgICAgICAgICAgICAgICBmcm9tIGJvdHMudXRpbHMuaGVscGVycyBpbXBvcnQgX3Byb2Nlc3NfZXJyb3IKCiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9wcm9jZXNzX2Vycm9yKGUpCiAgICAgICAgICAgIGV4Y2VwdCBFeGNlcHRpb24gYXMgZToKICAgICAgICAgICAgICAgIGZyb20gYm90cy51dGlscy5oZWxwZXJzIGltcG9ydCBfcHJvY2Vzc19lcnJvcgoKICAgICAgICAgICAgICAgIHJldHVybiBfcHJvY2Vzc19lcnJvcihlKQoKICAgICAgICAjIFVwZGF0ZSBkb2NzdHJpbmcgaWYgZGVzY3JpcHRpb24gcHJvdmlkZWQKICAgICAgICBpZiBkZXNjcmlwdGlvbjoKICAgICAgICAgICAgd3JhcHBlci5fX2RvY19fID0gZGVzY3JpcHRpb24KICAgICAgICBlbGlmIG5vdCB3cmFwcGVyLl9fZG9jX186CiAgICAgICAgICAgICMgR2VuZXJhdGUgbWluaW1hbCBkb2NzdHJpbmcgZnJvbSBmdW5jdGlvbiBuYW1lCiAgICAgICAgICAgIHdyYXBwZXIuX19kb2NfXyA9IGYiRXhlY3V0ZSB7ZnVuYy5fX25hbWVfXy5yZXBsYWNlKCdfJywgJyAnKX0iCgogICAgICAgIHJldHVybiB3cmFwcGVyCgogICAgcmV0dXJuIGRlY29yYXRvcgoKQHRvb2xpZnkoKQpkZWYgZXhlY3V0ZV9weXRob24oY29kZTogc3RyLCB0aW1lb3V0OiBpbnQ9MzAwKSAtPiBzdHI6CiAgICAiIiIKICAgIEV4ZWN1dGVzIHB5dGhvbiBjb2RlIGluIGEgc3RhdGVsZXNzIGVudmlyb25tZW50IHdpdGggY3Jvc3MtcGxhdGZvcm0KICAgIHRpbWVvdXQgaGFuZGxpbmcuCiAgICBQYXJhbWV0ZXJzOgogICAgLSBjb2RlIChzdHIpOiBTeW50YWN0aWNhbGx5IGNvcnJlY3QgcHl0aG9uIGNvZGUKICAgIC0gdGltZW91dCAoaW50KTogTWF4aW11bSBleGVjdXRpb24gdGltZSBpbiBzZWNvbmRzIChkZWZhdWx0OiAzMDApCiAgICBSZXR1cm5zIHN0ZG91dCBvciBhbiBlcnJvciBtZXNzYWdlLgogICAgY29zdDogdmFyaWVzCiAgICAiIiIKCiAgICBkZWYgY3JlYXRlX3dyYXBwZXJfYXN0KCk6CiAgICAgICAgd3JhcHBlcl9jb2RlID0gdGV4dHdyYXAuZGVkZW50KCdcbiAgICAgICAgICAgIGltcG9ydCBvc1xuICAgICAgICAgICAgaW1wb3J0IHN5c1xuICAgICAgICAgICAgaW1wb3J0IHRyYWNlYmFja1xuICAgICAgICAgICAgaW1wb3J0IHRpbWVcbiAgICAgICAgICAgIHN5cy5wYXRoLmFwcGVuZChvcy5wYXRoLmRpcm5hbWUob3MucGF0aC5kaXJuYW1lKFxuICAgICAgICAgICAgICAgIG9zLnBhdGguYWJzcGF0aChfX2ZpbGVfXykpKSlcbiAgICAgICAgICAgIGlmIHN5cy5wbGF0Zm9ybSA9PSBcJ3dpbjMyXCc6XG4gICAgICAgICAgICAgICAgaW1wb3J0IGNvZGVjc1xuICAgICAgICAgICAgICAgIHN5cy5zdGRvdXQgPSBjb2RlY3MuZ2V0d3JpdGVyKFwndXRmLThcJykoXG4gICAgICAgICAgICAgICAgICAgIHN5cy5zdGRvdXQuYnVmZmVyLCBcJ3N0cmljdFwnKVxuICAgICAgICAgICAgICAgIHN5cy5zdGRlcnIgPSBjb2RlY3MuZ2V0d3JpdGVyKFwndXRmLThcJykoXG4gICAgICAgICAgICAgICAgICAgIHN5cy5zdGRlcnIuYnVmZmVyLCBcJ3N0cmljdFwnKVxuICAgICAgICAgICAgZGVmIG1haW4oKTpcbiAgICAgICAgICAgICAgICBwYXNzICAjIFBsYWNlaG9sZGVyIGZvciB1c2VyIGNvZGVcbiAgICAgICAgICAgIGlmIF9fbmFtZV9fID09IFwnX19tYWluX19cJzpcbiAgICAgICAgICAgICAgICB0cnk6XG4gICAgICAgICAgICAgICAgICAgIG1haW4oKVxuICAgICAgICAgICAgICAgIGV4Y2VwdCBFeGNlcHRpb24gYXMgZXJyb3I6XG4gICAgICAgICAgICAgICAgICAgIHByaW50KGYiQW4gZXJyb3Igb2NjdXJyZWQ6IHtzdHIoZXJyb3IpfSIsIGZpbGU9c3lzLnN0ZGVycilcbiAgICAgICAgICAgICAgICAgICAgdHJhY2ViYWNrLnByaW50X2V4YyhmaWxlPXN5cy5zdGRlcnIpXG4gICAgICAgICAgICAgICAgICAgIHN5cy5leGl0KDEpXG4gICAgICAgICAgICAnKQogICAgICAgIHJldHVybiBhc3QucGFyc2Uod3JhcHBlcl9jb2RlKQoKICAgIGRlZiBpbnNlcnRfY29kZV9pbnRvX3dyYXBwZXIod3JhcHBlcl9hc3QsIGNvZGVfYXN0LCB0aW1lb3V0X3ZhbHVlKToKCiAgICAgICAgZGVmIGlzX21haW5fZnVuYyhub2RlKToKICAgICAgICAgICAgcmV0dXJuIGlzaW5zdGFuY2Uobm9kZSwgYXN0LkZ1bmN0aW9uRGVmKSBhbmQgbm9kZS5uYW1lID09ICdtYWluJwogICAgICAgIG5vZGVzID0gd3JhcHBlcl9hc3QuYm9keQogICAgICAgIG1haW5fZnVuYyA9IG5leHQoKG5vZGUgZm9yIG5vZGUgaW4gbm9kZXMgaWYgaXNfbWFpbl9mdW5jKG5vZGUpKSkKICAgICAgICBtYWluX2Z1bmMuYm9keSA9IGNvZGVfYXN0LmJvZHkKICAgICAgICByZXR1cm4gd3JhcHBlcl9hc3QKICAgIGlmIG5vdCBpc2luc3RhbmNlKHRpbWVvdXQsIGludCkgb3IgdGltZW91dCA8PSAwOgogICAgICAgIHJhaXNlIFZhbHVlRXJyb3IoJ1RpbWVvdXQgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXInKQogICAgY2xlYW5fY29kZSA9IHRleHR3cmFwLmRlZGVudChjb2RlKS5zdHJpcCgpCiAgICBjb2RlX2FzdCA9IGFzdC5wYXJzZShjbGVhbl9jb2RlKQogICAgd3JhcHBlcl9hc3QgPSBjcmVhdGVfd3JhcHBlcl9hc3QoKQogICAgY29tYmluZWRfYXN0ID0gaW5zZXJ0X2NvZGVfaW50b193cmFwcGVyKHdyYXBwZXJfYXN0LCBjb2RlX2FzdCwgdGltZW91dCkKICAgIGZpbmFsX2NvZGUgPSBfcHlfYXN0X3RvX3NvdXJjZShjb21iaW5lZF9hc3QpCiAgICB0ZW1wX2ZpbGVfbmFtZSA9IG9zLnBhdGguam9pbih0ZW1wZmlsZS5nZXR0ZW1wZGlyKCksIF9nZXRfdW5pcXVlX2ZpbGVuYW1lKCd0ZW1wX3NjcmlwdCcsICdweScpKQogICAgd2l0aCBvcGVuKHRlbXBfZmlsZV9uYW1lLCAndycsIGVuY29kaW5nPSd1dGYtOCcpIGFzIHRlbXBfZmlsZToKICAgICAgICB0ZW1wX2ZpbGUud3JpdGUoZmluYWxfY29kZSkKICAgICAgICB0ZW1wX2ZpbGUuZmx1c2goKQogICAgICAgIG9zLmZzeW5jKHRlbXBfZmlsZS5maWxlbm8oKSkKICAgIGVudiA9IG9zLmVudmlyb24uY29weSgpCiAgICBlbnZbJ1BZVEhPTklPRU5DT0RJTkcnXSA9ICd1dGYtOCcKICAgIHByb2Nlc3MgPSBzdWJwcm9jZXNzLlBvcGVuKFsncHl0aG9uJywgdGVtcF9maWxlX25hbWVdLCBzdGRvdXQ9c3VicHJvY2Vzcy5QSVBFLCBzdGRlcnI9c3VicHJvY2Vzcy5QSVBFLCB0ZXh0PVRydWUsIGVuY29kaW5nPSd1dGYtOCcsIGNyZWF0aW9uZmxhZ3M9c3VicHJvY2Vzcy5DUkVBVEVfTk9fV0lORE9XIGlmIG9zLm5hbWUgPT0gJ250JyBlbHNlIDAsIGVudj1lbnYpCiAgICBzdGRvdXQsIHN0ZGVyciA9IHByb2Nlc3MuY29tbXVuaWNhdGUodGltZW91dD10aW1lb3V0KQogICAgaWYgb3MucGF0aC5leGlzdHModGVtcF9maWxlX25hbWUpOgogICAgICAgIG9zLnJlbW92ZSh0ZW1wX2ZpbGVfbmFtZSkKICAgIGlmIHByb2Nlc3MucmV0dXJuY29kZSAhPSAwOgogICAgICAgIHJldHVybiBzdGRlcnIgb3IgJ1Byb2Nlc3MgZmFpbGVkIHdpdGggbm8gZXJyb3IgbWVzc2FnZScKICAgIHJldHVybiBzdGRvdXQgKyBzdGRlcnIKCmRlZiBfZ2V0X3VuaXF1ZV9maWxlbmFtZShiYXNlX25hbWUsIGV4dGVuc2lvbj0nJyk6CiAgICAiIiJHZW5lcmF0ZSBhIHVuaXF1ZSBmaWxlbmFtZSB1c2luZyBwcm9jZXNzIElEIGFuZCB0aW1lc3RhbXAuIiIiCiAgICB0aW1lc3RhbXAgPSBpbnQodGltZS50aW1lKCkgKiAxMDAwKQogICAgcGlkID0gb3MuZ2V0cGlkKCkKICAgIGlmIGV4dGVuc2lvbiBhbmQgKG5vdCBleHRlbnNpb24uc3RhcnRzd2l0aCgnLicpKToKICAgICAgICBleHRlbnNpb24gPSAnLicgKyBleHRlbnNpb24KICAgIHJldHVybiBmJ3tiYXNlX25hbWV9X3twaWR9X3t0aW1lc3RhbXB9e2V4dGVuc2lvbn0nlIwJZmlsZV9wYXRolGhdjAluYW1lc3BhY2WUaGSMLl9fcnVudGltZV9fLmR5bmFtaWNfbW9kdWxlXy03MzQyNjY5Njk2OTE3OTQwOTOUhZRSlH2UKGg3aExoNk5oWU5oW05oXGhdaBRoX2gVaGBoGGhhaGJoZmhnaGloNGhraGxobmhvaHFocmh0aHVoeGh5aHtofGh+aDVof2iAaIJog2iEaIVohmiHaIhoiWiKaItoj2iQaJFokmiTaJRolWiWaJdomGiZaJpom2icaJ1onmifaEZoT2igaKFoomijaKRopminaKloqmisaK1ormivaMVoymjSdWKMCWNvZGVfaGFzaJSMIGFjMjBjYzZjNjAxYjIxMmI2NjIyNTczOGZkM2YwZTU4lHVidX2UKGg2aNdoUmpLAQAAdYaUYmpFAQAAKGg3aExoNk5oWU5oWk5oW05oXGhdaBRoX2gVaGBoGGhhaGJoZmhnaGloNGhraGxobmhvaHFocmh0aHVoeGh5aHtofGh+aDVof2iAaIJog2iEaIVohmiHaIhoiWiKaItoj2iQaJFokmiTaJRolWiWaJdomGiZaJpom2icaJ1onmifaEZoT2igaKFoomijaKRopminaKloqmisaK1ormivaMVoymjSjAxfX2J1aWx0aW5zX1+UY2J1aWx0aW5zCl9fZGljdF9fCnUwjAhidWlsdGluc5SMB2dldGF0dHKUk5SMBGRpbGyUjAVfZGlsbJSTlIwIX3NldGF0dHKUamMBAACMB3NldGF0dHKUk5SHlFKUaM+MDWNlbGxfY29udGVudHOUakgBAACHlFIwaMsoaDdoTGg2TmhZTmhaTmhbTmhcaF1oFGhfaBVoYGgYaGFoYmhmaGdoaWg0aGtobGhuaG9ocWhyaHRodWh4aHloe2h8aH5oNWh/aIBogmiDaIRohWiGaIdoiGiJaIpoi2iPaJBokWiSaJNolGiVaJZol2iYaJlommibaJxonWieaJ9oRmhPaKBooWiiaKNopGimaKdoqWiqaKxorWiuaK9oxWjKaNJqYgEAAGNidWlsdGlucwpfX2RpY3RfXwp1MGpiAQAAY2J1aWx0aW5zCl9fZGljdF9fCnUwaMpo0mpiAQAAY2J1aWx0aW5zCl9fZGljdF9fCnUwLg==",
      "name": "toolify",
      "hash": "89e2ffcd6e8b3b71c61cc8de03ad4b592ee7e096199178ebda8a89a94b2f4e07",
      "provenance": {
       "module": "dynamic_module_-734266969691794093",
       "qualname": "toolify"
      }
     },
     "_convert_string_to_type": {
      "__helper_func__": true,
      "pickled": "gASVMwAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjBdfY29udmVydF9zdHJpbmdfdG9fdHlwZZSTlC4=",
      "name": "_convert_string_to_type",
      "hash": "024e40c56cb46e6fe9f52fe7e6e64a3effc17736268ef31195596c6a6be4c311",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "_convert_string_to_type"
      }
     },
     "_log_error_to_file": {
      "__helper_func__": true,
      "pickled": "gASVLgAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjBJfbG9nX2Vycm9yX3RvX2ZpbGWUk5Qu",
      "name": "_log_error_to_file",
      "hash": "c02546b672eb25afd5dc51ea7e1967cbb6fd264ca18ffd15c3cbeccebe4046ba",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "_log_error_to_file"
      }
     },
     "subprocess": {
      "__module_type__": true,
      "name": "subprocess",
      "spec": "subprocess"
     },
     "tempfile": {
      "__module_type__": true,
      "name": "tempfile",
      "spec": "tempfile"
     },
     "time": {
      "__module_type__": true,
      "name": "time",
      "spec": "time"
     },
     "_py_ast_to_source": {
      "__helper_func__": true,
      "pickled": "gASVLAAAAAAAAACMEmJvdHMudXRpbHMuaGVscGVyc5SMEV9weV9hc3RfdG9fc291cmNllJOULg==",
      "name": "_py_ast_to_source",
      "hash": "b4f03eb89ec6290dae99f96b4cbde39a5df78f3a58db9ae249d5cfe9d8d740c2",
      "provenance": {
       "module": "bots.utils.helpers",
       "qualname": "_py_ast_to_source"
      }
     },
     "execute_python": {
      "__imported_callable__": true,
      "pickled": "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aCxoLXNoLk0sAYWUTnSUUpR9lH2UKIwHX19kb2NfX5RoOowPX19hbm5vdGF0aW9uc19flH2UKGimaACMCl9sb2FkX3R5cGWUk5RoFIWUUpRoiGi8aIyFlFKUjAZyZXR1cm6UaL51dYaUYowSX19tb2R1bGVfY29udGV4dF9flIwUYm90cy5mb3VuZGF0aW9uLmJhc2WUjA1Nb2R1bGVDb250ZXh0lJOUKYGUfZQoaFRoLYwGc291cmNllFjyGAAAZGVmIHRvb2xpZnkoZGVzY3JpcHRpb246IHN0ciA9IE5vbmUpOgogICAgIiIiCiAgICBDb252ZXJ0IGFueSBmdW5jdGlvbiBpbnRvIGEgYm90IHRvb2wgd2l0aCBzdHJpbmctaW4sIHN0cmluZy1vdXQgaW50ZXJmYWNlLgoKICAgIC0gQ29udmVydHMgc3RyaW5nIGlucHV0cyB0byBwcm9wZXIgdHlwZXMgdXNpbmcgdHlwZSBoaW50cwogICAgLSBFbnN1cmVzIHN0cmluZyBvdXRwdXQgKEpTT04gZm9yIGNvbXBsZXggdHlwZXMpCiAgICAtIFdyYXBzIGluIGVycm9yIGhhbmRsaW5nIChyZXR1cm5zIGVycm9yIHN0cmluZ3MsIG5ldmVyIHJhaXNlcykKICAgIC0gRW5oYW5jZXMgZG9jc3RyaW5nIGlmIGRlc2NyaXB0aW9uIHByb3ZpZGVkCgogICAgQXJnczoKICAgICAgICBkZXNjcmlwdGlvbiAoc3RyLCBvcHRpb25hbCk6IE92ZXJyaWRlIHRoZSBmdW5jdGlvbidzIGRvY3N0cmluZwoKICAgIEV4YW1wbGU6CiAgICAgICAgQHRvb2xpZnkoKQogICAgICAgIGRlZiBhZGRfbnVtYmVycyh4OiBpbnQsIHk6IGludCA9IDApIC0+IGludDoKICAgICAgICAgICAgcmV0dXJuIHggKyB5CgogICAgICAgIEB0b29saWZ5KCJDYWxjdWxhdGUgdGhlIGFyZWEgb2YgYSBjaXJjbGUiKQogICAgICAgIGRlZiBhcmVhKHJhZGl1czogZmxvYXQpIC0+IGZsb2F0OgogICAgICAgICAgICByZXR1cm4gMy4xNDE1OSAqIHJhZGl1cyAqIHJhZGl1cwogICAgIiIiCgogICAgZGVmIGRlY29yYXRvcihmdW5jKToKICAgICAgICBAZnVuY3Rvb2xzLndyYXBzKGZ1bmMpCiAgICAgICAgZGVmIHdyYXBwZXIoKmFyZ3MsICoqa3dhcmdzKToKICAgICAgICAgICAgdHJ5OgogICAgICAgICAgICAgICAgIyBDb252ZXJ0IHN0cmluZyBpbnB1dHMgdG8gcHJvcGVyIHR5cGVzIHVzaW5nIHR5cGUgaGludHMKICAgICAgICAgICAgICAgIGNvbnZlcnRlZF9hcmdzLCBjb252ZXJ0ZWRfa3dhcmdzID0gX2NvbnZlcnRfdG9vbF9pbnB1dHMoZnVuYywgYXJncywga3dhcmdzKQoKICAgICAgICAgICAgICAgICMgQ2FsbCBvcmlnaW5hbCBmdW5jdGlvbgogICAgICAgICAgICAgICAgcmVzdWx0ID0gZnVuYygqY29udmVydGVkX2FyZ3MsICoqY29udmVydGVkX2t3YXJncykKCiAgICAgICAgICAgICAgICAjIENvbnZlcnQgcmVzdWx0IHRvIHN0cmluZwogICAgICAgICAgICAgICAgcmV0dXJuIF9jb252ZXJ0X3Rvb2xfb3V0cHV0KHJlc3VsdCkKCiAgICAgICAgICAgIGV4Y2VwdCBLZXlib2FyZEludGVycnVwdCBhcyBlOgogICAgICAgICAgICAgICAgIyBDb252ZXJ0IEtleWJvYXJkSW50ZXJydXB0IHRvIFRvb2xFeGVjdXRpb25FcnJvciB0byBwcmV2ZW50IGl0IGZyb20KICAgICAgICAgICAgICAgICMgYnViYmxpbmcgdXAgdG8gQ0xJIGFuZCBiZWluZyB0cmVhdGVkIGFzIHVzZXIgQ3RybCtDCiAgICAgICAgICAgICAgICBmcm9tIGJvdHMudXRpbHMuaGVscGVycyBpbXBvcnQgX3Byb2Nlc3NfZXJyb3IKCiAgICAgICAgICAgICAgICB0b29sX2Vycm9yID0gVG9vbEV4ZWN1dGlvbkVycm9yKGYiVG9vbCBleGVjdXRpb24gaW50ZXJydXB0ZWQ6IHtzdHIoZSl9IikKICAgICAgICAgICAgICAgIHJldHVybiBfcHJvY2Vzc19lcnJvcih0b29sX2Vycm9yKQoKICAgICAgICAgICAgZXhjZXB0IFR5cGVFcnJvciBhcyBlOgogICAgICAgICAgICAgICAgIyBDaGVjayBpZiB0aGlzIGlzIGEgbWlzc2luZyByZXF1aXJlZCBhcmd1bWVudCBlcnJvcgogICAgICAgICAgICAgICAgZXJyb3JfbXNnID0gc3RyKGUpCiAgICAgICAgICAgICAgICBpZiAibWlzc2luZyIgaW4gZXJyb3JfbXNnIGFuZCAicmVxdWlyZWQiIGluIGVycm9yX21zZyBhbmQgImFyZ3VtZW50IiBpbiBlcnJvcl9tc2c6CiAgICAgICAgICAgICAgICAgICAgIyBBZGQgc3BlY2lhbCBtZXNzYWdlIGZvciBvdXRwdXQgdG9rZW4gbGltaXRhdGlvbgogICAgICAgICAgICAgICAgICAgIGVuaGFuY2VkX2Vycm9yID0gVHlwZUVycm9yKAogICAgICAgICAgICAgICAgICAgICAgICBmIntlcnJvcl9tc2d9XG5cbiIKICAgICAgICAgICAgICAgICAgICAgICAgZiLimqDvuI8gIFRoaXMgZXJyb3IgaXMgY29tbW9ubHkgY2F1c2VkIGJ5IGhpdHRpbmcgdGhlIG1heF90b2tlbnMgbGltaXQgYmVmb3JlIGNvbXBsZXRpbmcgdGhlIHRvb2wgY2FsbC5cbiIKICAgICAgICAgICAgICAgICAgICAgICAgZiJUaGUgcmVzcG9uc2Ugd2FzIHRydW5jYXRlZCBtaWQtcGFyYW1ldGVyLCBtYWtpbmcgaXQgYXBwZWFyIHRoYXQgcmVxdWlyZWQgcGFyYW1ldGVycyBhcmUgbWlzc2luZy5cbiIKICAgICAgICAgICAgICAgICAgICAgICAgZiJUbyBmaXggdGhpczogV29yayBpbiBTTUFMTEVSIENIVU5LUy4gRWRpdCBmZXdlciBsaW5lcyBhdCBhIHRpbWUsICIKICAgICAgICAgICAgICAgICAgICAgICAgZiJvciBicmVhayB5b3VyIHRhc2sgaW50byBtdWx0aXBsZSBzdGVwcy4iCiAgICAgICAgICAgICAgICAgICAgKQogICAgICAgICAgICAgICAgICAgIGZyb20gYm90cy51dGlscy5oZWxwZXJzIGltcG9ydCBfcHJvY2Vzc19lcnJvcgoKICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3Byb2Nlc3NfZXJyb3IoZW5oYW5jZWRfZXJyb3IpCiAgICAgICAgICAgICAgICBlbHNlOgogICAgICAgICAgICAgICAgICAgIGZyb20gYm90cy51dGlscy5oZWxwZXJzIGltcG9ydCBfcHJvY2Vzc19lcnJvcgoKICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3Byb2Nlc3NfZXJyb3IoZSkKICAgICAgICAgICAgZXhjZXB0IEV4Y2VwdGlvbiBhcyBlOgogICAgICAgICAgICAgICAgZnJvbSBib3RzLnV0aWxzLmhlbHBlcnMgaW1wb3J0IF9wcm9jZXNzX2Vycm9yCgogICAgICAgICAgICAgICAgcmV0dXJuIF9wcm9jZXNzX2Vycm9yKGUpCgogICAgICAgICMgVXBkYXRlIGRvY3N0cmluZyBpZiBkZXNjcmlwdGlvbiBwcm92aWRlZAogICAgICAgIGlmIGRlc2NyaXB0aW9uOgogICAgICAgICAgICB3cmFwcGVyLl9fZG9jX18gPSBkZXNjcmlwdGlvbgogICAgICAgIGVsaWYgbm90IHdyYXBwZXIuX19kb2NfXzoKICAgICAgICAgICAgIyBHZW5lcmF0ZSBtaW5pbWFsIGRvY3N0cmluZyBmcm9tIGZ1bmN0aW9uIG5hbWUKICAgICAgICAgICAgd3JhcHBlci5fX2RvY19fID0gZiJFeGVjdXRlIHtmdW5jLl9fbmFtZV9fLnJlcGxhY2UoJ18nLCAnICcpfSIKCiAgICAgICAgcmV0dXJuIHdyYXBwZXIKCiAgICByZXR1cm4gZGVjb3JhdG9yCgpAdG9vbGlmeSgpCmRlZiBleGVjdXRlX3B5dGhvbihjb2RlOiBzdHIsIHRpbWVvdXQ6IGludD0zMDApIC0+IHN0cjoKICAgICIiIgogICAgRXhlY3V0ZXMgcHl0aG9uIGNvZGUgaW4gYSBzdGF0ZWxlc3MgZW52aXJvbm1lbnQgd2l0aCBjcm9zcy1wbGF0Zm9ybQogICAgdGltZW91dCBoYW5kbGluZy4KICAgIFBhcmFtZXRlcnM6CiAgICAtIGNvZGUgKHN0cik6IFN5bnRhY3RpY2FsbHkgY29ycmVjdCBweXRob24gY29kZQogICAgLSB0aW1lb3V0IChpbnQpOiBNYXhpbXVtIGV4ZWN1dGlvbiB0aW1lIGluIHNlY29uZHMgKGRlZmF1bHQ6IDMwMCkKICAgIFJldHVybnMgc3Rkb3V0IG9yIGFuIGVycm9yIG1lc3NhZ2UuCiAgICBjb3N0OiB2YXJpZXMKICAgICIiIgoKICAgIGRlZiBjcmVhdGVfd3JhcHBlcl9hc3QoKToKICAgICAgICB3cmFwcGVyX2NvZGUgPSB0ZXh0d3JhcC5kZWRlbnQoJ1xuICAgICAgICAgICAgaW1wb3J0IG9zXG4gICAgICAgICAgICBpbXBvcnQgc3lzXG4gICAgICAgICAgICBpbXBvcnQgdHJhY2ViYWNrXG4gICAgICAgICAgICBpbXBvcnQgdGltZVxuICAgICAgICAgICAgc3lzLnBhdGguYXBwZW5kKG9zLnBhdGguZGlybmFtZShvcy5wYXRoLmRpcm5hbWUoXG4gICAgICAgICAgICAgICAgb3MucGF0aC5hYnNwYXRoKF9fZmlsZV9fKSkpKVxuICAgICAgICAgICAgaWYgc3lzLnBsYXRmb3JtID09IFwnd2luMzJcJzpcbiAgICAgICAgICAgICAgICBpbXBvcnQgY29kZWNzXG4gICAgICAgICAgICAgICAgc3lzLnN0ZG91dCA9IGNvZGVjcy5nZXR3cml0ZXIoXCd1dGYtOFwnKShcbiAgICAgICAgICAgICAgICAgICAgc3lzLnN0ZG91dC5idWZmZXIsIFwnc3RyaWN0XCcpXG4gICAgICAgICAgICAgICAgc3lzLnN0ZGVyciA9IGNvZGVjcy5nZXR3cml0ZXIoXCd1dGYtOFwnKShcbiAgICAgICAgICAgICAgICAgICAgc3lzLnN0ZGVyci5idWZmZXIsIFwnc3RyaWN0XCcpXG4gICAgICAgICAgICBkZWYgbWFpbigpOlxuICAgICAgICAgICAgICAgIHBhc3MgICMgUGxhY2Vob2xkZXIgZm9yIHVzZXIgY29kZVxuICAgICAgICAgICAgaWYgX19uYW1lX18gPT0gXCdfX21haW5fX1wnOlxuICAgICAgICAgICAgICAgIHRyeTpcbiAgICAgICAgICAgICAgICAgICAgbWFpbigpXG4gICAgICAgICAgICAgICAgZXhjZXB0IEV4Y2VwdGlvbiBhcyBlcnJvcjpcbiAgICAgICAgICAgICAgICAgICAgcHJpbnQoZiJBbiBlcnJvciBvY2N1cnJlZDoge3N0cihlcnJvcil9IiwgZmlsZT1zeXMuc3RkZXJyKVxuICAgICAgICAgICAgICAgICAgICB0cmFjZWJhY2sucHJpbnRfZXhjKGZpbGU9c3lzLnN0ZGVycilcbiAgICAgICAgICAgICAgICAgICAgc3lzLmV4aXQoMSlcbiAgICAgICAgICAgICcpCiAgICAgICAgcmV0dXJuIGFzdC5wYXJzZSh3cmFwcGVyX2NvZGUpCgogICAgZGVmIGluc2VydF9jb2RlX2ludG9fd3JhcHBlcih3cmFwcGVyX2FzdCwgY29kZV9hc3QsIHRpbWVvdXRfdmFsdWUpOgoKICAgICAgICBkZWYgaXNfbWFpbl9mdW5jKG5vZGUpOgogICAgICAgICAgICByZXR1cm4gaXNpbnN0YW5jZShub2RlLCBhc3QuRnVuY3Rpb25EZWYpIGFuZCBub2RlLm5hbWUgPT0gJ21haW4nCiAgICAgICAgbm9kZXMgPSB3cmFwcGVyX2FzdC5ib2R5CiAgICAgICAgbWFpbl9mdW5jID0gbmV4dCgobm9kZSBmb3Igbm9kZSBpbiBub2RlcyBpZiBpc19tYWluX2Z1bmMobm9kZSkpKQogICAgICAgIG1haW5fZnVuYy5ib2R5ID0gY29kZV9hc3QuYm9keQogICAgICAgIHJldHVybiB3cmFwcGVyX2FzdAogICAgaWYgbm90IGlzaW5zdGFuY2UodGltZW91dCwgaW50KSBvciB0aW1lb3V0IDw9IDA6CiAgICAgICAgcmFpc2UgVmFsdWVFcnJvcignVGltZW91dCBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlcicpCiAgICBjbGVhbl9jb2RlID0gdGV4dHdyYXAuZGVkZW50KGNvZGUpLnN0cmlwKCkKICAgIGNvZGVfYXN0ID0gYXN0LnBhcnNlKGNsZWFuX2NvZGUpCiAgICB3cmFwcGVyX2FzdCA9IGNyZWF0ZV93cmFwcGVyX2FzdCgpCiAgICBjb21iaW5lZF9hc3QgPSBpbnNlcnRfY29kZV9pbnRvX3dyYXBwZXIod3JhcHBlcl9hc3QsIGNvZGVfYXN0LCB0aW1lb3V0KQogICAgZmluYWxfY29kZSA9IF9weV9hc3RfdG9fc291cmNlKGNvbWJpbmVkX2FzdCkKICAgIHRlbXBfZmlsZV9uYW1lID0gb3MucGF0aC5qb2luKHRlbXBmaWxlLmdldHRlbXBkaXIoKSwgX2dldF91bmlxdWVfZmlsZW5hbWUoJ3RlbXBfc2NyaXB0JywgJ3B5JykpCiAgICB3aXRoIG9wZW4odGVtcF9maWxlX25hbWUsICd3JywgZW5jb2Rpbmc9J3V0Zi04JykgYXMgdGVtcF9maWxlOgogICAgICAgIHRlbXBfZmlsZS53cml0ZShmaW5hbF9jb2RlKQogICAgICAgIHRlbXBfZmlsZS5mbHVzaCgpCiAgICAgICAgb3MuZnN5bmModGVtcF9maWxlLmZpbGVubygpKQogICAgZW52ID0gb3MuZW52aXJvbi5jb3B5KCkKICAgIGVudlsnUFlUSE9OSU9FTkNPRElORyddID0gJ3V0Zi04JwogICAgcHJvY2VzcyA9IHN1YnByb2Nlc3MuUG9wZW4oWydweXRob24nLCB0ZW1wX2ZpbGVfbmFtZV0sIHN0ZG91dD1zdWJwcm9jZXNzLlBJUEUsIHN0ZGVycj1zdWJwcm9jZXNzLlBJUEUsIHRleHQ9VHJ1ZSwgZW5jb2Rpbmc9J3V0Zi04JywgY3JlYXRpb25mbGFncz1zdWJwcm9jZXNzLkNSRUFURV9OT19XSU5ET1cgaWYgb3MubmFtZSA9PSAnbnQnIGVsc2UgMCwgZW52PWVudikKICAgIHN0ZG91dCwgc3RkZXJyID0gcHJvY2Vzcy5jb21tdW5pY2F0ZSh0aW1lb3V0PXRpbWVvdXQpCiAgICBpZiBvcy5wYXRoLmV4aXN0cyh0ZW1wX2ZpbGVfbmFtZSk6CiAgICAgICAgb3MucmVtb3ZlKHRlbXBfZmlsZV9uYW1lKQogICAgaWYgcHJvY2Vzcy5yZXR1cm5jb2RlICE9IDA6CiAgICAgICAgcmV0dXJuIHN0ZGVyciBvciAnUHJvY2VzcyBmYWlsZWQgd2l0aCBubyBlcnJvciBtZXNzYWdlJwogICAgcmV0dXJuIHN0ZG91dCArIHN0ZGVycgoKZGVmIF9nZXRfdW5pcXVlX2ZpbGVuYW1lKGJhc2VfbmFtZSwgZXh0ZW5zaW9uPScnKToKICAgICIiIkdlbmVyYXRlIGEgdW5pcXVlIGZpbGVuYW1lIHVzaW5nIHByb2Nlc3MgSUQgYW5kIHRpbWVzdGFtcC4iIiIKICAgIHRpbWVzdGFtcCA9IGludCh0aW1lLnRpbWUoKSAqIDEwMDApCiAgICBwaWQgPSBvcy5nZXRwaWQoKQogICAgaWYgZXh0ZW5zaW9uIGFuZCAobm90IGV4dGVuc2lvbi5zdGFydHN3aXRoKCcuJykpOgogICAgICAgIGV4dGVuc2lvbiA9ICcuJyArIGV4dGVuc2lvbgogICAgcmV0dXJuIGYne2Jhc2VfbmFtZX1fe3BpZH1fe3RpbWVzdGFtcH17ZXh0ZW5zaW9ufSeUjAlmaWxlX3BhdGiUjCNkeW5hbWljX21vZHVsZV8tMTI4NTkwMDAzNDExMDc2Mzk4OJSMCW5hbWVzcGFjZZRoAIwOX2ltcG9ydF9tb2R1bGWUk5SMLl9fcnVudGltZV9fLmR5bmFtaWNfbW9kdWxlXy03MzQyNjY5Njk2OTE3OTQwOTOUhZRSlH2UKGgsaC1ouE6MC19fcGFja2FnZV9flE6MCF9fc3BlY19flE6MCF9fZmlsZV9flGjMaA+ME2JvdHMuZGV2LmRlY29yYXRvcnOUaA+TlGgQaNdoEJOUaBNo12gTk5RoQWjPaEGFlFKUjAhkYXRldGltZZRoz2jdhZRSlIwJZnVuY3Rvb2xzlGjPaOCFlFKUjAdpbnNwZWN0lGjPaOOFlFKUjAdsb2dnaW5nlGjPaOaFlFKUaJBoz2iQhZRSlIwDc3lzlGjPjANzeXOUhZRSlGg/aM9oP4WUUpSMCXRyYWNlYmFja5Roz2jxhZRSlIwFd3JhcHOUaOBo9JOUjANBbnmUjAZ0eXBpbmeUaPaTlIwIQ2FsbGFibGWUaPdo+ZOUjAhPcHRpb25hbJRo92j7k5SMBFR5cGWUaPdo/ZOUjBJyZW1vdmVfY29kZV9ibG9ja3OUaBJo/5OUjAZsb2dnZXKUaOaMCWdldExvZ2dlcpSTlGjXhZRSlIwMTm9IVFRQRmlsdGVylGjXagYBAACTlIwHbGF6eV9mbpRo12oIAQAAk5SMCmxhenlfY2xhc3OUaNdqCgEAAJOUjAxfZ2V0X2NvbnRleHSUaNdqDAEAAJOUjBFfZ2V0X3B5X2ludGVyZmFjZZRo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",
      "name": "execute_python",
      "hash": "4da96c69f5b9ab277de1da7e8f0bf2c3d29d6deaabec6828899d836ae8469ff2",
      "provenance": {
       "module": "dynamic_module_-734266969691794093",
       "qualname": "execute_python"
      }
     }
    }
   },
   "dynamic_module_3913901117500357081": {
    "name": "dynamic_module_7571845853012171355",
    "source": "import copy\nimport threading\nfrom concurrent.futures import ThreadPoolExecutor, as_completed\nfrom bots.flows import functional_prompts as fp\nimport traceback\nfrom bots.flows.recombinators import recombinators as recomb\nfrom bots.utils.helpers import _process_error\nfrom typing import List, Optional\n\ndef toolify(description: str = None):\n    \"\"\"\n    Convert any function into a bot tool with string-in, string-out interface.\n\n    - Converts string inputs to proper types using type hints\n    - Ensures string output (JSON for complex types)\n    - Wraps in error handling (returns error strings, never raises)\n    - Enhances docstring if description provided\n\n    Args:\n        description (str, optional): Override the function's docstring\n\n    Example:\n        @toolify()\n        def add_numbers(x: int, y: int = 0) -> int:\n            return x + y\n\n        @toolify(\"Calculate the area of a circle\")\n        def area(radius: float) -> float:\n            return 3.14159 * radius * radius\n    \"\"\"\n\n    def decorator(func):\n        @functools.wraps(func)\n        def wrapper(*args, **kwargs):\n            try:\n                # Convert string inputs to proper types using type hints\n                converted_args, converted_kwargs = _convert_tool_inputs(func, args, kwargs)\n\n                # Call original function\n                result = func(*converted_args, **converted_kwargs)\n\n                # Convert result to string\n                return _convert_tool_output(result)\n\n            except KeyboardInterrupt as e:\n                # Convert KeyboardInterrupt to ToolExecutionError to prevent it from\n                # bubbling up to CLI and being treated as user Ctrl+C\n\n                tool_error = ToolExecutionError(f\"Tool execution interrupted: {str(e)}\")\n                return _process_error(tool_error)\n\n            except TypeError as e:\n                # Check if this is a missing required argument error\n                error_msg = str(e)\n                if \"missing\" in error_msg and \"required\" in error_msg and \"argument\" in error_msg:\n                    # Add special message for output token limitation\n                    enhanced_error = TypeError(\n                        f\"{error_msg}\\n\\n\"\n                        f\"\u26a0\ufe0f  This error is commonly caused by hitting the max_tokens limit before completing the tool call.\\n\"\n                        f\"The response was truncated mid-parameter, making it appear that required parameters are missing.\\n\"\n                        f\"To fix this: Work in SMALLER CHUNKS. Edit fewer lines at a time, \"\n                        f\"or break your task into multiple steps.\"\n                    )\n\n                    return _process_error(enhanced_error)\n                else:\n\n                    return _process_error(e)\n            except Exception as e:\n\n                return _process_error(e)\n\n        # Update docstring if description provided\n        if description:\n            wrapper.__doc__ = description\n        elif not wrapper.__doc__:\n            # Generate minimal docstring from function name\n            wrapper.__doc__ = f\"Execute {func.__name__.replace('_', ' ')}\"\n\n        return wrapper\n\n    return decorator\n\n@toolify()\ndef branch_self(self_prompts: str, allow_work: str='False', parallel: str='False', recombine: str='concatenate') -> str:\n    \"\"\"Create multiple conversation branches to explore different approaches or tackle separate tasks.\n\n    Creates isolated conversation branches using deepcopy:\n    1. Deepcopy current bot state (uses __getstate__/__setstate__ for proper serialization)\n    2. Execute each branch with independent bot instances\n    3. Stitch results back into main conversation tree\n\n    Note: Uses deepcopy with __getstate__/__setstate__ which leverages the hybrid\n    serialization strategy (source code + dill for helpers). See bots/foundation/tool_handling.md.\n\n    Args:\n        self_prompts (str): List of prompts as a string array, like ['task 1', 'task 2', 'task 3']\n                           Each prompt becomes a separate conversation branch\n        allow_work (str): 'True' to let each branch use tools and continue working until done\n                         'False' (default) for single-response branches\n        parallel (str): 'True' to let branches work in parallel, 'False' for sequential (default).\n        recombine (str): One of ('none', 'concatenate', 'llm_merge', 'llm_vote', 'llm_judge'), default 'concatenate'.\n                         Combines the final messages from each branch using that method.\n\n    Returns:\n        str: Success message with branch count, or error details if something went wrong\n    \"\"\"\n    bot = _get_calling_bot()\n    if not bot:\n        return 'Error: Could not find calling bot'\n    allow_work = allow_work.lower() == 'true'\n    parallel = parallel.lower() == 'true'\n    recombine = recombine.lower()\n    valid_recombine_options = ['none', 'concatenate', 'llm_judge', 'llm_vote', 'llm_merge']\n    if recombine not in valid_recombine_options:\n        return f'Error: Invalid recombine option. Valid: {valid_recombine_options}'\n    try:\n        message_list = _process_string_array(self_prompts)\n        if not message_list:\n            return 'Error: No valid messages provided'\n    except Exception as e:\n        return f'Error parsing prompts: {str(e)}'\n    prefixed_prompts = [f'(self-prompt): {prompt}' for prompt in message_list]\n    try:\n        original_node = bot.conversation\n        original_autosave = bot.autosave\n        bot.autosave = False\n        dummy_results_added = False\n        original_results = None\n        if original_node.tool_calls:\n            dummy_results = []\n            for tool_call in original_node.tool_calls:\n                if tool_call.get('name') == 'branch_self':\n                    dummy_result = bot.tool_handler.generate_response_schema(tool_call, 'Branching in progress...')\n                    dummy_results.append(dummy_result)\n            if dummy_results:\n                original_results = list(getattr(original_node, 'tool_results', []))\n                original_node._add_tool_results(dummy_results)\n                dummy_results_added = True\n        replies_lock = threading.Lock()\n\n        def execute_branch(prompt, parent_bot_node):\n            \"\"\"Execute a single branch with the given prompt.\"\"\"\n            try:\n                branch_bot = copy.deepcopy(bot)\n                branch_bot.autosave = False\n                branching_node = branch_bot.conversation\n                if hasattr(branch_bot, 'tool_handler') and branch_bot.tool_handler:\n                    branch_bot.tool_handler.clear()\n                if allow_work:\n                    response = branch_bot.respond(prompt)\n                    while not fp.conditions.tool_not_used(branch_bot):\n                        response = branch_bot.respond('ok')\n                else:\n                    response = branch_bot.respond(prompt)\n                with replies_lock:\n                    parent_bot_node.replies.extend(branching_node.replies)\n                    for node in branching_node.replies:\n                        node.parent = parent_bot_node\n                return (response, branch_bot.conversation)\n            except Exception:\n                traceback.print_exc()\n                return (None, None)\n        responses = []\n        branch_nodes = []\n        if parallel:\n            with ThreadPoolExecutor() as executor:\n                futures = [executor.submit(execute_branch, prompt, original_node) for prompt in prefixed_prompts]\n                for future in as_completed(futures):\n                    response, node = future.result()\n                    responses.append(response)\n                    branch_nodes.append(node)\n        else:\n            for prompt in prefixed_prompts:\n                response, node = execute_branch(prompt, original_node)\n                responses.append(response)\n                branch_nodes.append(node)\n        if dummy_results_added:\n            original_node.tool_results = original_results\n        bot.autosave = original_autosave\n        success_count = sum((1 for r in responses if r is not None))\n        combined = 'No recombinator selected'\n        if recombine != 'none' and responses:\n            valid_responses = [r for r in responses if r is not None]\n            if valid_responses:\n                if recombine == 'concatenate':\n                    combined, _ = recomb.concatenate(valid_responses, [])\n                elif recombine == 'llm_judge':\n                    combined, _ = recomb.llm_judge(valid_responses, [], judge_bot=bot)\n                elif recombine == 'llm_vote':\n                    combined, _ = recomb.llm_vote(valid_responses, [], vote_bot=bot)\n                elif recombine == 'llm_merge':\n                    combined, _ = recomb.llm_merge(valid_responses, [], merge_bot=bot)\n                else:\n                    combined = 'Unknown recombination method'\n        exec_type = 'parallel' if parallel else 'sequential'\n        work_type = 'iterative' if allow_work else 'single-response'\n        result_content = f'Successfully completed {success_count}/{len(message_list)} {exec_type} {work_type} branches. Recombination result:\\n\\n{combined}'\n        return result_content\n    except Exception as e:\n        traceback.print_exc()\n        return f'Error in branch_self: {str(e)}'\n\ndef _process_string_array(input_str: str) -> List[str]:\n    \"\"\"Parse a string representation of an array into a list of strings.\n    Only works with properly formatted Python list literals.\n    Args:\n        input_str (str): String representation of a Python list literal\n    Returns:\n        List[str]: List of parsed strings\n    Raises:\n        ValueError: If the input is not a valid Python list literal\n    \"\"\"\n    result = ast.literal_eval(input_str)\n    if not isinstance(result, list) or not all((isinstance(x, str) for x in result)):\n        raise ValueError('Input must evaluate to a list of strings')\n    return result\n\ndef _get_calling_bot() -> Optional[Bot]:\n    \"\"\"Helper function to get a reference to the calling bot.\n    Returns:\n        Optional[Bot]: Reference to the calling bot or None if not found\n    \"\"\"\n    frame = inspect.currentframe()\n    while frame:\n        if frame.f_code.co_name == '_cvsn_respond' and 'self' in frame.f_locals:\n            potential_bot = frame.f_locals['self']\n            if isinstance(potential_bot, Bot):\n                return potential_bot\n        frame = frame.f_back\n    return None",
    "file_path": "dynamic_module_3913901117500357081",
    "code_hash": "27b78baacc5d1bda1bfec687dfb946f1",
    "globals": {
     "_convert_tool_inputs": {
      "__helper_func__": true,
      "pickled": "gASVMAAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjBRfY29udmVydF90b29sX2lucHV0c5STlC4=",
      "name": "_convert_tool_inputs",
      "hash": "8bc4aba1c7d69350a812d8553b6a7ff0cd23ae5c818f3b9533752a69e91acf2e",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "_convert_tool_inputs"
      }
     },
     "_convert_tool_output": {
      "__helper_func__": true,
      "pickled": "gASVMAAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjBRfY29udmVydF90b29sX291dHB1dJSTlC4=",
      "name": "_convert_tool_output",
      "hash": "6c85767d30db1c50646d25d2b954c893aed15774f97345f9b8c99674c59cf928",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "_convert_tool_output"
      }
     },
     "ToolExecutionError": {
      "__imported_callable__": true,
      "pickled": "gASVLgAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjBJUb29sRXhlY3V0aW9uRXJyb3KUk5Qu",
      "name": "ToolExecutionError",
      "hash": "e3f136f46cc3014d1b1a8ac6716adb9da7db1dd83f2ed8529e090d97ae0db998",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "ToolExecutionError"
      }
     },
     "ast": {
      "__module_type__": true,
      "name": "ast",
      "spec": "ast"
     },
     "datetime": {
      "__module_type__": true,
      "name": "datetime",
      "spec": "datetime"
     },
     "functools": {
      "__module_type__": true,
      "name": "functools",
      "spec": "functools"
     },
     "inspect": {
      "__module_type__": true,
      "name": "inspect",
      "spec": "inspect"
     },
     "logging": {
      "__module_type__": true,
      "name": "logging",
      "spec": "logging"
     },
     "os": {
      "__module_type__": true,
      "name": "os",
      "spec": "os"
     },
     "sys": {
      "__module_type__": true,
      "name": "sys",
      "spec": "sys"
     },
     "textwrap": {
      "__module_type__": true,
      "name": "textwrap",
      "spec": "textwrap"
     },
     "traceback": {
      "__module_type__": true,
      "name": "traceback",
      "spec": "traceback"
     },
     "wraps": {
      "__imported_callable__": true,
      "pickled": "gASVFwAAAAAAAACMCWZ1bmN0b29sc5SMBXdyYXBzlJOULg==",
      "name": "wraps",
      "hash": "4c7c8f91a978a903bce2515f7fe83cb09b7074259dabad02b312209312f718ed",
      "provenance": {
       "module": "functools",
       "qualname": "wraps"
      }
     },
     "Any": {
      "__imported_callable__": true,
      "pickled": "gASVEgAAAAAAAACMBnR5cGluZ5SMA0FueZSTlC4=",
      "name": "Any",
      "hash": "fbf19bc6bf716a555ce7094664e2bc898734e4acfc2cd6d9ee399edef2e5c02b",
      "provenance": {
       "module": "typing",
       "qualname": "Any"
      }
     },
     "Callable": {
      "__imported_callable__": true,
      "pickled": "gASVFwAAAAAAAACMBnR5cGluZ5SMCENhbGxhYmxllJOULg==",
      "name": "Callable",
      "hash": "17cf7f09b805961290dccb95aa11199df32c246cb879f355ffa1a31d6285edad",
      "provenance": {
       "module": "typing",
       "qualname": "Callable"
      }
     },
     "Optional": {
      "__imported_callable__": true,
      "pickled": "gASVFwAAAAAAAACMBnR5cGluZ5SMCE9wdGlvbmFslJOULg==",
      "name": "Optional",
      "hash": "d69b63c158dd563d1537447d9d3a68afdda0efb70794ab11c234d01e2e593e56",
      "provenance": {
       "module": "typing",
       "qualname": "Optional"
      }
     },
     "Type": {
      "__imported_callable__": true,
      "pickled": "gASVEwAAAAAAAACMBnR5cGluZ5SMBFR5cGWUk5Qu",
      "name": "Type",
      "hash": "9e98fdb991d3addb0aad6e13cd94b21998f5d97e9f30b15f9c697afe5cde1832",
      "provenance": {
       "module": "typing",
       "qualname": "Type"
      }
     },
     "remove_code_blocks": {
      "__imported_callable__": true,
      "pickled": "gASVLQAAAAAAAACMEmJvdHMudXRpbHMuaGVscGVyc5SMEnJlbW92ZV9jb2RlX2Jsb2Nrc5STlC4=",
      "name": "remove_code_blocks",
      "hash": "44524fda389310a2a28f80da99409efd110baefaa9ea50345d092a634c89fc1d",
      "provenance": {
       "module": "bots.utils.helpers",
       "qualname": "remove_code_blocks"
      }
     },
     "NoHTTPFilter": {
      "__imported_callable__": true,
      "pickled": "gASVKAAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjAxOb0hUVFBGaWx0ZXKUk5Qu",
      "name": "NoHTTPFilter",
      "hash": "9f920bc687c51afef3dea517f9b64393473ed37dac3fda0cedd01a655b483a52",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "NoHTTPFilter"
      }
     },
     "lazy_fn": {
      "__imported_callable__": true,
      "pickled": "gASVIwAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjAdsYXp5X2ZulJOULg==",
      "name": "lazy_fn",
      "hash": "a1737e2cf8adde594f0dd0b3f17ffaad4c126dcf16906e82cb07f18c13d8b7a2",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "lazy_fn"
      }
     },
     "lazy_class": {
      "__imported_callable__": true,
      "pickled": "gASVJgAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjApsYXp5X2NsYXNzlJOULg==",
      "name": "lazy_class",
      "hash": "d1883fc4e7eb2d64f47b4e90b4b6b69d0c5be0d0e3175787058ad631d122e4c6",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "lazy_class"
      }
     },
     "_get_context": {
      "__helper_func__": true,
      "pickled": "gASVKAAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjAxfZ2V0X2NvbnRleHSUk5Qu",
      "name": "_get_context",
      "hash": "979ef249cdc1f76f4020d948ffc352f7c667afb0d89f221770156eebd7717c7a",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "_get_context"
      }
     },
     "_get_py_interface": {
      "__helper_func__": true,
      "pickled": "gASVLQAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjBFfZ2V0X3B5X2ludGVyZmFjZZSTlC4=",
      "name": "_get_py_interface",
      "hash": "d45b0506fb8815e8d9c3a9217b0ca101dac4fb9f51c8546285cf68a95ab027e7",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "_get_py_interface"
      }
     },
     "lazy": {
      "__imported_callable__": true,
      "pickled": "gASVIAAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjARsYXp5lJOULg==",
      "name": "lazy",
      "hash": "6e25446d8765ac65a5518c01582ddf52784eb90c51d57e224c94823d5b7c55cd",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "lazy"
      }
     },
     "debug_on_error": {
      "__imported_callable__": true,
      "pickled": "gASVKgAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjA5kZWJ1Z19vbl9lcnJvcpSTlC4=",
      "name": "debug_on_error",
      "hash": "06d89d594519c41c1dae666437441d4fd4aeeea959f1c905694940a50ae4ddfe",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "debug_on_error"
      }
     },
     "log_errors": {
      "__imported_callable__": true,
      "pickled": "gASVJgAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjApsb2dfZXJyb3JzlJOULg==",
      "name": "log_errors",
      "hash": "f9446c0ae11aa5bb7726b83da744e8dc707a91edc91085abbca1cefd1897d829",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "log_errors"
      }
     },
     "toolify": {
      "__imported_callable__": true,
      "pickled": "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ciBoZWxwZXJzKS4gU2VlIGJvdHMvZm91bmRhdGlvbi90b29sX2hhbmRsaW5nLm1kLgoKICAgIEFyZ3M6CiAgICAgICAgc2VsZl9wcm9tcHRzIChzdHIpOiBMaXN0IG9mIHByb21wdHMgYXMgYSBzdHJpbmcgYXJyYXksIGxpa2UgWyd0YXNrIDEnLCAndGFzayAyJywgJ3Rhc2sgMyddCiAgICAgICAgICAgICAgICAgICAgICAgICAgIEVhY2ggcHJvbXB0IGJlY29tZXMgYSBzZXBhcmF0ZSBjb252ZXJzYXRpb24gYnJhbmNoCiAgICAgICAgYWxsb3dfd29yayAoc3RyKTogJ1RydWUnIHRvIGxldCBlYWNoIGJyYW5jaCB1c2UgdG9vbHMgYW5kIGNvbnRpbnVlIHdvcmtpbmcgdW50aWwgZG9uZQogICAgICAgICAgICAgICAgICAgICAgICAgJ0ZhbHNlJyAoZGVmYXVsdCkgZm9yIHNpbmdsZS1yZXNwb25zZSBicmFuY2hlcwogICAgICAgIHBhcmFsbGVsIChzdHIpOiAnVHJ1ZScgdG8gbGV0IGJyYW5jaGVzIHdvcmsgaW4gcGFyYWxsZWwsICdGYWxzZScgZm9yIHNlcXVlbnRpYWwgKGRlZmF1bHQpLgogICAgICAgIHJlY29tYmluZSAoc3RyKTogT25lIG9mICgnbm9uZScsICdjb25jYXRlbmF0ZScsICdsbG1fbWVyZ2UnLCAnbGxtX3ZvdGUnLCAnbGxtX2p1ZGdlJyksIGRlZmF1bHQgJ2NvbmNhdGVuYXRlJy4KICAgICAgICAgICAgICAgICAgICAgICAgIENvbWJpbmVzIHRoZSBmaW5hbCBtZXNzYWdlcyBmcm9tIGVhY2ggYnJhbmNoIHVzaW5nIHRoYXQgbWV0aG9kLgoKICAgIFJldHVybnM6CiAgICAgICAgc3RyOiBTdWNjZXNzIG1lc3NhZ2Ugd2l0aCBicmFuY2ggY291bnQsIG9yIGVycm9yIGRldGFpbHMgaWYgc29tZXRoaW5nIHdlbnQgd3JvbmcKICAgIJRLAE6MElRocmVhZFBvb2xFeGVjdXRvcpSMDGFzX2NvbXBsZXRlZJSGlIwSZnVuY3Rpb25hbF9wcm9tcHRzlIWUjCFFcnJvcjogQ291bGQgbm90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lwEBAIwLBAB5AK0DdwGUTksBhpQpjAIuMJSMAXKUhpRoJ4wJPGdlbmV4cHI+lIweYnJhbmNoX3NlbGYuPGxvY2Fscz4uPGdlbmV4cHI+lEu1QxXoAPiAANAcQ6kJoDGwUbFdnFGpCfmUQwiCBxEBigcRAZQpKXSUUpSMGE5vIHJlY29tYmluYXRvciBzZWxlY3RlZJRo7YwNcmVjb21iaW5hdG9yc5SFlGjuaO+MCWp1ZGdlX2JvdJSFlGjwjAh2b3RlX2JvdJSFlGjxjAltZXJnZV9ib3SUhZSMHFVua25vd24gcmVjb21iaW5hdGlvbiBtZXRob2SUjAhwYXJhbGxlbJSMCnNlcXVlbnRpYWyUjAlpdGVyYXRpdmWUjA9zaW5nbGUtcmVzcG9uc2WUjBdTdWNjZXNzZnVsbHkgY29tcGxldGVkIJSMAS+UaDKMIiBicmFuY2hlcy4gUmVjb21iaW5hdGlvbiByZXN1bHQ6CgqUjBZFcnJvciBpbiBicmFuY2hfc2VsZjoglHSUKGobAQAAjAl0aHJlYWRpbmeUjBJjb25jdXJyZW50LmZ1dHVyZXOUaOZo54wKYm90cy5mbG93c5Ro6WisjAVsb3dlcpSMFV9wcm9jZXNzX3N0cmluZ19hcnJheZRoG2gZagMBAABqAgEAAIwKdG9vbF9jYWxsc5SMA2dldJRo/YwYZ2VuZXJhdGVfcmVzcG9uc2Vfc2NoZW1hlIwGYXBwZW5klIwEbGlzdJSMB2dldGF0dHKUjBFfYWRkX3Rvb2xfcmVzdWx0c5SMBExvY2uUjAZzdWJtaXSUaCFo+YwDc3VtlIwYYm90cy5mbG93cy5yZWNvbWJpbmF0b3JzlGotAQAAaO5o72jwaPGMA2xlbpRofGoMAQAAdJQojAxzZWxmX3Byb21wdHOUahkBAABqNgEAAIwJcmVjb21iaW5llGo/AQAAaOZo54wXdmFsaWRfcmVjb21iaW5lX29wdGlvbnOUjAxtZXNzYWdlX2xpc3SUaCJqDgEAAIwQcHJlZml4ZWRfcHJvbXB0c5SMDW9yaWdpbmFsX25vZGWUjBFvcmlnaW5hbF9hdXRvc2F2ZZSME2R1bW15X3Jlc3VsdHNfYWRkZWSUjBBvcmlnaW5hbF9yZXN1bHRzlIwNZHVtbXlfcmVzdWx0c5SMCXRvb2xfY2FsbJSM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cykKICAgIC0gRW5oYW5jZXMgZG9jc3RyaW5nIGlmIGRlc2NyaXB0aW9uIHByb3ZpZGVkCgogICAgQXJnczoKICAgICAgICBkZXNjcmlwdGlvbiAoc3RyLCBvcHRpb25hbCk6IE92ZXJyaWRlIHRoZSBmdW5jdGlvbidzIGRvY3N0cmluZwoKICAgIEV4YW1wbGU6CiAgICAgICAgQHRvb2xpZnkoKQogICAgICAgIGRlZiBhZGRfbnVtYmVycyh4OiBpbnQsIHk6IGludCA9IDApIC0+IGludDoKICAgICAgICAgICAgcmV0dXJuIHggKyB5CgogICAgICAgIEB0b29saWZ5KCJDYWxjdWxhdGUgdGhlIGFyZWEgb2YgYSBjaXJjbGUiKQogICAgICAgIGRlZiBhcmVhKHJhZGl1czogZmxvYXQpIC0+IGZsb2F0OgogICAgICAgICAgICByZXR1cm4gMy4xNDE1OSAqIHJhZGl1cyAqIHJhZGl1cwogICAgIiIiCgogICAgZGVmIGRlY29yYXRvcihmdW5jKToKICAgICAgICBAZnVuY3Rvb2xzLndyYXBzKGZ1bmMpCiAgICAgICAgZGVmIHdyYXBwZXIoKmFyZ3MsICoqa3dhcmdzKToKICAgICAgICAgICAgdHJ5OgogICAgICAgICAgICAgICAgIyBDb252ZXJ0IHN0cmluZyBpbnB1dHMgdG8gcHJvcGVyIHR5cGVzIHVzaW5nIHR5cGUgaGludHMKICAgICAgICAgICAgICAgIGNvbnZlcnRlZF9hcmdzLCBjb252ZXJ0ZWRfa3dhcmdzID0gX2NvbnZlcnRfdG9vbF9pbnB1dHMoZnVuYywgYXJncywga3dhcmdzKQoKICAgICAgICAgICAgICAgICMgQ2FsbCBvcmlnaW5hbCBmdW5jdGlvbgogICAgICAgICAgICAgICAgcmVzdWx0ID0gZnVuYygqY29udmVydGVkX2FyZ3MsICoqY29udmVydGVkX2t3YXJncykKCiAgICAgICAgICAgICAgICAjIENvbnZlcnQgcmVzdWx0IHRvIHN0cmluZwogICAgICAgICAgICAgICAgcmV0dXJuIF9jb252ZXJ0X3Rvb2xfb3V0cHV0KHJlc3VsdCkKCiAgICAgICAgICAgIGV4Y2VwdCBLZXlib2FyZEludGVycnVwdCBhcyBlOgogICAgICAgICAgICAgICAgIyBDb252ZXJ0IEtleWJvYXJkSW50ZXJydXB0IHRvIFRvb2xFeGVjdXRpb25FcnJvciB0byBwcmV2ZW50IGl0IGZyb20KICAgICAgICAgICAgICAgICMgYnViYmxpbmcgdXAgdG8gQ0xJIGFuZCBiZWluZyB0cmVhdGVkIGFzIHVzZXIgQ3RybCtDCiAgICAgICAgICAgICAgICBmcm9tIGJvdHMudXRpbHMuaGVscGVycyBpbXBvcnQgX3Byb2Nlc3NfZXJyb3IKCiAgICAgICAgICAgICAgICB0b29sX2Vycm9yID0gVG9vbEV4ZWN1dGlvbkVycm9yKGYiVG9vbCBleGVjdXRpb24gaW50ZXJydXB0ZWQ6IHtzdHIoZSl9IikKICAgICAgICAgICAgICAgIHJldHVybiBfcHJvY2Vzc19lcnJvcih0b29sX2Vycm9yKQoKICAgICAgICAgICAgZXhjZXB0IFR5cGVFcnJvciBhcyBlOgogICAgICAgICAgICAgICAgIyBDaGVjayBpZiB0aGlzIGlzIGEgbWlzc2luZyByZXF1aXJlZCBhcmd1bWVudCBlcnJvcgogICAgICAgICAgICAgICAgZXJyb3JfbXNnID0gc3RyKGUpCiAgICAgICAgICAgICAgICBpZiAibWlzc2luZyIgaW4gZXJyb3JfbXNnIGFuZCAicmVxdWlyZWQiIGluIGVycm9yX21zZyBhbmQgImFyZ3VtZW50IiBpbiBlcnJvcl9tc2c6CiAgICAgICAgICAgICAgICAgICAgIyBBZGQgc3BlY2lhbCBtZXNzYWdlIGZvciBvdXRwdXQgdG9rZW4gbGltaXRhdGlvbgogICAgICAgICAgICAgICAgICAgIGVuaGFuY2VkX2Vycm9yID0gVHlwZUVycm9yKAogICAgICAgICAgICAgICAgICAgICAgICBmIntlcnJvcl9tc2d9XG5cbiIKICAgICAgICAgICAgICAgICAgICAgICAgZiLimqDvuI8gIFRoaXMgZXJyb3IgaXMgY29tbW9ubHkgY2F1c2VkIGJ5IGhpdHRpbmcgdGhlIG1heF90b2tlbnMgbGltaXQgYmVmb3JlIGNvbXBsZXRpbmcgdGhlIHRvb2wgY2FsbC5cbiIKICAgICAgICAgICAgICAgICAgICAgICAgZiJUaGUgcmVzcG9uc2Ugd2FzIHRydW5jYXRlZCBtaWQtcGFyYW1ldGVyLCBtYWtpbmcgaXQgYXBwZWFyIHRoYXQgcmVxdWlyZWQgcGFyYW1ldGVycyBhcmUgbWlzc2luZy5cbiIKICAgICAgICAgICAgICAgICAgICAgICAgZiJUbyBmaXggdGhpczogV29yayBpbiBTTUFMTEVSIENIVU5LUy4gRWRpdCBmZXdlciBsaW5lcyBhdCBhIHRpbWUsICIKICAgICAgICAgICAgICAgICAgICAgICAgZiJvciBicmVhayB5b3VyIHRhc2sgaW50byBtdWx0aXBsZSBzdGVwcy4iCiAgICAgICAgICAgICAgICAgICAgKQogICAgICAgICAgICAgICAgICAgIGZyb20gYm90cy51dGlscy5oZWxwZXJzIGltcG9ydCBfcHJvY2Vzc19lcnJvcgoKICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3Byb2Nlc3NfZXJyb3IoZW5oYW5jZWRfZXJyb3IpCiAgICAgICAgICAgICAgICBlbHNlOgogICAgICAgICAgICAgICAgICAgIGZyb20gYm90cy51dGlscy5oZWxwZXJzIGltcG9ydCBfcHJvY2Vzc19lcnJvcgoKICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3Byb2Nlc3NfZXJyb3IoZSkKICAgICAgICAgICAgZXhjZXB0IEV4Y2VwdGlvbiBhcyBlOgogICAgICAgICAgICAgICAgZnJvbSBib3RzLnV0aWxzLmhlbHBlcnMgaW1wb3J0IF9wcm9jZXNzX2Vycm9yCgogICAgICAgICAgICAgICAgcmV0dXJuIF9wcm9jZXNzX2Vycm9yKGUpCgogICAgICAgICMgVXBkYXRlIGRvY3N0cmluZyBpZiBkZXNjcmlwdGlvbiBwcm92aWRlZAogICAgICAgIGlmIGRlc2NyaXB0aW9uOgogICAgICAgICAgICB3cmFwcGVyLl9fZG9jX18gPSBkZXNjcmlwdGlvbgogICAgICAgIGVsaWYgbm90IHdyYXBwZXIuX19kb2NfXzoKICAgICAgICAgICAgIyBHZW5lcmF0ZSBtaW5pbWFsIGRvY3N0cmluZyBmcm9tIGZ1bmN0aW9uIG5hbWUKICAgICAgICAgICAgd3JhcHBlci5fX2RvY19fID0gZiJFeGVjdXRlIHtmdW5jLl9fbmFtZV9fLnJlcGxhY2UoJ18nLCAnICcpfSIKCiAgICAgICAgcmV0dXJuIHdyYXBwZXIKCiAgICByZXR1cm4gZGVjb3JhdG9yCgpAdG9vbGlmeSgpCmRlZiBicmFuY2hfc2VsZihzZWxmX3Byb21wdHM6IHN0ciwgYWxsb3dfd29yazogc3RyPSdGYWxzZScsIHBhcmFsbGVsOiBzdHI9J0ZhbHNlJywgcmVjb21iaW5lOiBzdHI9J2NvbmNhdGVuYXRlJykgLT4gc3RyOgogICAgIiIiQ3JlYXRlIG11bHRpcGxlIGNvbnZlcnNhdGlvbiBicmFuY2hlcyB0byBleHBsb3JlIGRpZmZlcmVudCBhcHByb2FjaGVzIG9yIHRhY2tsZSBzZXBhcmF0ZSB0YXNrcy4KCiAgICBDcmVhdGVzIGlzb2xhdGVkIGNvbnZlcnNhdGlvbiBicmFuY2hlcyB1c2luZyBkZWVwY29weToKICAgIDEuIERlZXBjb3B5IGN1cnJlbnQgYm90IHN0YXRlICh1c2VzIF9fZ2V0c3RhdGVfXy9fX3NldHN0YXRlX18gZm9yIHByb3BlciBzZXJpYWxpemF0aW9uKQogICAgMi4gRXhlY3V0ZSBlYWNoIGJyYW5jaCB3aXRoIGluZGVwZW5kZW50IGJvdCBpbnN0YW5jZXMKICAgIDMuIFN0aXRjaCByZXN1bHRzIGJhY2sgaW50byBtYWluIGNvbnZlcnNhdGlvbiB0cmVlCgogICAgTm90ZTogVXNlcyBkZWVwY29weSB3aXRoIF9fZ2V0c3RhdGVfXy9fX3NldHN0YXRlX18gd2hpY2ggbGV2ZXJhZ2VzIHRoZSBoeWJyaWQKICAgIHNlcmlhbGl6YXRpb24gc3RyYXRlZ3kgKHNvdXJjZSBjb2RlICsgZGlsbCBmb3IgaGVscGVycykuIFNlZSBib3RzL2ZvdW5kYXRpb24vdG9vbF9oYW5kbGluZy5tZC4KCiAgICBBcmdzOgogICAgICAgIHNlbGZfcHJvbXB0cyAoc3RyKTogTGlzdCBvZiBwcm9tcHRzIGFzIGEgc3RyaW5nIGFycmF5LCBsaWtlIFsndGFzayAxJywgJ3Rhc2sgMicsICd0YXNrIDMnXQogICAgICAgICAgICAgICAgICAgICAgICAgICBFYWNoIHByb21wdCBiZWNvbWVzIGEgc2VwYXJhdGUgY29udmVyc2F0aW9uIGJyYW5jaAogICAgICAgIGFsbG93X3dvcmsgKHN0cik6ICdUcnVlJyB0byBsZXQgZWFjaCBicmFuY2ggdXNlIHRvb2xzIGFuZCBjb250aW51ZSB3b3JraW5nIHVudGlsIGRvbmUKICAgICAgICAgICAgICAgICAgICAgICAgICdGYWxzZScgKGRlZmF1bHQpIGZvciBzaW5nbGUtcmVzcG9uc2UgYnJhbmNoZXMKICAgICAgICBwYXJhbGxlbCAoc3RyKTogJ1RydWUnIHRvIGxldCBicmFuY2hlcyB3b3JrIGluIHBhcmFsbGVsLCAnRmFsc2UnIGZvciBzZXF1ZW50aWFsIChkZWZhdWx0KS4KICAgICAgICByZWNvbWJpbmUgKHN0cik6IE9uZSBvZiAoJ25vbmUnLCAnY29uY2F0ZW5hdGUnLCAnbGxtX21lcmdlJywgJ2xsbV92b3RlJywgJ2xsbV9qdWRnZScpLCBkZWZhdWx0ICdjb25jYXRlbmF0ZScuCiAgICAgICAgICAgICAgICAgICAgICAgICBDb21iaW5lcyB0aGUgZmluYWwgbWVzc2FnZXMgZnJvbSBlYWNoIGJyYW5jaCB1c2luZyB0aGF0IG1ldGhvZC4KCiAgICBSZXR1cm5zOgogICAgICAgIHN0cjogU3VjY2VzcyBtZXNzYWdlIHdpdGggYnJhbmNoIGNvdW50LCBvciBlcnJvciBkZXRhaWxzIGlmIHNvbWV0aGluZyB3ZW50IHdyb25nCiAgICAiIiIKICAgIGltcG9ydCBjb3B5CiAgICBpbXBvcnQgdGhyZWFkaW5nCiAgICBmcm9tIGNvbmN1cnJlbnQuZnV0dXJlcyBpbXBvcnQgVGhyZWFkUG9vbEV4ZWN1dG9yLCBhc19jb21wbGV0ZWQKICAgIGZyb20gYm90cy5mbG93cyBpbXBvcnQgZnVuY3Rpb25hbF9wcm9tcHRzIGFzIGZwCiAgICBib3QgPSBfZ2V0X2NhbGxpbmdfYm90KCkKICAgIGlmIG5vdCBib3Q6CiAgICAgICAgcmV0dXJuICdFcnJvcjogQ291bGQgbm90IGZpbmQgY2FsbGluZyBib3QnCiAgICBhbGxvd193b3JrID0gYWxsb3dfd29yay5sb3dlcigpID09ICd0cnVlJwogICAgcGFyYWxsZWwgPSBwYXJhbGxlbC5sb3dlcigpID09ICd0cnVlJwogICAgcmVjb21iaW5lID0gcmVjb21iaW5lLmxvd2VyKCkKICAgIHZhbGlkX3JlY29tYmluZV9vcHRpb25zID0gWydub25lJywgJ2NvbmNhdGVuYXRlJywgJ2xsbV9qdWRnZScsICdsbG1fdm90ZScsICdsbG1fbWVyZ2UnXQogICAgaWYgcmVjb21iaW5lIG5vdCBpbiB2YWxpZF9yZWNvbWJpbmVfb3B0aW9uczoKICAgICAgICByZXR1cm4gZidFcnJvcjogSW52YWxpZCByZWNvbWJpbmUgb3B0aW9uLiBWYWxpZDoge3ZhbGlkX3JlY29tYmluZV9vcHRpb25zfScKICAgIHRyeToKICAgICAgICBtZXNzYWdlX2xpc3QgPSBfcHJvY2Vzc19zdHJpbmdfYXJyYXkoc2VsZl9wcm9tcHRzKQogICAgICAgIGlmIG5vdCBtZXNzYWdlX2xpc3Q6CiAgICAgICAgICAgIHJldHVybiAnRXJyb3I6IE5vIHZhbGlkIG1lc3NhZ2VzIHByb3ZpZGVkJwogICAgZXhjZXB0IEV4Y2VwdGlvbiBhcyBlOgogICAgICAgIHJldHVybiBmJ0Vycm9yIHBhcnNpbmcgcHJvbXB0czoge3N0cihlKX0nCiAgICBwcmVmaXhlZF9wcm9tcHRzID0gW2YnKHNlbGYtcHJvbXB0KToge3Byb21wdH0nIGZvciBwcm9tcHQgaW4gbWVzc2FnZV9saXN0XQogICAgdHJ5OgogICAgICAgIG9yaWdpbmFsX25vZGUgPSBib3QuY29udmVyc2F0aW9uCiAgICAgICAgb3JpZ2luYWxfYXV0b3NhdmUgPSBib3QuYXV0b3NhdmUKICAgICAgICBib3QuYXV0b3NhdmUgPSBGYWxzZQogICAgICAgIGR1bW15X3Jlc3VsdHNfYWRkZWQgPSBGYWxzZQogICAgICAgIG9yaWdpbmFsX3Jlc3VsdHMgPSBOb25lCiAgICAgICAgaWYgb3JpZ2luYWxfbm9kZS50b29sX2NhbGxzOgogICAgICAgICAgICBkdW1teV9yZXN1bHRzID0gW10KICAgICAgICAgICAgZm9yIHRvb2xfY2FsbCBpbiBvcmlnaW5hbF9ub2RlLnRvb2xfY2FsbHM6CiAgICAgICAgICAgICAgICBpZiB0b29sX2NhbGwuZ2V0KCduYW1lJykgPT0gJ2JyYW5jaF9zZWxmJzoKICAgICAgICAgICAgICAgICAgICBkdW1teV9yZXN1bHQgPSBib3QudG9vbF9oYW5kbGVyLmdlbmVyYXRlX3Jlc3BvbnNlX3NjaGVtYSh0b29sX2NhbGwsICdCcmFuY2hpbmcgaW4gcHJvZ3Jlc3MuLi4nKQogICAgICAgICAgICAgICAgICAgIGR1bW15X3Jlc3VsdHMuYXBwZW5kKGR1bW15X3Jlc3VsdCkKICAgICAgICAgICAgaWYgZHVtbXlfcmVzdWx0czoKICAgICAgICAgICAgICAgIG9yaWdpbmFsX3Jlc3VsdHMgPSBsaXN0KGdldGF0dHIob3JpZ2luYWxfbm9kZSwgJ3Rvb2xfcmVzdWx0cycsIFtdKSkKICAgICAgICAgICAgICAgIG9yaWdpbmFsX25vZGUuX2FkZF90b29sX3Jlc3VsdHMoZHVtbXlfcmVzdWx0cykKICAgICAgICAgICAgICAgIGR1bW15X3Jlc3VsdHNfYWRkZWQgPSBUcnVlCiAgICAgICAgcmVwbGllc19sb2NrID0gdGhyZWFkaW5nLkxvY2soKQoKICAgICAgICBkZWYgZXhlY3V0ZV9icmFuY2gocHJvbXB0LCBwYXJlbnRfYm90X25vZGUpOgogICAgICAgICAgICAiIiJFeGVjdXRlIGEgc2luZ2xlIGJyYW5jaCB3aXRoIHRoZSBnaXZlbiBwcm9tcHQuIiIiCiAgICAgICAgICAgIHRyeToKICAgICAgICAgICAgICAgIGJyYW5jaF9ib3QgPSBjb3B5LmRlZXBjb3B5KGJvdCkKICAgICAgICAgICAgICAgIGJyYW5jaF9ib3QuYXV0b3NhdmUgPSBGYWxzZQogICAgICAgICAgICAgICAgYnJhbmNoaW5nX25vZGUgPSBicmFuY2hfYm90LmNvbnZlcnNhdGlvbgogICAgICAgICAgICAgICAgaWYgaGFzYXR0cihicmFuY2hfYm90LCAndG9vbF9oYW5kbGVyJykgYW5kIGJyYW5jaF9ib3QudG9vbF9oYW5kbGVyOgogICAgICAgICAgICAgICAgICAgIGJyYW5jaF9ib3QudG9vbF9oYW5kbGVyLmNsZWFyKCkKICAgICAgICAgICAgICAgIGlmIGFsbG93X3dvcms6CiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBicmFuY2hfYm90LnJlc3BvbmQocHJvbXB0KQogICAgICAgICAgICAgICAgICAgIHdoaWxlIG5vdCBmcC5jb25kaXRpb25zLnRvb2xfbm90X3VzZWQoYnJhbmNoX2JvdCk6CiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gYnJhbmNoX2JvdC5yZXNwb25kKCdvaycpCiAgICAgICAgICAgICAgICBlbHNlOgogICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gYnJhbmNoX2JvdC5yZXNwb25kKHByb21wdCkKICAgICAgICAgICAgICAgIHdpdGggcmVwbGllc19sb2NrOgogICAgICAgICAgICAgICAgICAgIHBhcmVudF9ib3Rfbm9kZS5yZXBsaWVzLmV4dGVuZChicmFuY2hpbmdfbm9kZS5yZXBsaWVzKQogICAgICAgICAgICAgICAgICAgIGZvciBub2RlIGluIGJyYW5jaGluZ19ub2RlLnJlcGxpZXM6CiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUucGFyZW50ID0gcGFyZW50X2JvdF9ub2RlCiAgICAgICAgICAgICAgICByZXR1cm4gKHJlc3BvbnNlLCBicmFuY2hfYm90LmNvbnZlcnNhdGlvbikKICAgICAgICAgICAgZXhjZXB0IEV4Y2VwdGlvbjoKICAgICAgICAgICAgICAgIGltcG9ydCB0cmFjZWJhY2sKICAgICAgICAgICAgICAgIHRyYWNlYmFjay5wcmludF9leGMoKQogICAgICAgICAgICAgICAgcmV0dXJuIChOb25lLCBOb25lKQogICAgICAgIHJlc3BvbnNlcyA9IFtdCiAgICAgICAgYnJhbmNoX25vZGVzID0gW10KICAgICAgICBpZiBwYXJhbGxlbDoKICAgICAgICAgICAgd2l0aCBUaHJlYWRQb29sRXhlY3V0b3IoKSBhcyBleGVjdXRvcjoKICAgICAgICAgICAgICAgIGZ1dHVyZXMgPSBbZXhlY3V0b3Iuc3VibWl0KGV4ZWN1dGVfYnJhbmNoLCBwcm9tcHQsIG9yaWdpbmFsX25vZGUpIGZvciBwcm9tcHQgaW4gcHJlZml4ZWRfcHJvbXB0c10KICAgICAgICAgICAgICAgIGZvciBmdXR1cmUgaW4gYXNfY29tcGxldGVkKGZ1dHVyZXMpOgogICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLCBub2RlID0gZnV0dXJlLnJlc3VsdCgpCiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VzLmFwcGVuZChyZXNwb25zZSkKICAgICAgICAgICAgICAgICAgICBicmFuY2hfbm9kZXMuYXBwZW5kKG5vZGUpCiAgICAgICAgZWxzZToKICAgICAgICAgICAgZm9yIHByb21wdCBpbiBwcmVmaXhlZF9wcm9tcHRzOgogICAgICAgICAgICAgICAgcmVzcG9uc2UsIG5vZGUgPSBleGVjdXRlX2JyYW5jaChwcm9tcHQsIG9yaWdpbmFsX25vZGUpCiAgICAgICAgICAgICAgICByZXNwb25zZXMuYXBwZW5kKHJlc3BvbnNlKQogICAgICAgICAgICAgICAgYnJhbmNoX25vZGVzLmFwcGVuZChub2RlKQogICAgICAgIGlmIGR1bW15X3Jlc3VsdHNfYWRkZWQ6CiAgICAgICAgICAgIG9yaWdpbmFsX25vZGUudG9vbF9yZXN1bHRzID0gb3JpZ2luYWxfcmVzdWx0cwogICAgICAgIGJvdC5hdXRvc2F2ZSA9IG9yaWdpbmFsX2F1dG9zYXZlCiAgICAgICAgc3VjY2Vzc19jb3VudCA9IHN1bSgoMSBmb3IgciBpbiByZXNwb25zZXMgaWYgciBpcyBub3QgTm9uZSkpCiAgICAgICAgY29tYmluZWQgPSAnTm8gcmVjb21iaW5hdG9yIHNlbGVjdGVkJwogICAgICAgIGlmIHJlY29tYmluZSAhPSAnbm9uZScgYW5kIHJlc3BvbnNlczoKICAgICAgICAgICAgdmFsaWRfcmVzcG9uc2VzID0gW3IgZm9yIHIgaW4gcmVzcG9uc2VzIGlmIHIgaXMgbm90IE5vbmVdCiAgICAgICAgICAgIGlmIHZhbGlkX3Jlc3BvbnNlczoKICAgICAgICAgICAgICAgIGZyb20gYm90cy5mbG93cy5yZWNvbWJpbmF0b3JzIGltcG9ydCByZWNvbWJpbmF0b3JzIGFzIHJlY29tYgogICAgICAgICAgICAgICAgaWYgcmVjb21iaW5lID09ICdjb25jYXRlbmF0ZSc6CiAgICAgICAgICAgICAgICAgICAgY29tYmluZWQsIF8gPSByZWNvbWIuY29uY2F0ZW5hdGUodmFsaWRfcmVzcG9uc2VzLCBbXSkKICAgICAgICAgICAgICAgIGVsaWYgcmVjb21iaW5lID09ICdsbG1fanVkZ2UnOgogICAgICAgICAgICAgICAgICAgIGNvbWJpbmVkLCBfID0gcmVjb21iLmxsbV9qdWRnZSh2YWxpZF9yZXNwb25zZXMsIFtdLCBqdWRnZV9ib3Q9Ym90KQogICAgICAgICAgICAgICAgZWxpZiByZWNvbWJpbmUgPT0gJ2xsbV92b3RlJzoKICAgICAgICAgICAgICAgICAgICBjb21iaW5lZCwgXyA9IHJlY29tYi5sbG1fdm90ZSh2YWxpZF9yZXNwb25zZXMsIFtdLCB2b3RlX2JvdD1ib3QpCiAgICAgICAgICAgICAgICBlbGlmIHJlY29tYmluZSA9PSAnbGxtX21lcmdlJzoKICAgICAgICAgICAgICAgICAgICBjb21iaW5lZCwgXyA9IHJlY29tYi5sbG1fbWVyZ2UodmFsaWRfcmVzcG9uc2VzLCBbXSwgbWVyZ2VfYm90PWJvdCkKICAgICAgICAgICAgICAgIGVsc2U6CiAgICAgICAgICAgICAgICAgICAgY29tYmluZWQgPSAnVW5rbm93biByZWNvbWJpbmF0aW9uIG1ldGhvZCcKICAgICAgICBleGVjX3R5cGUgPSAncGFyYWxsZWwnIGlmIHBhcmFsbGVsIGVsc2UgJ3NlcXVlbnRpYWwnCiAgICAgICAgd29ya190eXBlID0gJ2l0ZXJhdGl2ZScgaWYgYWxsb3dfd29yayBlbHNlICdzaW5nbGUtcmVzcG9uc2UnCiAgICAgICAgcmVzdWx0X2NvbnRlbnQgPSBmJ1N1Y2Nlc3NmdWxseSBjb21wbGV0ZWQge3N1Y2Nlc3NfY291bnR9L3tsZW4obWVzc2FnZV9saXN0KX0ge2V4ZWNfdHlwZX0ge3dvcmtfdHlwZX0gYnJhbmNoZXMuIFJlY29tYmluYXRpb24gcmVzdWx0OlxuXG57Y29tYmluZWR9JwogICAgICAgIHJldHVybiByZXN1bHRfY29udGVudAogICAgZXhjZXB0IEV4Y2VwdGlvbiBhcyBlOgogICAgICAgIGltcG9ydCB0cmFjZWJhY2sKICAgICAgICB0cmFjZWJhY2sucHJpbnRfZXhjKCkKICAgICAgICByZXR1cm4gZidFcnJvciBpbiBicmFuY2hfc2VsZjoge3N0cihlKX0nCgpkZWYgX3Byb2Nlc3Nfc3RyaW5nX2FycmF5KGlucHV0X3N0cjogc3RyKSAtPiBMaXN0W3N0cl06CiAgICAiIiJQYXJzZSBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhbiBhcnJheSBpbnRvIGEgbGlzdCBvZiBzdHJpbmdzLgogICAgT25seSB3b3JrcyB3aXRoIHByb3Blcmx5IGZvcm1hdHRlZCBQeXRob24gbGlzdCBsaXRlcmFscy4KICAgIEFyZ3M6CiAgICAgICAgaW5wdXRfc3RyIChzdHIpOiBTdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBQeXRob24gbGlzdCBsaXRlcmFsCiAgICBSZXR1cm5zOgogICAgICAgIExpc3Rbc3RyXTogTGlzdCBvZiBwYXJzZWQgc3RyaW5ncwogICAgUmFpc2VzOgogICAgICAgIFZhbHVlRXJyb3I6IElmIHRoZSBpbnB1dCBpcyBub3QgYSB2YWxpZCBQeXRob24gbGlzdCBsaXRlcmFsCiAgICAiIiIKICAgIHJlc3VsdCA9IGFzdC5saXRlcmFsX2V2YWwoaW5wdXRfc3RyKQogICAgaWYgbm90IGlzaW5zdGFuY2UocmVzdWx0LCBsaXN0KSBvciBub3QgYWxsKChpc2luc3RhbmNlKHgsIHN0cikgZm9yIHggaW4gcmVzdWx0KSk6CiAgICAgICAgcmFpc2UgVmFsdWVFcnJvcignSW5wdXQgbXVzdCBldmFsdWF0ZSB0byBhIGxpc3Qgb2Ygc3RyaW5ncycpCiAgICByZXR1cm4gcmVzdWx0CgpkZWYgX2dldF9jYWxsaW5nX2JvdCgpIC0+IE9wdGlvbmFsW0JvdF06CiAgICAiIiJIZWxwZXIgZnVuY3Rpb24gdG8gZ2V0IGEgcmVmZXJlbmNlIHRvIHRoZSBjYWxsaW5nIGJvdC4KICAgIFJldHVybnM6CiAgICAgICAgT3B0aW9uYWxbQm90XTogUmVmZXJlbmNlIHRvIHRoZSBjYWxsaW5nIGJvdCBvciBOb25lIGlmIG5vdCBmb3VuZAogICAgIiIiCiAgICBmcmFtZSA9IGluc3BlY3QuY3VycmVudGZyYW1lKCkKICAgIHdoaWxlIGZyYW1lOgogICAgICAgIGlmIGZyYW1lLmZfY29kZS5jb19uYW1lID09ICdfY3Zzbl9yZXNwb25kJyBhbmQgJ3NlbGYnIGluIGZyYW1lLmZfbG9jYWxzOgogICAgICAgICAgICBwb3RlbnRpYWxfYm90ID0gZnJhbWUuZl9sb2NhbHNbJ3NlbGYnXQogICAgICAgICAgICBpZiBpc2luc3RhbmNlKHBvdGVudGlhbF9ib3QsIEJvdCk6CiAgICAgICAgICAgICAgICByZXR1cm4gcG90ZW50aWFsX2JvdAogICAgICAgIGZyYW1lID0gZnJhbWUuZl9iYWNrCiAgICByZXR1cm4gTm9uZZSMCWZpbGVfcGF0aJRoXYwJbmFtZXNwYWNllGhkjC5fX3J1bnRpbWVfXy5keW5hbWljX21vZHVsZV83NTcxODQ1ODUzMDEyMTcxMzU1lIWUUpR9lChoN2hMaDZOaFlOaFtOaFxoXWgUaF9oFWhgaBhoYWhiaGZoZ2hpaDRoa2hsaG5ob2hxaHJodGh1aHhoeWh7aHxofmg1aH9ogGiCaINohGiFaIZoh2iIaIloimiLaI9okGiRaJJok2iUaJVolmiXaJhomWiaaJtonGidaJ5on2hGaE9ooGihaKJoo2ikaKZop2ioaKloq2isaMJo02jVaNZo12jYaOCMCWFkZF90b29sc5Ro1GqFAQAAk5SMDGxpc3RfY29udGV4dJRo1GqHAQAAk5SMDnJlbW92ZV9jb250ZXh0lGjUaokBAACTlGpDAQAAaAIoaAQoQwgCCioBRAEWAZRLAUsASwBLAksESwNDipcAdAAAAAAAAAAAAGoDAAAAAAAAAAAAAAAAAAAAAAAAfACrAQAAAAAAAH0BdAUAAAAAAAAAAHwBdAYAAAAAAAAAAKsCAAAAAAAAchJ0CQAAAAAAAAAAZAGEAHwBRACrAAAAAAAAAKsBAAAAAAAAcwt0CwAAAAAAAAAAZAKrAQAAAAAAAIIBfAFTAJRYXAEAAFBhcnNlIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGFuIGFycmF5IGludG8gYSBsaXN0IG9mIHN0cmluZ3MuCiAgICBPbmx5IHdvcmtzIHdpdGggcHJvcGVybHkgZm9ybWF0dGVkIFB5dGhvbiBsaXN0IGxpdGVyYWxzLgogICAgQXJnczoKICAgICAgICBpbnB1dF9zdHIgKHN0cik6IFN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIFB5dGhvbiBsaXN0IGxpdGVyYWwKICAgIFJldHVybnM6CiAgICAgICAgTGlzdFtzdHJdOiBMaXN0IG9mIHBhcnNlZCBzdHJpbmdzCiAgICBSYWlzZXM6CiAgICAgICAgVmFsdWVFcnJvcjogSWYgdGhlIGlucHV0IGlzIG5vdCBhIHZhbGlkIFB5dGhvbiBsaXN0IGxpdGVyYWwKICAgIJRoBChoPksBSwBLAEsCSwVLM0M8SwABAJcAfABdFAAAfQF0AQAAAAAAAAAAfAF0AgAAAAAAAAAAqwIAAAAAAACWAZcBAQCMFgQAeQCtA3cBlGhNaLdoGYaUaiMBAACMAXiUhpRoJ2omAQAAjChfcHJvY2Vzc19zdHJpbmdfYXJyYXkuPGxvY2Fscz4uPGdlbmV4cHI+lEvZQxjoAPiAANAvU8lGwHG0CrgxvGPXMELJRvmUQwSCGhwBlCkpdJRSlIwoSW5wdXQgbXVzdCBldmFsdWF0ZSB0byBhIGxpc3Qgb2Ygc3RyaW5nc5SHlChoYowMbGl0ZXJhbF9ldmFslGi3akgBAACMA2FsbJSMClZhbHVlRXJyb3KUdJSMCWlucHV0X3N0cpRoIYaUaCdqQwEAAGpDAQAAS85DPIAA9BQADhHXDR3RDR2YadMNKIBG3AsVkGacZNQLI6wz0S9TyUbTL1PUK1TcDhjQGUPTDkTQCETYCxGATZRoPikpdJRSlH2UaDdoTHNqQwEAAE5OdJRSlH2UfZQoaDZqjQEAAGhSfZQoap0BAABoV2jGaMloqGhXhpRSlHV1hpRijBFfdmVyYm9zZV9jYWxsYmFja5Ro1GqrAQAAk5SMF19yZW1vdmVfZHVtbXlfZnJvbV90cmVllGjUaq0BAACTlIwIc3ViYWdlbnSUaNRqrwEAAJOUdWKMCWNvZGVfaGFzaJSMIGI4NTgyZDA0YzlhNWNiY2E4NWU1OGU1YWE3YWU2NDEylHVidX2UKGg2aOVoUmp2AQAAdYaUYmqiAQAAKGg3aExoNk5oWU5oWk5oW05oXGhdaBRoX2gVaGBoGGhhaGJoZmhnaGloNGhraGxobmhvaHFocmh0aHVoeGh5aHtofGh+aDVof2iAaIJog2iEaIVohmiHaIhoiWiKaItoj2iQaJFokmiTaJRolWiWaJdomGiZaJpom2icaJ1onmifaEZoT2igaKFoomijaKRopminaKhoqWiraKxowmjTaNVo1mjXaNho4GqFAQAAaoYBAABqhwEAAGqIAQAAaokBAABqigEAAGpDAQAAaqQBAABqqwEAAGqsAQAAaq0BAABqrgEAAGqvAQAAarABAACMDF9fYnVpbHRpbnNfX5RjYnVpbHRpbnMKX19kaWN0X18KdTBqbwEAAChoN2hMaDZOaFlOaFpOaFtOaFxoXWgUaF9oFWhgaBhoYWhiaGZoZ2hpaDRoa2hsaG5ob2hxaHJodGh1aHhoeWh7aHxofmg1aH9ogGiCaINohGiFaIZoh2iIaIloimiLaI9okGiRaJJok2iUaJVolmiXaJhomWiaaJtonGidaJ5on2hGaE9ooGihaKJoo2ikaKZop2ioaKloq2isaMJo02jVaNZo12jYaOBqhQEAAGqGAQAAaocBAABqiAEAAGqJAQAAaooBAABqQwEAAGqkAQAAaqsBAABqrAEAAGqtAQAAaq4BAABqrwEAAGqwAQAAarUBAABjYnVpbHRpbnMKX19kaWN0X18KdTCMCGJ1aWx0aW5zlIwHZ2V0YXR0cpSTlIwEZGlsbJSMBV9kaWxslJOUjAhfc2V0YXR0cpRqtgEAAIwHc2V0YXR0cpSTlIeUUpRo3YwNY2VsbF9jb250ZW50c5RqcwEAAIeUUjBo2ShoN2hMaDZOaFlOaFpOaFtOaFxoXWgUaF9oFWhgaBhoYWhiaGZoZ2hpaDRoa2hsaG5ob2hxaHJodGh1aHhoeWh7aHxofmg1aH9ogGiCaINohGiFaIZoh2iIaIloimiLaI9okGiRaJJok2iUaJVolmiXaJhomWiaaJtonGidaJ5on2hGaE9ooGihaKJoo2ikaKZop2ioaKloq2isaMJo02jVaNZo12jYaOBqhQEAAGqGAQAAaocBAABqiAEAAGqJAQAAaooBAABqQwEAAGqkAQAAaqsBAABqrAEAAGqtAQAAaq4BAABqrwEAAGqwAQAAarUBAABjYnVpbHRpbnMKX19kaWN0X18KdTBqhQEAAGqGAQAAaocBAABqiAEAAGqJAQAAaooBAABqQwEAAGqkAQAAaqsBAABqrAEAAGqtAQAAaq4BAABqrwEAAGqwAQAAarUBAABjYnVpbHRpbnMKX19kaWN0X18KdTBo02jVaNZo12jYaOBqhQEAAGqGAQAAaocBAABqiAEAAGqJAQAAaooBAABqQwEAAGqkAQAAaqsBAABqrAEAAGqtAQAAaq4BAABqrwEAAGqwAQAAarUBAABjYnVpbHRpbnMKX19kaWN0X18KdTAu",
      "name": "toolify",
      "hash": "da28e52b6069d27fd681a092804cc9eb3422b7fb97aece278c7391b29871b696",
      "provenance": {
       "module": "dynamic_module_7571845853012171355",
       "qualname": "toolify"
      }
     },
     "_convert_string_to_type": {
      "__helper_func__": true,
      "pickled": "gASVMwAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjBdfY29udmVydF9zdHJpbmdfdG9fdHlwZZSTlC4=",
      "name": "_convert_string_to_type",
      "hash": "024e40c56cb46e6fe9f52fe7e6e64a3effc17736268ef31195596c6a6be4c311",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "_convert_string_to_type"
      }
     },
     "_log_error_to_file": {
      "__helper_func__": true,
      "pickled": "gASVLgAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjBJfbG9nX2Vycm9yX3RvX2ZpbGWUk5Qu",
      "name": "_log_error_to_file",
      "hash": "c02546b672eb25afd5dc51ea7e1967cbb6fd264ca18ffd15c3cbeccebe4046ba",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "_log_error_to_file"
      }
     },
     "json": {
      "__module_type__": true,
      "name": "json",
      "spec": "json"
     },
     "List": {
      "__imported_callable__": true,
      "pickled": "gASVEwAAAAAAAACMBnR5cGluZ5SMBExpc3SUk5Qu",
      "name": "List",
      "hash": "4177cb372f5ac2e670cf003d399db45b34278d8cf8801c6f8c592fc37176022f",
      "provenance": {
       "module": "typing",
       "qualname": "List"
      }
     },
     "Bot": {
      "__imported_callable__": true,
      "pickled": "gASVIAAAAAAAAACMFGJvdHMuZm91bmRhdGlvbi5iYXNllIwDQm90lJOULg==",
      "name": "Bot",
      "hash": "0a4ab7f39ea6cd147bb4589dad55c5e11e3d88deb65d684e7a6c7e8c28fdc6d1",
      "provenance": {
       "module": "bots.foundation.base",
       "qualname": "Bot"
      }
     },
     "get_own_info": {
      "__imported_callable__": true,
      "pickled": "gASVKgAAAAAAAACMFWJvdHMudG9vbHMuc2VsZl90b29sc5SMDGdldF9vd25faW5mb5STlC4=",
      "name": "get_own_info",
      "hash": "a20f468fbbd729bc4fde649cc3830e7b5c2e833d58d43dd03569e6c0ac35033d",
      "provenance": {
       "module": "bots.tools.self_tools",
       "qualname": "get_own_info"
      }
     },
     "_modify_own_settings": {
      "__helper_func__": true,
      "pickled": "gASVMgAAAAAAAACMFWJvdHMudG9vbHMuc2VsZl90b29sc5SMFF9tb2RpZnlfb3duX3NldHRpbmdzlJOULg==",
      "name": "_modify_own_settings",
      "hash": "3fbf37fea12c6b3b0a4306c19e227a47baa08f0d466d9aa96fba9748699c8d87",
      "provenance": {
       "module": "bots.tools.self_tools",
       "qualname": "_modify_own_settings"
      }
     },
     "branch_self": {
      "__imported_callable__": true,
      "pickled": "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AAEAZCd0FwAAAAAAAAAAfAmrAQAAAAAAAJsAnQJjAlkAZAJ9CX4JUwBkAn0Jfgl3AXcAeANZAHcBlChYHgUAAENyZWF0ZSBtdWx0aXBsZSBjb252ZXJzYXRpb24gYnJhbmNoZXMgdG8gZXhwbG9yZSBkaWZmZXJlbnQgYXBwcm9hY2hlcyBvciB0YWNrbGUgc2VwYXJhdGUgdGFza3MuCgogICAgQ3JlYXRlcyBpc29sYXRlZCBjb252ZXJzYXRpb24gYnJhbmNoZXMgdXNpbmcgZGVlcGNvcHk6CiAgICAxLiBEZWVwY29weSBjdXJyZW50IGJvdCBzdGF0ZSAodXNlcyBfX2dldHN0YXRlX18vX19zZXRzdGF0ZV9fIGZvciBwcm9wZXIgc2VyaWFsaXphdGlvbikKICAgIDIuIEV4ZWN1dGUgZWFjaCBicmFuY2ggd2l0aCBpbmRlcGVuZGVudCBib3QgaW5zdGFuY2VzCiAgICAzLiBTdGl0Y2ggcmVzdWx0cyBiYWNrIGludG8gbWFpbiBjb252ZXJzYXRpb24gdHJlZQoKICAgIE5vdGU6IFVzZXMgZGVlcGNvcHkgd2l0aCBfX2dldHN0YXRlX18vX19zZXRzdGF0ZV9fIHdoaWNoIGxldmVyYWdlcyB0aGUgaHlicmlkCiAgICBzZXJpYWxpemF0aW9uIHN0cmF0ZWd5IChzb3VyY2UgY29kZSArIGRpbGwgZm9yIGhlbHBlcnMpLiBTZWUgYm90cy9mb3VuZGF0aW9uL3Rvb2xfaGFuZGxpbmcubWQuCgogICAgQXJnczoKICAgICAgICBzZWxmX3Byb21wdHMgKHN0cik6IExpc3Qgb2YgcHJvbXB0cyBhcyBhIHN0cmluZyBhcnJheSwgbGlrZSBbJ3Rhc2sgMScsICd0YXNrIDInLCAndGFzayAzJ10KICAgICAgICAgICAgICAgICAgICAgICAgICAgRWFjaCBwcm9tcHQgYmVjb21lcyBhIHNlcGFyYXRlIGNvbnZlcnNhdGlvbiBicmFuY2gKICAgICAgICBhbGxvd193b3JrIChzdHIpOiAnVHJ1ZScgdG8gbGV0IGVhY2ggYnJhbmNoIHVzZSB0b29scyBhbmQgY29udGludWUgd29ya2luZyB1bnRpbCBkb25lCiAgICAgICAgICAgICAgICAgICAgICAgICAnRmFsc2UnIChkZWZhdWx0KSBmb3Igc2luZ2xlLXJlc3BvbnNlIGJyYW5jaGVzCiAgICAgICAgcGFyYWxsZWwgKHN0cik6ICdUcnVlJyB0byBsZXQgYnJhbmNoZXMgd29yayBpbiBwYXJhbGxlbCwgJ0ZhbHNlJyBmb3Igc2VxdWVudGlhbCAoZGVmYXVsdCkuCiAgICAgICAgcmVjb21iaW5lIChzdHIpOiBPbmUgb2YgKCdub25lJywgJ2NvbmNhdGVuYXRlJywgJ2xsbV9tZXJnZScsICdsbG1fdm90ZScsICdsbG1fanVkZ2UnKSwgZGVmYXVsdCAnY29uY2F0ZW5hdGUnLgogICAgICAgICAgICAgICAgICAgICAgICAgQ29tYmluZXMgdGhlIGZpbmFsIG1lc3NhZ2VzIGZyb20gZWFjaCBicmFuY2ggdXNpbmcgdGhhdCBtZXRob2QuCgogICAgUmV0dXJuczoKICAgICAgICBzdHI6IFN1Y2Nlc3MgbWVzc2FnZSB3aXRoIGJyYW5jaCBjb3VudCwgb3IgZXJyb3IgZGV0YWlscyBpZiBzb21ldGhpbmcgd2VudCB3cm9uZwogICAglEsATowSVGhyZWFkUG9vbEV4ZWN1dG9ylIwMYXNfY29tcGxldGVklIaUjBJmdW5jdGlvbmFsX3Byb21wdHOUhZSMIUVycm9yOiBDb3VsZCBub3QgZmluZCBjYWxsaW5nIGJvdJSMBHRydWWUKIwEbm9uZZSMC2NvbmNhdGVuYXRllIwJbGxtX2p1ZGdllIwIbGxtX3ZvdGWUjAlsbG1fbWVyZ2WUdJSMKEVycm9yOiBJbnZhbGlkIHJlY29tYmluZSBvcHRpb24uIFZhbGlkOiCUjCFFcnJvcjogTm8gdmFsaWQgbWVzc2FnZXMgcHJvdmlkZWSUjBdFcnJvciBwYXJzaW5nIHByb21wdHM6IJSMDyhzZWxmLXByb21wdCk6IJSJjARuYW1llGgujBhCcmFuY2hpbmcgaW4gcHJvZ3Jlc3MuLi6UjAx0b29sX3Jlc3VsdHOUiGgEKEMyBAICASIBDgEYATABNAEEASIBNgEi/zoDIgEGAUoBHgEQ/wT+EAQc/BoFEAEIASABBP2USwJLAEsASwdLBksTQpgCAACVBZcACQCJCWoB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lIwBIJSMIiBicmFuY2hlcy4gUmVjb21iaW5hdGlvbiByZXN1bHQ6CgqUjBZFcnJvciBpbiBicmFuY2hfc2VsZjoglHSUKGhxjAl0aHJlYWRpbmeUjBJjb25jdXJyZW50LmZ1dHVyZXOUaDtoPIwKYm90cy5mbG93c5RoPowQX2dldF9jYWxsaW5nX2JvdJSMBWxvd2VylIwVX3Byb2Nlc3Nfc3RyaW5nX2FycmF5lGgWaBRoWGhXjAp0b29sX2NhbGxzlIwDZ2V0lGhSjBhnZW5lcmF0ZV9yZXNwb25zZV9zY2hlbWGUjAZhcHBlbmSUjARsaXN0lIwHZ2V0YXR0cpSMEV9hZGRfdG9vbF9yZXN1bHRzlIwETG9ja5SMBnN1Ym1pdJRoHGhOjANzdW2UjBhib3RzLmZsb3dzLnJlY29tYmluYXRvcnOUaIRoQ2hEaEVoRowDbGVulGhhaGJ0lCiMDHNlbGZfcHJvbXB0c5Rob2iNjAlyZWNvbWJpbmWUaJdoO2g8jBd2YWxpZF9yZWNvbWJpbmVfb3B0aW9uc5SMDG1lc3NhZ2VfbGlzdJRoHWhkjBBwcmVmaXhlZF9wcm9tcHRzlIwNb3JpZ2luYWxfbm9kZZSMEW9yaWdpbmFsX2F1dG9zYXZllIwTZHVtbXlfcmVzdWx0c19hZGRlZJSMEG9yaWdpbmFsX3Jlc3VsdHOUjA1kdW1teV9yZXN1bHRzlIwJdG9vbF9jYWxslIwMZHVtbXlfcmVzdWx0lGhrjAlyZXNwb25zZXOUjAxicmFuY2hfbm9kZXOUjAhleGVjdXRvcpSMB2Z1dHVyZXOUjAZmdXR1cmWUaGhoaYwNc3VjY2Vzc19jb3VudJSMCGNvbWJpbmVklGh7jA92YWxpZF9yZXNwb25zZXOUjAZyZWNvbWKUjAFflIwJZXhlY190eXBllIwJd29ya190eXBllIwOcmVzdWx0X2NvbnRlbnSUaGF0lGgiaC5oLktPQsgDAAD8gADzMAAFENsEFN8EQ90EM9wKGtMKHIBD2QsO2A8y2BEb1xEh0REh0xEjoHbRES2AStgPF49+iX7TDx+gNtEPKYBI2BAZlw+RD9MQIYBJ2h5b0AQb2AcQ0Bgv0Qcv2BE50DpR0DlS0A9T0AhT8AIFBTLcFyyoXNMXOogM2Q8b2BM28AMAEBzxCABCAU4B0xdOwRywdpgvqCaoGNIYMsAc0AQU0BdO8AJRAQUx2Bgb1xgo0RgoiA3YHB+fTJlM0AgZ2BcciAOMDNgeI9AIG9gbH9AIGNgLGNcLI9ILI9gcHohN2B0q1x011B01kAnYExyXPZE9oBbTEyioTdMTOdgjJtcjM9EjM9cjTNEjTMhZ0Fhy0yNzkEzYFCHXFCjRFCioHNUUNvAHAB428QgAEB3cIyesB7ANuH7IctMoUtMjU9AQINgQHdcQL9EQL7AN1BA+2CYq0BAj2Bcgl36RftMXJ4gM9wQWCSTwABYJJPAuABUXiAnYFxmIDNkLE9kRI9QRJagY2WBw0xpx0WBw0FZcmDifP5k/qD64NsA91RtR0GBwkAfQGnHZHiqoN9YeM5BG2CUrp12hXaNfkU6QSJhk2BQd1xQk0RQkoFjUFC7YFCDXFCfRFCeoBNUULfEHAB809wUAEibQESXzDgAbK5AG2SEvsAa4DdMhRpEOkAiYJNgQGdcQINEQIKAY1BAq2BAc1xAj0RAjoETVECnwBwAbK/EIAAwf2Ck5iE3UDCbYFyiIA4wM3Bgb0RxDqQnTHEPTGESIDdgTLYgI2AsUmAbSCx6hOdkqM9MeRakpoFGwcbF9mnGoKYhP0B5F2Q8e3RBM2BMcoA3SEy3YIijXIjTRIjSwX8Bi0yJJkUuQSJlh2BUeoCvSFS3YIijXIjLRIjKwP8BC0FJV0CIy0yJWkUuQSJlh2BUeoCrSFSzYIiinL6EvsC/AMtBQU6Av0yJUkUuQSJlh2BUeoCvSFS3YIijXIjLRIjKwP8BC0FJV0CIy0yJWkUuQSJlh4B89kEjZIiqRSrAMiAnZIy2RS9AzRIgJ2BsysD2wL8ARxDPAfNNDVNBCVdBVVtBXYNBWYdBhYtBjbNBibfAAAG4BUgLwAABTAlsC8AAAUgJcAvAAABpdAogO2A8d0Agd+PRhAgAMFfIAAQUy2BEorBOoUasWqAjQDzHVCDH78AMBBTL84hdO+fJcAQAbcgH3AwASJtERJfzyIgAfRgH49CIADBXyAAMFMdsIGNgIEdcIG9EIG9QIHdgRJ6wDqEGrBqB40A8w1Qgw+/AHAwUx+pRDicEtDUsnAMIADEwLBMIPQRRMJwDDJEIATCcAxSQFTBUDxSkaTBAGxgNBBEwVA8cIQS1MJwDINQdMIgTIPQRMIgTJAUIlTCcAyycJTAgDyzANTAMDyz0BTAgDzAMFTAgDzBAFTBUDzBUFTB8HzBoNTCcAzCcJTRwDzDAhTRcDzREBTRwDzRcFTRwDlCkoaG9ocGhxaHJoc3SUdJRSlH2UaCxoLXNoLowFRmFsc2WUaMpoQ4eUTnSUUpR9lH2UKIwHX19kb2NfX5RoOowPX19hbm5vdGF0aW9uc19flH2UKGiqaACMCl9sb2FkX3R5cGWUk5RoFIWUUpRob2jWaI1o1miraNaMBnJldHVybpRo1nV1hpRijBJfX21vZHVsZV9jb250ZXh0X1+UjBRib3RzLmZvdW5kYXRpb24uYmFzZZSMDU1vZHVsZUNvbnRleHSUk5QpgZR9lChoTGgtjAZzb3VyY2WUWAoqAABkZWYgdG9vbGlmeShkZXNjcmlwdGlvbjogc3RyID0gTm9uZSk6CiAgICAiIiIKICAgIENvbnZlcnQgYW55IGZ1bmN0aW9uIGludG8gYSBib3QgdG9vbCB3aXRoIHN0cmluZy1pbiwgc3RyaW5nLW91dCBpbnRlcmZhY2UuCgogICAgLSBDb252ZXJ0cyBzdHJpbmcgaW5wdXRzIHRvIHByb3BlciB0eXBlcyB1c2luZyB0eXBlIGhpbnRzCiAgICAtIEVuc3VyZXMgc3RyaW5nIG91dHB1dCAoSlNPTiBmb3IgY29tcGxleCB0eXBlcykKICAgIC0gV3JhcHMgaW4gZXJyb3IgaGFuZGxpbmcgKHJldHVybnMgZXJyb3Igc3RyaW5ncywgbmV2ZXIgcmFpc2VzKQogICAgLSBFbmhhbmNlcyBkb2NzdHJpbmcgaWYgZGVzY3JpcHRpb24gcHJvdmlkZWQKCiAgICBBcmdzOgogICAgICAgIGRlc2NyaXB0aW9uIChzdHIsIG9wdGlvbmFsKTogT3ZlcnJpZGUgdGhlIGZ1bmN0aW9uJ3MgZG9jc3RyaW5nCgogICAgRXhhbXBsZToKICAgICAgICBAdG9vbGlmeSgpCiAgICAgICAgZGVmIGFkZF9udW1iZXJzKHg6IGludCwgeTogaW50ID0gMCkgLT4gaW50OgogICAgICAgICAgICByZXR1cm4geCArIHkKCiAgICAgICAgQHRvb2xpZnkoIkNhbGN1bGF0ZSB0aGUgYXJlYSBvZiBhIGNpcmNsZSIpCiAgICAgICAgZGVmIGFyZWEocmFkaXVzOiBmbG9hdCkgLT4gZmxvYXQ6CiAgICAgICAgICAgIHJldHVybiAzLjE0MTU5ICogcmFkaXVzICogcmFkaXVzCiAgICAiIiIKCiAgICBkZWYgZGVjb3JhdG9yKGZ1bmMpOgogICAgICAgIEBmdW5jdG9vbHMud3JhcHMoZnVuYykKICAgICAgICBkZWYgd3JhcHBlcigqYXJncywgKiprd2FyZ3MpOgogICAgICAgICAgICB0cnk6CiAgICAgICAgICAgICAgICAjIENvbnZlcnQgc3RyaW5nIGlucHV0cyB0byBwcm9wZXIgdHlwZXMgdXNpbmcgdHlwZSBoaW50cwogICAgICAgICAgICAgICAgY29udmVydGVkX2FyZ3MsIGNvbnZlcnRlZF9rd2FyZ3MgPSBfY29udmVydF90b29sX2lucHV0cyhmdW5jLCBhcmdzLCBrd2FyZ3MpCgogICAgICAgICAgICAgICAgIyBDYWxsIG9yaWdpbmFsIGZ1bmN0aW9uCiAgICAgICAgICAgICAgICByZXN1bHQgPSBmdW5jKCpjb252ZXJ0ZWRfYXJncywgKipjb252ZXJ0ZWRfa3dhcmdzKQoKICAgICAgICAgICAgICAgICMgQ29udmVydCByZXN1bHQgdG8gc3RyaW5nCiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnZlcnRfdG9vbF9vdXRwdXQocmVzdWx0KQoKICAgICAgICAgICAgZXhjZXB0IEtleWJvYXJkSW50ZXJydXB0IGFzIGU6CiAgICAgICAgICAgICAgICAjIENvbnZlcnQgS2V5Ym9hcmRJbnRlcnJ1cHQgdG8gVG9vbEV4ZWN1dGlvbkVycm9yIHRvIHByZXZlbnQgaXQgZnJvbQogICAgICAgICAgICAgICAgIyBidWJibGluZyB1cCB0byBDTEkgYW5kIGJlaW5nIHRyZWF0ZWQgYXMgdXNlciBDdHJsK0MKICAgICAgICAgICAgICAgIGZyb20gYm90cy51dGlscy5oZWxwZXJzIGltcG9ydCBfcHJvY2Vzc19lcnJvcgoKICAgICAgICAgICAgICAgIHRvb2xfZXJyb3IgPSBUb29sRXhlY3V0aW9uRXJyb3IoZiJUb29sIGV4ZWN1dGlvbiBpbnRlcnJ1cHRlZDoge3N0cihlKX0iKQogICAgICAgICAgICAgICAgcmV0dXJuIF9wcm9jZXNzX2Vycm9yKHRvb2xfZXJyb3IpCgogICAgICAgICAgICBleGNlcHQgVHlwZUVycm9yIGFzIGU6CiAgICAgICAgICAgICAgICAjIENoZWNrIGlmIHRoaXMgaXMgYSBtaXNzaW5nIHJlcXVpcmVkIGFyZ3VtZW50IGVycm9yCiAgICAgICAgICAgICAgICBlcnJvcl9tc2cgPSBzdHIoZSkKICAgICAgICAgICAgICAgIGlmICJtaXNzaW5nIiBpbiBlcnJvcl9tc2cgYW5kICJyZXF1aXJlZCIgaW4gZXJyb3JfbXNnIGFuZCAiYXJndW1lbnQiIGluIGVycm9yX21zZzoKICAgICAgICAgICAgICAgICAgICAjIEFkZCBzcGVjaWFsIG1lc3NhZ2UgZm9yIG91dHB1dCB0b2tlbiBsaW1pdGF0aW9uCiAgICAgICAgICAgICAgICAgICAgZW5oYW5jZWRfZXJyb3IgPSBUeXBlRXJyb3IoCiAgICAgICAgICAgICAgICAgICAgICAgIGYie2Vycm9yX21zZ31cblxuIgogICAgICAgICAgICAgICAgICAgICAgICBmIuKaoO+4jyAgVGhpcyBlcnJvciBpcyBjb21tb25seSBjYXVzZWQgYnkgaGl0dGluZyB0aGUgbWF4X3Rva2VucyBsaW1pdCBiZWZvcmUgY29tcGxldGluZyB0aGUgdG9vbCBjYWxsLlxuIgogICAgICAgICAgICAgICAgICAgICAgICBmIlRoZSByZXNwb25zZSB3YXMgdHJ1bmNhdGVkIG1pZC1wYXJhbWV0ZXIsIG1ha2luZyBpdCBhcHBlYXIgdGhhdCByZXF1aXJlZCBwYXJhbWV0ZXJzIGFyZSBtaXNzaW5nLlxuIgogICAgICAgICAgICAgICAgICAgICAgICBmIlRvIGZpeCB0aGlzOiBXb3JrIGluIFNNQUxMRVIgQ0hVTktTLiBFZGl0IGZld2VyIGxpbmVzIGF0IGEgdGltZSwgIgogICAgICAgICAgICAgICAgICAgICAgICBmIm9yIGJyZWFrIHlvdXIgdGFzayBpbnRvIG11bHRpcGxlIHN0ZXBzLiIKICAgICAgICAgICAgICAgICAgICApCiAgICAgICAgICAgICAgICAgICAgZnJvbSBib3RzLnV0aWxzLmhlbHBlcnMgaW1wb3J0IF9wcm9jZXNzX2Vycm9yCgogICAgICAgICAgICAgICAgICAgIHJldHVybiBfcHJvY2Vzc19lcnJvcihlbmhhbmNlZF9lcnJvcikKICAgICAgICAgICAgICAgIGVsc2U6CiAgICAgICAgICAgICAgICAgICAgZnJvbSBib3RzLnV0aWxzLmhlbHBlcnMgaW1wb3J0IF9wcm9jZXNzX2Vycm9yCgogICAgICAgICAgICAgICAgICAgIHJldHVybiBfcHJvY2Vzc19lcnJvcihlKQogICAgICAgICAgICBleGNlcHQgRXhjZXB0aW9uIGFzIGU6CiAgICAgICAgICAgICAgICBmcm9tIGJvdHMudXRpbHMuaGVscGVycyBpbXBvcnQgX3Byb2Nlc3NfZXJyb3IKCiAgICAgICAgICAgICAgICByZXR1cm4gX3Byb2Nlc3NfZXJyb3IoZSkKCiAgICAgICAgIyBVcGRhdGUgZG9jc3RyaW5nIGlmIGRlc2NyaXB0aW9uIHByb3ZpZGVkCiAgICAgICAgaWYgZGVzY3JpcHRpb246CiAgICAgICAgICAgIHdyYXBwZXIuX19kb2NfXyA9IGRlc2NyaXB0aW9uCiAgICAgICAgZWxpZiBub3Qgd3JhcHBlci5fX2RvY19fOgogICAgICAgICAgICAjIEdlbmVyYXRlIG1pbmltYWwgZG9jc3RyaW5nIGZyb20gZnVuY3Rpb24gbmFtZQogICAgICAgICAgICB3cmFwcGVyLl9fZG9jX18gPSBmIkV4ZWN1dGUge2Z1bmMuX19uYW1lX18ucmVwbGFjZSgnXycsICcgJyl9IgoKICAgICAgICByZXR1cm4gd3JhcHBlcgoKICAgIHJldHVybiBkZWNvcmF0b3IKCkB0b29saWZ5KCkKZGVmIGJyYW5jaF9zZWxmKHNlbGZfcHJvbXB0czogc3RyLCBhbGxvd193b3JrOiBzdHI9J0ZhbHNlJywgcGFyYWxsZWw6IHN0cj0nRmFsc2UnLCByZWNvbWJpbmU6IHN0cj0nY29uY2F0ZW5hdGUnKSAtPiBzdHI6CiAgICAiIiJDcmVhdGUgbXVsdGlwbGUgY29udmVyc2F0aW9uIGJyYW5jaGVzIHRvIGV4cGxvcmUgZGlmZmVyZW50IGFwcHJvYWNoZXMgb3IgdGFja2xlIHNlcGFyYXRlIHRhc2tzLgoKICAgIENyZWF0ZXMgaXNvbGF0ZWQgY29udmVyc2F0aW9uIGJyYW5jaGVzIHVzaW5nIGRlZXBjb3B5OgogICAgMS4gRGVlcGNvcHkgY3VycmVudCBib3Qgc3RhdGUgKHVzZXMgX19nZXRzdGF0ZV9fL19fc2V0c3RhdGVfXyBmb3IgcHJvcGVyIHNlcmlhbGl6YXRpb24pCiAgICAyLiBFeGVjdXRlIGVhY2ggYnJhbmNoIHdpdGggaW5kZXBlbmRlbnQgYm90IGluc3RhbmNlcwogICAgMy4gU3RpdGNoIHJlc3VsdHMgYmFjayBpbnRvIG1haW4gY29udmVyc2F0aW9uIHRyZWUKCiAgICBOb3RlOiBVc2VzIGRlZXBjb3B5IHdpdGggX19nZXRzdGF0ZV9fL19fc2V0c3RhdGVfXyB3aGljaCBsZXZlcmFnZXMgdGhlIGh5YnJpZAogICAgc2VyaWFsaXphdGlvbiBzdHJhdGVneSAoc291cmNlIGNvZGUgKyBkaWxsIGZvciBoZWxwZXJzKS4gU2VlIGJvdHMvZm91bmRhdGlvbi90b29sX2hhbmRsaW5nLm1kLgoKICAgIEFyZ3M6CiAgICAgICAgc2VsZl9wcm9tcHRzIChzdHIpOiBMaXN0IG9mIHByb21wdHMgYXMgYSBzdHJpbmcgYXJyYXksIGxpa2UgWyd0YXNrIDEnLCAndGFzayAyJywgJ3Rhc2sgMyddCiAgICAgICAgICAgICAgICAgICAgICAgICAgIEVhY2ggcHJvbXB0IGJlY29tZXMgYSBzZXBhcmF0ZSBjb252ZXJzYXRpb24gYnJhbmNoCiAgICAgICAgYWxsb3dfd29yayAoc3RyKTogJ1RydWUnIHRvIGxldCBlYWNoIGJyYW5jaCB1c2UgdG9vbHMgYW5kIGNvbnRpbnVlIHdvcmtpbmcgdW50aWwgZG9uZQogICAgICAgICAgICAgICAgICAgICAgICAgJ0ZhbHNlJyAoZGVmYXVsdCkgZm9yIHNpbmdsZS1yZXNwb25zZSBicmFuY2hlcwogICAgICAgIHBhcmFsbGVsIChzdHIpOiAnVHJ1ZScgdG8gbGV0IGJyYW5jaGVzIHdvcmsgaW4gcGFyYWxsZWwsICdGYWxzZScgZm9yIHNlcXVlbnRpYWwgKGRlZmF1bHQpLgogICAgICAgIHJlY29tYmluZSAoc3RyKTogT25lIG9mICgnbm9uZScsICdjb25jYXRlbmF0ZScsICdsbG1fbWVyZ2UnLCAnbGxtX3ZvdGUnLCAnbGxtX2p1ZGdlJyksIGRlZmF1bHQgJ2NvbmNhdGVuYXRlJy4KICAgICAgICAgICAgICAgICAgICAgICAgIENvbWJpbmVzIHRoZSBmaW5hbCBtZXNzYWdlcyBmcm9tIGVhY2ggYnJhbmNoIHVzaW5nIHRoYXQgbWV0aG9kLgoKICAgIFJldHVybnM6CiAgICAgICAgc3RyOiBTdWNjZXNzIG1lc3NhZ2Ugd2l0aCBicmFuY2ggY291bnQsIG9yIGVycm9yIGRldGFpbHMgaWYgc29tZXRoaW5nIHdlbnQgd3JvbmcKICAgICIiIgogICAgaW1wb3J0IGNvcHkKICAgIGltcG9ydCB0aHJlYWRpbmcKICAgIGZyb20gY29uY3VycmVudC5mdXR1cmVzIGltcG9ydCBUaHJlYWRQb29sRXhlY3V0b3IsIGFzX2NvbXBsZXRlZAogICAgZnJvbSBib3RzLmZsb3dzIGltcG9ydCBmdW5jdGlvbmFsX3Byb21wdHMgYXMgZnAKICAgIGJvdCA9IF9nZXRfY2FsbGluZ19ib3QoKQogICAgaWYgbm90IGJvdDoKICAgICAgICByZXR1cm4gJ0Vycm9yOiBDb3VsZCBub3QgZmluZCBjYWxsaW5nIGJvdCcKICAgIGFsbG93X3dvcmsgPSBhbGxvd193b3JrLmxvd2VyKCkgPT0gJ3RydWUnCiAgICBwYXJhbGxlbCA9IHBhcmFsbGVsLmxvd2VyKCkgPT0gJ3RydWUnCiAgICByZWNvbWJpbmUgPSByZWNvbWJpbmUubG93ZXIoKQogICAgdmFsaWRfcmVjb21iaW5lX29wdGlvbnMgPSBbJ25vbmUnLCAnY29uY2F0ZW5hdGUnLCAnbGxtX2p1ZGdlJywgJ2xsbV92b3RlJywgJ2xsbV9tZXJnZSddCiAgICBpZiByZWNvbWJpbmUgbm90IGluIHZhbGlkX3JlY29tYmluZV9vcHRpb25zOgogICAgICAgIHJldHVybiBmJ0Vycm9yOiBJbnZhbGlkIHJlY29tYmluZSBvcHRpb24uIFZhbGlkOiB7dmFsaWRfcmVjb21iaW5lX29wdGlvbnN9JwogICAgdHJ5OgogICAgICAgIG1lc3NhZ2VfbGlzdCA9IF9wcm9jZXNzX3N0cmluZ19hcnJheShzZWxmX3Byb21wdHMpCiAgICAgICAgaWYgbm90IG1lc3NhZ2VfbGlzdDoKICAgICAgICAgICAgcmV0dXJuICdFcnJvcjogTm8gdmFsaWQgbWVzc2FnZXMgcHJvdmlkZWQnCiAgICBleGNlcHQgRXhjZXB0aW9uIGFzIGU6CiAgICAgICAgcmV0dXJuIGYnRXJyb3IgcGFyc2luZyBwcm9tcHRzOiB7c3RyKGUpfScKICAgIHByZWZpeGVkX3Byb21wdHMgPSBbZicoc2VsZi1wcm9tcHQpOiB7cHJvbXB0fScgZm9yIHByb21wdCBpbiBtZXNzYWdlX2xpc3RdCiAgICB0cnk6CiAgICAgICAgb3JpZ2luYWxfbm9kZSA9IGJvdC5jb252ZXJzYXRpb24KICAgICAgICBvcmlnaW5hbF9hdXRvc2F2ZSA9IGJvdC5hdXRvc2F2ZQogICAgICAgIGJvdC5hdXRvc2F2ZSA9IEZhbHNlCiAgICAgICAgZHVtbXlfcmVzdWx0c19hZGRlZCA9IEZhbHNlCiAgICAgICAgb3JpZ2luYWxfcmVzdWx0cyA9IE5vbmUKICAgICAgICBpZiBvcmlnaW5hbF9ub2RlLnRvb2xfY2FsbHM6CiAgICAgICAgICAgIGR1bW15X3Jlc3VsdHMgPSBbXQogICAgICAgICAgICBmb3IgdG9vbF9jYWxsIGluIG9yaWdpbmFsX25vZGUudG9vbF9jYWxsczoKICAgICAgICAgICAgICAgIGlmIHRvb2xfY2FsbC5nZXQoJ25hbWUnKSA9PSAnYnJhbmNoX3NlbGYnOgogICAgICAgICAgICAgICAgICAgIGR1bW15X3Jlc3VsdCA9IGJvdC50b29sX2hhbmRsZXIuZ2VuZXJhdGVfcmVzcG9uc2Vfc2NoZW1hKHRvb2xfY2FsbCwgJ0JyYW5jaGluZyBpbiBwcm9ncmVzcy4uLicpCiAgICAgICAgICAgICAgICAgICAgZHVtbXlfcmVzdWx0cy5hcHBlbmQoZHVtbXlfcmVzdWx0KQogICAgICAgICAgICBpZiBkdW1teV9yZXN1bHRzOgogICAgICAgICAgICAgICAgb3JpZ2luYWxfcmVzdWx0cyA9IGxpc3QoZ2V0YXR0cihvcmlnaW5hbF9ub2RlLCAndG9vbF9yZXN1bHRzJywgW10pKQogICAgICAgICAgICAgICAgb3JpZ2luYWxfbm9kZS5fYWRkX3Rvb2xfcmVzdWx0cyhkdW1teV9yZXN1bHRzKQogICAgICAgICAgICAgICAgZHVtbXlfcmVzdWx0c19hZGRlZCA9IFRydWUKICAgICAgICByZXBsaWVzX2xvY2sgPSB0aHJlYWRpbmcuTG9jaygpCgogICAgICAgIGRlZiBleGVjdXRlX2JyYW5jaChwcm9tcHQsIHBhcmVudF9ib3Rfbm9kZSk6CiAgICAgICAgICAgICIiIkV4ZWN1dGUgYSBzaW5nbGUgYnJhbmNoIHdpdGggdGhlIGdpdmVuIHByb21wdC4iIiIKICAgICAgICAgICAgdHJ5OgogICAgICAgICAgICAgICAgYnJhbmNoX2JvdCA9IGNvcHkuZGVlcGNvcHkoYm90KQogICAgICAgICAgICAgICAgYnJhbmNoX2JvdC5hdXRvc2F2ZSA9IEZhbHNlCiAgICAgICAgICAgICAgICBicmFuY2hpbmdfbm9kZSA9IGJyYW5jaF9ib3QuY29udmVyc2F0aW9uCiAgICAgICAgICAgICAgICBpZiBoYXNhdHRyKGJyYW5jaF9ib3QsICd0b29sX2hhbmRsZXInKSBhbmQgYnJhbmNoX2JvdC50b29sX2hhbmRsZXI6CiAgICAgICAgICAgICAgICAgICAgYnJhbmNoX2JvdC50b29sX2hhbmRsZXIuY2xlYXIoKQogICAgICAgICAgICAgICAgaWYgYWxsb3dfd29yazoKICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IGJyYW5jaF9ib3QucmVzcG9uZChwcm9tcHQpCiAgICAgICAgICAgICAgICAgICAgd2hpbGUgbm90IGZwLmNvbmRpdGlvbnMudG9vbF9ub3RfdXNlZChicmFuY2hfYm90KToKICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBicmFuY2hfYm90LnJlc3BvbmQoJ29rJykKICAgICAgICAgICAgICAgIGVsc2U6CiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBicmFuY2hfYm90LnJlc3BvbmQocHJvbXB0KQogICAgICAgICAgICAgICAgd2l0aCByZXBsaWVzX2xvY2s6CiAgICAgICAgICAgICAgICAgICAgcGFyZW50X2JvdF9ub2RlLnJlcGxpZXMuZXh0ZW5kKGJyYW5jaGluZ19ub2RlLnJlcGxpZXMpCiAgICAgICAgICAgICAgICAgICAgZm9yIG5vZGUgaW4gYnJhbmNoaW5nX25vZGUucmVwbGllczoKICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5wYXJlbnQgPSBwYXJlbnRfYm90X25vZGUKICAgICAgICAgICAgICAgIHJldHVybiAocmVzcG9uc2UsIGJyYW5jaF9ib3QuY29udmVyc2F0aW9uKQogICAgICAgICAgICBleGNlcHQgRXhjZXB0aW9uOgogICAgICAgICAgICAgICAgaW1wb3J0IHRyYWNlYmFjawogICAgICAgICAgICAgICAgdHJhY2ViYWNrLnByaW50X2V4YygpCiAgICAgICAgICAgICAgICByZXR1cm4gKE5vbmUsIE5vbmUpCiAgICAgICAgcmVzcG9uc2VzID0gW10KICAgICAgICBicmFuY2hfbm9kZXMgPSBbXQogICAgICAgIGlmIHBhcmFsbGVsOgogICAgICAgICAgICB3aXRoIFRocmVhZFBvb2xFeGVjdXRvcigpIGFzIGV4ZWN1dG9yOgogICAgICAgICAgICAgICAgZnV0dXJlcyA9IFtleGVjdXRvci5zdWJtaXQoZXhlY3V0ZV9icmFuY2gsIHByb21wdCwgb3JpZ2luYWxfbm9kZSkgZm9yIHByb21wdCBpbiBwcmVmaXhlZF9wcm9tcHRzXQogICAgICAgICAgICAgICAgZm9yIGZ1dHVyZSBpbiBhc19jb21wbGV0ZWQoZnV0dXJlcyk6CiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UsIG5vZGUgPSBmdXR1cmUucmVzdWx0KCkKICAgICAgICAgICAgICAgICAgICByZXNwb25zZXMuYXBwZW5kKHJlc3BvbnNlKQogICAgICAgICAgICAgICAgICAgIGJyYW5jaF9ub2Rlcy5hcHBlbmQobm9kZSkKICAgICAgICBlbHNlOgogICAgICAgICAgICBmb3IgcHJvbXB0IGluIHByZWZpeGVkX3Byb21wdHM6CiAgICAgICAgICAgICAgICByZXNwb25zZSwgbm9kZSA9IGV4ZWN1dGVfYnJhbmNoKHByb21wdCwgb3JpZ2luYWxfbm9kZSkKICAgICAgICAgICAgICAgIHJlc3BvbnNlcy5hcHBlbmQocmVzcG9uc2UpCiAgICAgICAgICAgICAgICBicmFuY2hfbm9kZXMuYXBwZW5kKG5vZGUpCiAgICAgICAgaWYgZHVtbXlfcmVzdWx0c19hZGRlZDoKICAgICAgICAgICAgb3JpZ2luYWxfbm9kZS50b29sX3Jlc3VsdHMgPSBvcmlnaW5hbF9yZXN1bHRzCiAgICAgICAgYm90LmF1dG9zYXZlID0gb3JpZ2luYWxfYXV0b3NhdmUKICAgICAgICBzdWNjZXNzX2NvdW50ID0gc3VtKCgxIGZvciByIGluIHJlc3BvbnNlcyBpZiByIGlzIG5vdCBOb25lKSkKICAgICAgICBjb21iaW5lZCA9ICdObyByZWNvbWJpbmF0b3Igc2VsZWN0ZWQnCiAgICAgICAgaWYgcmVjb21iaW5lICE9ICdub25lJyBhbmQgcmVzcG9uc2VzOgogICAgICAgICAgICB2YWxpZF9yZXNwb25zZXMgPSBbciBmb3IgciBpbiByZXNwb25zZXMgaWYgciBpcyBub3QgTm9uZV0KICAgICAgICAgICAgaWYgdmFsaWRfcmVzcG9uc2VzOgogICAgICAgICAgICAgICAgZnJvbSBib3RzLmZsb3dzLnJlY29tYmluYXRvcnMgaW1wb3J0IHJlY29tYmluYXRvcnMgYXMgcmVjb21iCiAgICAgICAgICAgICAgICBpZiByZWNvbWJpbmUgPT0gJ2NvbmNhdGVuYXRlJzoKICAgICAgICAgICAgICAgICAgICBjb21iaW5lZCwgXyA9IHJlY29tYi5jb25jYXRlbmF0ZSh2YWxpZF9yZXNwb25zZXMsIFtdKQogICAgICAgICAgICAgICAgZWxpZiByZWNvbWJpbmUgPT0gJ2xsbV9qdWRnZSc6CiAgICAgICAgICAgICAgICAgICAgY29tYmluZWQsIF8gPSByZWNvbWIubGxtX2p1ZGdlKHZhbGlkX3Jlc3BvbnNlcywgW10sIGp1ZGdlX2JvdD1ib3QpCiAgICAgICAgICAgICAgICBlbGlmIHJlY29tYmluZSA9PSAnbGxtX3ZvdGUnOgogICAgICAgICAgICAgICAgICAgIGNvbWJpbmVkLCBfID0gcmVjb21iLmxsbV92b3RlKHZhbGlkX3Jlc3BvbnNlcywgW10sIHZvdGVfYm90PWJvdCkKICAgICAgICAgICAgICAgIGVsaWYgcmVjb21iaW5lID09ICdsbG1fbWVyZ2UnOgogICAgICAgICAgICAgICAgICAgIGNvbWJpbmVkLCBfID0gcmVjb21iLmxsbV9tZXJnZSh2YWxpZF9yZXNwb25zZXMsIFtdLCBtZXJnZV9ib3Q9Ym90KQogICAgICAgICAgICAgICAgZWxzZToKICAgICAgICAgICAgICAgICAgICBjb21iaW5lZCA9ICdVbmtub3duIHJlY29tYmluYXRpb24gbWV0aG9kJwogICAgICAgIGV4ZWNfdHlwZSA9ICdwYXJhbGxlbCcgaWYgcGFyYWxsZWwgZWxzZSAnc2VxdWVudGlhbCcKICAgICAgICB3b3JrX3R5cGUgPSAnaXRlcmF0aXZlJyBpZiBhbGxvd193b3JrIGVsc2UgJ3NpbmdsZS1yZXNwb25zZScKICAgICAgICByZXN1bHRfY29udGVudCA9IGYnU3VjY2Vzc2Z1bGx5IGNvbXBsZXRlZCB7c3VjY2Vzc19jb3VudH0ve2xlbihtZXNzYWdlX2xpc3QpfSB7ZXhlY190eXBlfSB7d29ya190eXBlfSBicmFuY2hlcy4gUmVjb21iaW5hdGlvbiByZXN1bHQ6XG5cbntjb21iaW5lZH0nCiAgICAgICAgcmV0dXJuIHJlc3VsdF9jb250ZW50CiAgICBleGNlcHQgRXhjZXB0aW9uIGFzIGU6CiAgICAgICAgaW1wb3J0IHRyYWNlYmFjawogICAgICAgIHRyYWNlYmFjay5wcmludF9leGMoKQogICAgICAgIHJldHVybiBmJ0Vycm9yIGluIGJyYW5jaF9zZWxmOiB7c3RyKGUpfScKCmRlZiBfcHJvY2Vzc19zdHJpbmdfYXJyYXkoaW5wdXRfc3RyOiBzdHIpIC0+IExpc3Rbc3RyXToKICAgICIiIlBhcnNlIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGFuIGFycmF5IGludG8gYSBsaXN0IG9mIHN0cmluZ3MuCiAgICBPbmx5IHdvcmtzIHdpdGggcHJvcGVybHkgZm9ybWF0dGVkIFB5dGhvbiBsaXN0IGxpdGVyYWxzLgogICAgQXJnczoKICAgICAgICBpbnB1dF9zdHIgKHN0cik6IFN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIFB5dGhvbiBsaXN0IGxpdGVyYWwKICAgIFJldHVybnM6CiAgICAgICAgTGlzdFtzdHJdOiBMaXN0IG9mIHBhcnNlZCBzdHJpbmdzCiAgICBSYWlzZXM6CiAgICAgICAgVmFsdWVFcnJvcjogSWYgdGhlIGlucHV0IGlzIG5vdCBhIHZhbGlkIFB5dGhvbiBsaXN0IGxpdGVyYWwKICAgICIiIgogICAgcmVzdWx0ID0gYXN0LmxpdGVyYWxfZXZhbChpbnB1dF9zdHIpCiAgICBpZiBub3QgaXNpbnN0YW5jZShyZXN1bHQsIGxpc3QpIG9yIG5vdCBhbGwoKGlzaW5zdGFuY2UoeCwgc3RyKSBmb3IgeCBpbiByZXN1bHQpKToKICAgICAgICByYWlzZSBWYWx1ZUVycm9yKCdJbnB1dCBtdXN0IGV2YWx1YXRlIHRvIGEgbGlzdCBvZiBzdHJpbmdzJykKICAgIHJldHVybiByZXN1bHQKCmRlZiBfZ2V0X2NhbGxpbmdfYm90KCkgLT4gT3B0aW9uYWxbQm90XToKICAgICIiIkhlbHBlciBmdW5jdGlvbiB0byBnZXQgYSByZWZlcmVuY2UgdG8gdGhlIGNhbGxpbmcgYm90LgogICAgUmV0dXJuczoKICAgICAgICBPcHRpb25hbFtCb3RdOiBSZWZlcmVuY2UgdG8gdGhlIGNhbGxpbmcgYm90IG9yIE5vbmUgaWYgbm90IGZvdW5kCiAgICAiIiIKICAgIGZyYW1lID0gaW5zcGVjdC5jdXJyZW50ZnJhbWUoKQogICAgd2hpbGUgZnJhbWU6CiAgICAgICAgaWYgZnJhbWUuZl9jb2RlLmNvX25hbWUgPT0gJ19jdnNuX3Jlc3BvbmQnIGFuZCAnc2VsZicgaW4gZnJhbWUuZl9sb2NhbHM6CiAgICAgICAgICAgIHBvdGVudGlhbF9ib3QgPSBmcmFtZS5mX2xvY2Fsc1snc2VsZiddCiAgICAgICAgICAgIGlmIGlzaW5zdGFuY2UocG90ZW50aWFsX2JvdCwgQm90KToKICAgICAgICAgICAgICAgIHJldHVybiBwb3RlbnRpYWxfYm90CiAgICAgICAgZnJhbWUgPSBmcmFtZS5mX2JhY2sKICAgIHJldHVybiBOb25llIwJZmlsZV9wYXRolIwiZHluYW1pY19tb2R1bGVfMzkxMzkwMTExNzUwMDM1NzA4MZSMCW5hbWVzcGFjZZRoAIwOX2ltcG9ydF9tb2R1bGWUk5SMLl9fcnVudGltZV9fLmR5bmFtaWNfbW9kdWxlXzc1NzE4NDU4NTMwMTIxNzEzNTWUhZRSlH2UKGgsaC1o0E6MC19fcGFja2FnZV9flE6MCF9fc3BlY19flE6MCF9fZmlsZV9flGjiaA+ME2JvdHMuZGV2LmRlY29yYXRvcnOUaA+TlGgQaO1oEJOUaBNo7WgTk5SMA2FzdJRo5WjxhZRSlIwIZGF0ZXRpbWWUaOVo9IWUUpSMCWZ1bmN0b29sc5Ro5Wj3hZRSlIwHaW5zcGVjdJRo5Wj6hZRSlIwHbG9nZ2luZ5Ro5Wj9hZRSlIwCb3OUaOVqAAEAAIWUUpSMA3N5c5Ro5YwDc3lzlIWUUpSMCHRleHR3cmFwlGjlagcBAACFlFKUaGFo5WhhhZRSlIwFd3JhcHOUaPdqDAEAAJOUjANBbnmUjAZ0eXBpbmeUag4BAACTlIwIQ2FsbGFibGWUag8BAABqEQEAAJOUjAhPcHRpb25hbJRqDwEAAGoTAQAAk5SMBFR5cGWUag8BAABqFQEAAJOUjBJyZW1vdmVfY29kZV9ibG9ja3OUaBJqFwEAAJOUjAZsb2dnZXKUaP2MCWdldExvZ2dlcpSTlGjthZRSlIwMTm9IVFRQRmlsdGVylGjtah4BAACTlIwHbGF6eV9mbpRo7WogAQAAk5SMCmxhenlfY2xhc3OUaO1qIgEAAJOUjAxfZ2V0X2NvbnRleHSUaO1qJAEAAJOUjBFfZ2V0X3B5X2lu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",
      "name": "branch_self",
      "hash": "7f947dfcdb0d2702dc61e6cb92a418f8025874f50bea7561c6fc730d05bc0b7f",
      "provenance": {
       "module": "dynamic_module_7571845853012171355",
       "qualname": "branch_self"
      }
     },
     "add_tools": {
      "__imported_callable__": true,
      "pickled": "gASVJwAAAAAAAACMFWJvdHMudG9vbHMuc2VsZl90b29sc5SMCWFkZF90b29sc5STlC4=",
      "name": "add_tools",
      "hash": "e426bca163b5fc4ada03a5244a935139d0d4d742aaec2eb42e1da978c803b0f5",
      "provenance": {
       "module": "bots.tools.self_tools",
       "qualname": "add_tools"
      }
     },
     "list_context": {
      "__imported_callable__": true,
      "pickled": "gASVKgAAAAAAAACMFWJvdHMudG9vbHMuc2VsZl90b29sc5SMDGxpc3RfY29udGV4dJSTlC4=",
      "name": "list_context",
      "hash": "aca8c5a8ea74321c4dc4321a0d13b6543630a1356e337bd5e37aab9705920375",
      "provenance": {
       "module": "bots.tools.self_tools",
       "qualname": "list_context"
      }
     },
     "remove_context": {
      "__imported_callable__": true,
      "pickled": "gASVLAAAAAAAAACMFWJvdHMudG9vbHMuc2VsZl90b29sc5SMDnJlbW92ZV9jb250ZXh0lJOULg==",
      "name": "remove_context",
      "hash": "844c0a8c9292aa5651b8dbf5a4ed403cef362e98c3448da0d83540e8db749da8",
      "provenance": {
       "module": "bots.tools.self_tools",
       "qualname": "remove_context"
      }
     },
     "_verbose_callback": {
      "__helper_func__": true,
      "pickled": "gASVLwAAAAAAAACMFWJvdHMudG9vbHMuc2VsZl90b29sc5SMEV92ZXJib3NlX2NhbGxiYWNrlJOULg==",
      "name": "_verbose_callback",
      "hash": "9c82e7d02bb30f7619e98eb4592178e595349398b083ec309b7df6faf745facb",
      "provenance": {
       "module": "bots.tools.self_tools",
       "qualname": "_verbose_callback"
      }
     },
     "_remove_dummy_from_tree": {
      "__helper_func__": true,
      "pickled": "gASVNQAAAAAAAACMFWJvdHMudG9vbHMuc2VsZl90b29sc5SMF19yZW1vdmVfZHVtbXlfZnJvbV90cmVllJOULg==",
      "name": "_remove_dummy_from_tree",
      "hash": "28ace6295e4d8788a37a54c2b3ad9dd47cd633b12018c5e828417877fdbcf222",
      "provenance": {
       "module": "bots.tools.self_tools",
       "qualname": "_remove_dummy_from_tree"
      }
     },
     "subagent": {
      "__imported_callable__": true,
      "pickled": "gASVJgAAAAAAAACMFWJvdHMudG9vbHMuc2VsZl90b29sc5SMCHN1YmFnZW50lJOULg==",
      "name": "subagent",
      "hash": "7906556f7bb3787822292780a7ca91117f5a21efc476be7449ee5bf3f1da82ca",
      "provenance": {
       "module": "bots.tools.self_tools",
       "qualname": "subagent"
      }
     }
    }
   },
   "dynamic_module_8141535594493942321": {
    "name": "dynamic_module_5021674588523893096",
    "source": "from bots.utils.helpers import _process_error\nfrom typing import List, Optional\n\ndef toolify(description: str = None):\n    \"\"\"\n    Convert any function into a bot tool with string-in, string-out interface.\n\n    - Converts string inputs to proper types using type hints\n    - Ensures string output (JSON for complex types)\n    - Wraps in error handling (returns error strings, never raises)\n    - Enhances docstring if description provided\n\n    Args:\n        description (str, optional): Override the function's docstring\n\n    Example:\n        @toolify()\n        def add_numbers(x: int, y: int = 0) -> int:\n            return x + y\n\n        @toolify(\"Calculate the area of a circle\")\n        def area(radius: float) -> float:\n            return 3.14159 * radius * radius\n    \"\"\"\n\n    def decorator(func):\n        @functools.wraps(func)\n        def wrapper(*args, **kwargs):\n            try:\n                # Convert string inputs to proper types using type hints\n                converted_args, converted_kwargs = _convert_tool_inputs(func, args, kwargs)\n\n                # Call original function\n                result = func(*converted_args, **converted_kwargs)\n\n                # Convert result to string\n                return _convert_tool_output(result)\n\n            except KeyboardInterrupt as e:\n                # Convert KeyboardInterrupt to ToolExecutionError to prevent it from\n                # bubbling up to CLI and being treated as user Ctrl+C\n\n                tool_error = ToolExecutionError(f\"Tool execution interrupted: {str(e)}\")\n                return _process_error(tool_error)\n\n            except TypeError as e:\n                # Check if this is a missing required argument error\n                error_msg = str(e)\n                if \"missing\" in error_msg and \"required\" in error_msg and \"argument\" in error_msg:\n                    # Add special message for output token limitation\n                    enhanced_error = TypeError(\n                        f\"{error_msg}\\n\\n\"\n                        f\"\u26a0\ufe0f  This error is commonly caused by hitting the max_tokens limit before completing the tool call.\\n\"\n                        f\"The response was truncated mid-parameter, making it appear that required parameters are missing.\\n\"\n                        f\"To fix this: Work in SMALLER CHUNKS. Edit fewer lines at a time, \"\n                        f\"or break your task into multiple steps.\"\n                    )\n\n                    return _process_error(enhanced_error)\n                else:\n\n                    return _process_error(e)\n            except Exception as e:\n\n                return _process_error(e)\n\n        # Update docstring if description provided\n        if description:\n            wrapper.__doc__ = description\n        elif not wrapper.__doc__:\n            # Generate minimal docstring from function name\n            wrapper.__doc__ = f\"Execute {func.__name__.replace('_', ' ')}\"\n\n        return wrapper\n\n    return decorator\n\n@toolify()\ndef remove_context(labels: str) -> str:\n    \"\"\"Remove bot-user message pairs from the conversation history.\n\n    Use when you need to delete specific messages from your conversation tree\n    to reduce context or remove irrelevant information. This is a demo tool\n    that removes message pairs by stitching the tree after deletion.\n\n    Note: This tool has limitations with branched conversations and will\n    attempt to handle the simplest case (linear conversation paths).\n\n    Parameters:\n        labels (str): String representation of a list of labels to remove.\n            Format: \"['A', 'B', 'C']\"\n            Use list_context() first to see available labels.\n\n    Returns:\n        str: Success message with count of removed pairs, or error message\n\n    Example:\n        remove_context(\"['A', 'C']\")\n    \"\"\"\n    bot = _get_calling_bot()\n    if not bot:\n        return 'Error: Could not find calling bot'\n    try:\n        label_list = _process_string_array(labels)\n        if not label_list:\n            return 'Error: No valid labels provided'\n    except Exception as e:\n        return f'Error parsing labels: {str(e)}'\n    root = bot.conversation._find_root()\n    bot_nodes = []\n\n    def collect_bot_nodes(node):\n        \"\"\"Recursively collect all bot (assistant) nodes in order.\"\"\"\n        if hasattr(node, 'role') and node.role == 'assistant':\n            bot_nodes.append(node)\n        for reply in node.replies:\n            collect_bot_nodes(reply)\n    collect_bot_nodes(root)\n    if not bot_nodes:\n        return 'Error: No bot messages found in conversation'\n\n    def generate_label(index):\n        \"\"\"Generate Excel-style column labels: A, B, ..., Z, AA, AB, ...\"\"\"\n        label = ''\n        index += 1\n        while index > 0:\n            index -= 1\n            label = chr(65 + index % 26) + label\n            index //= 26\n        return label\n    label_to_node = {}\n    for i, node in enumerate(bot_nodes):\n        label = generate_label(i)\n        label_to_node[label] = node\n    nodes_to_remove = []\n    missing_labels = []\n    for label in label_list:\n        if label in label_to_node:\n            nodes_to_remove.append(label_to_node[label])\n        else:\n            missing_labels.append(label)\n    if missing_labels and (not nodes_to_remove):\n        return f'Error: None of the provided labels were found: {missing_labels}'\n    removed_count = 0\n    errors = []\n    for bot_node in nodes_to_remove:\n        try:\n            if not bot_node.parent:\n                errors.append('Cannot remove root node')\n                continue\n            parent = bot_node.parent\n            if len(bot_node.replies) == 0:\n                errors.append('Bot node has no child user node to remove')\n                continue\n            if len(bot_node.replies) > 1:\n                errors.append('Bot node has multiple children - cannot determine which to remove')\n                continue\n            user_node = bot_node.replies[0]\n            if not (hasattr(user_node, 'role') and user_node.role == 'user'):\n                errors.append(\"Bot node's child is not a user node\")\n                continue\n            if bot_node in parent.replies:\n                original_index = parent.replies.index(bot_node)\n                parent.replies.remove(bot_node)\n                insert_index = original_index\n                for child in user_node.replies:\n                    child.parent = parent\n                    parent.replies.insert(insert_index, child)\n                    insert_index += 1\n            else:\n                for child in user_node.replies:\n                    child.parent = parent\n                    parent.replies.append(child)\n            current = bot.conversation\n            while current:\n                if current == bot_node or current == user_node:\n                    bot.conversation = parent\n                    break\n                current = current.parent\n            removed_count += 1\n        except Exception as e:\n            errors.append(f'Failed to remove node pair: {str(e)}')\n            continue\n    result_parts = []\n    if removed_count > 0:\n        result_parts.append(f'Successfully removed {removed_count} message pair(s)')\n    if missing_labels:\n        result_parts.append(f'Missing labels: {missing_labels}')\n    if errors:\n        result_parts.append(f\"Errors: {'; '.join(errors)}\")\n    if not result_parts:\n        return 'No messages were removed'\n    return ' | '.join(result_parts)\n\ndef _process_string_array(input_str: str) -> List[str]:\n    \"\"\"Parse a string representation of an array into a list of strings.\n    Only works with properly formatted Python list literals.\n    Args:\n        input_str (str): String representation of a Python list literal\n    Returns:\n        List[str]: List of parsed strings\n    Raises:\n        ValueError: If the input is not a valid Python list literal\n    \"\"\"\n    result = ast.literal_eval(input_str)\n    if not isinstance(result, list) or not all((isinstance(x, str) for x in result)):\n        raise ValueError('Input must evaluate to a list of strings')\n    return result\n\ndef _get_calling_bot() -> Optional[Bot]:\n    \"\"\"Helper function to get a reference to the calling bot.\n    Returns:\n        Optional[Bot]: Reference to the calling bot or None if not found\n    \"\"\"\n    frame = inspect.currentframe()\n    while frame:\n        if frame.f_code.co_name == '_cvsn_respond' and 'self' in frame.f_locals:\n            potential_bot = frame.f_locals['self']\n            if isinstance(potential_bot, Bot):\n                return potential_bot\n        frame = frame.f_back\n    return None",
    "file_path": "dynamic_module_8141535594493942321",
    "code_hash": "b057461dba9fd2cdc1e16ad0e39b05e8",
    "globals": {
     "_convert_tool_inputs": {
      "__helper_func__": true,
      "pickled": "gASVMAAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjBRfY29udmVydF90b29sX2lucHV0c5STlC4=",
      "name": "_convert_tool_inputs",
      "hash": "8bc4aba1c7d69350a812d8553b6a7ff0cd23ae5c818f3b9533752a69e91acf2e",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "_convert_tool_inputs"
      }
     },
     "_convert_tool_output": {
      "__helper_func__": true,
      "pickled": "gASVMAAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjBRfY29udmVydF90b29sX291dHB1dJSTlC4=",
      "name": "_convert_tool_output",
      "hash": "6c85767d30db1c50646d25d2b954c893aed15774f97345f9b8c99674c59cf928",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "_convert_tool_output"
      }
     },
     "ToolExecutionError": {
      "__imported_callable__": true,
      "pickled": "gASVLgAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjBJUb29sRXhlY3V0aW9uRXJyb3KUk5Qu",
      "name": "ToolExecutionError",
      "hash": "e3f136f46cc3014d1b1a8ac6716adb9da7db1dd83f2ed8529e090d97ae0db998",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "ToolExecutionError"
      }
     },
     "ast": {
      "__module_type__": true,
      "name": "ast",
      "spec": "ast"
     },
     "datetime": {
      "__module_type__": true,
      "name": "datetime",
      "spec": "datetime"
     },
     "functools": {
      "__module_type__": true,
      "name": "functools",
      "spec": "functools"
     },
     "inspect": {
      "__module_type__": true,
      "name": "inspect",
      "spec": "inspect"
     },
     "logging": {
      "__module_type__": true,
      "name": "logging",
      "spec": "logging"
     },
     "os": {
      "__module_type__": true,
      "name": "os",
      "spec": "os"
     },
     "sys": {
      "__module_type__": true,
      "name": "sys",
      "spec": "sys"
     },
     "textwrap": {
      "__module_type__": true,
      "name": "textwrap",
      "spec": "textwrap"
     },
     "traceback": {
      "__module_type__": true,
      "name": "traceback",
      "spec": "traceback"
     },
     "wraps": {
      "__imported_callable__": true,
      "pickled": "gASVFwAAAAAAAACMCWZ1bmN0b29sc5SMBXdyYXBzlJOULg==",
      "name": "wraps",
      "hash": "4c7c8f91a978a903bce2515f7fe83cb09b7074259dabad02b312209312f718ed",
      "provenance": {
       "module": "functools",
       "qualname": "wraps"
      }
     },
     "Any": {
      "__imported_callable__": true,
      "pickled": "gASVEgAAAAAAAACMBnR5cGluZ5SMA0FueZSTlC4=",
      "name": "Any",
      "hash": "fbf19bc6bf716a555ce7094664e2bc898734e4acfc2cd6d9ee399edef2e5c02b",
      "provenance": {
       "module": "typing",
       "qualname": "Any"
      }
     },
     "Callable": {
      "__imported_callable__": true,
      "pickled": "gASVFwAAAAAAAACMBnR5cGluZ5SMCENhbGxhYmxllJOULg==",
      "name": "Callable",
      "hash": "17cf7f09b805961290dccb95aa11199df32c246cb879f355ffa1a31d6285edad",
      "provenance": {
       "module": "typing",
       "qualname": "Callable"
      }
     },
     "Optional": {
      "__imported_callable__": true,
      "pickled": "gASVFwAAAAAAAACMBnR5cGluZ5SMCE9wdGlvbmFslJOULg==",
      "name": "Optional",
      "hash": "d69b63c158dd563d1537447d9d3a68afdda0efb70794ab11c234d01e2e593e56",
      "provenance": {
       "module": "typing",
       "qualname": "Optional"
      }
     },
     "Type": {
      "__imported_callable__": true,
      "pickled": "gASVEwAAAAAAAACMBnR5cGluZ5SMBFR5cGWUk5Qu",
      "name": "Type",
      "hash": "9e98fdb991d3addb0aad6e13cd94b21998f5d97e9f30b15f9c697afe5cde1832",
      "provenance": {
       "module": "typing",
       "qualname": "Type"
      }
     },
     "remove_code_blocks": {
      "__imported_callable__": true,
      "pickled": "gASVLQAAAAAAAACMEmJvdHMudXRpbHMuaGVscGVyc5SMEnJlbW92ZV9jb2RlX2Jsb2Nrc5STlC4=",
      "name": "remove_code_blocks",
      "hash": "44524fda389310a2a28f80da99409efd110baefaa9ea50345d092a634c89fc1d",
      "provenance": {
       "module": "bots.utils.helpers",
       "qualname": "remove_code_blocks"
      }
     },
     "NoHTTPFilter": {
      "__imported_callable__": true,
      "pickled": "gASVKAAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjAxOb0hUVFBGaWx0ZXKUk5Qu",
      "name": "NoHTTPFilter",
      "hash": "9f920bc687c51afef3dea517f9b64393473ed37dac3fda0cedd01a655b483a52",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "NoHTTPFilter"
      }
     },
     "lazy_fn": {
      "__imported_callable__": true,
      "pickled": "gASVIwAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjAdsYXp5X2ZulJOULg==",
      "name": "lazy_fn",
      "hash": "a1737e2cf8adde594f0dd0b3f17ffaad4c126dcf16906e82cb07f18c13d8b7a2",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "lazy_fn"
      }
     },
     "lazy_class": {
      "__imported_callable__": true,
      "pickled": "gASVJgAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjApsYXp5X2NsYXNzlJOULg==",
      "name": "lazy_class",
      "hash": "d1883fc4e7eb2d64f47b4e90b4b6b69d0c5be0d0e3175787058ad631d122e4c6",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "lazy_class"
      }
     },
     "_get_context": {
      "__helper_func__": true,
      "pickled": "gASVKAAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjAxfZ2V0X2NvbnRleHSUk5Qu",
      "name": "_get_context",
      "hash": "979ef249cdc1f76f4020d948ffc352f7c667afb0d89f221770156eebd7717c7a",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "_get_context"
      }
     },
     "_get_py_interface": {
      "__helper_func__": true,
      "pickled": "gASVLQAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjBFfZ2V0X3B5X2ludGVyZmFjZZSTlC4=",
      "name": "_get_py_interface",
      "hash": "d45b0506fb8815e8d9c3a9217b0ca101dac4fb9f51c8546285cf68a95ab027e7",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "_get_py_interface"
      }
     },
     "lazy": {
      "__imported_callable__": true,
      "pickled": "gASVIAAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjARsYXp5lJOULg==",
      "name": "lazy",
      "hash": "6e25446d8765ac65a5518c01582ddf52784eb90c51d57e224c94823d5b7c55cd",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "lazy"
      }
     },
     "debug_on_error": {
      "__imported_callable__": true,
      "pickled": "gASVKgAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjA5kZWJ1Z19vbl9lcnJvcpSTlC4=",
      "name": "debug_on_error",
      "hash": "06d89d594519c41c1dae666437441d4fd4aeeea959f1c905694940a50ae4ddfe",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "debug_on_error"
      }
     },
     "log_errors": {
      "__imported_callable__": true,
      "pickled": "gASVJgAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjApsb2dfZXJyb3JzlJOULg==",
      "name": "log_errors",
      "hash": "f9446c0ae11aa5bb7726b83da744e8dc707a91edc91085abbca1cefd1897d829",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "log_errors"
      }
     },
     "toolify": {
      "__imported_callable__": true,
      "pickled": "gASVeFMAAAAAAACMCmRpbGwuX2RpbGyUjBBfY3JlYXRlX2Z1bmN0aW9ulJOUKGgAjAxfY3JlYXRlX2NvZGWUk5QoQwQEFgo2lEsBSwBLAEsCSwJLA0MShwCXAIgAZgFkAYQIfQF8AVMAlFiIAgAACiAgICBDb252ZXJ0IGFueSBmdW5jdGlvbiBpbnRvIGEgYm90IHRvb2wgd2l0aCBzdHJpbmctaW4sIHN0cmluZy1vdXQgaW50ZXJmYWNlLgoKICAgIC0gQ29udmVydHMgc3RyaW5nIGlucHV0cyB0byBwcm9wZXIgdHlwZXMgdXNpbmcgdHlwZSBoaW50cwogICAgLSBFbnN1cmVzIHN0cmluZyBvdXRwdXQgKEpTT04gZm9yIGNvbXBsZXggdHlwZXMpCiAgICAtIFdyYXBzIGluIGVycm9yIGhhbmRsaW5nIChyZXR1cm5zIGVycm9yIHN0cmluZ3MsIG5ldmVyIHJhaXNlcykKICAgIC0gRW5oYW5jZXMgZG9jc3RyaW5nIGlmIGRlc2NyaXB0aW9uIHByb3ZpZGVkCgogICAgQXJnczoKICAgICAgICBkZXNjcmlwdGlvbiAoc3RyLCBvcHRpb25hbCk6IE92ZXJyaWRlIHRoZSBmdW5jdGlvbidzIGRvY3N0cmluZwoKICAgIEV4YW1wbGU6CiAgICAgICAgQHRvb2xpZnkoKQogICAgICAgIGRlZiBhZGRfbnVtYmVycyh4OiBpbnQsIHk6IGludCA9IDApIC0+IGludDoKICAgICAgICAgICAgcmV0dXJuIHggKyB5CgogICAgICAgIEB0b29saWZ5KCJDYWxjdWxhdGUgdGhlIGFyZWEgb2YgYSBjaXJjbGUiKQogICAgICAgIGRlZiBhcmVhKHJhZGl1czogZmxvYXQpIC0+IGZsb2F0OgogICAgICAgICAgICByZXR1cm4gMy4xNDE1OSAqIHJhZGl1cyAqIHJhZGl1cwogICAglGgEKEMUBgEoAQj/CAECLAQBDgUE/BgCSAKUSwFLAEsASwJLBUsTQ7qVAYcAlwB0AAAAAAAAAAAAagMAAAAAAAAAAAAAAAAAAAAAAACJAKsBAAAAAAAAiABmAWQBhAirAAAAAAAAAH0BiQJyCYkCfAFfAgAAAAAAAAAAfAFTAHwBagQAAAAAAAAAAAAAAAAAAAAAAABzJGQCiQBqBgAAAAAAAAAAAAAAAAAAAAAAAGoJAAAAAAAAAAAAAAAAAAAAAAAAZANkBKsCAAAAAAAAmwCdAnwBXwIAAAAAAAAAAHwBUwCUKE5oBChDLAQCAgIgAxADGAIQAwwCLgEiAhACFgEYAgoBCP8KBwwCGgIMAiIBEAEMAiL9lEsASwBLAEsKSwdLH0KuAQAAlQGXAAkAdAEAAAAAAAAAAIkKfAB8AasDAAAAAAAAXAIAAH0CfQMCAIkKfAJpAHwDpAGOAX0EdAMAAAAAAAAAAHwEqwEAAAAAAABTACMAdAQAAAAAAAAAACQAci99BWQBZAJsA20EfQYBAHQLAAAAAAAAAABkA3QNAAAAAAAAAAB8BasBAAAAAAAAmwCdAqsBAAAAAAAAfQcCAHwGfAerAQAAAAAAAGMCWQBkAH0FfgVTAGQAfQV+BXcBdA4AAAAAAAAAACQAclB9BXQNAAAAAAAAAAB8BasBAAAAAAAAfQhkBHwIdgByKWQFfAh2AHIlZAZ8CHYAciF0DwAAAAAAAAAAfAibAGQHnQKrAQAAAAAAAH0JZAFkAmwDbQR9BgEAAgB8BnwJqwEAAAAAAABjAlkAZAB9BX4FUwBkAWQCbANtBH0GAQACAHwGfAWrAQAAAAAAAGMCWQBkAH0FfgVTAGQAfQV+BXcBdBAAAAAAAAAAACQAchh9BWQBZAJsA20EfQYBAAIAfAZ8BasBAAAAAAAAYwJZAGQAfQV+BVMAZAB9BX4FdwF3AHgDWQB3AZQoTksAjA5fcHJvY2Vzc19lcnJvcpSFlIwcVG9vbCBleGVjdXRpb24gaW50ZXJydXB0ZWQ6IJSMB21pc3NpbmeUjAhyZXF1aXJlZJSMCGFyZ3VtZW50lFgyAQAACgrimqDvuI8gIFRoaXMgZXJyb3IgaXMgY29tbW9ubHkgY2F1c2VkIGJ5IGhpdHRpbmcgdGhlIG1heF90b2tlbnMgbGltaXQgYmVmb3JlIGNvbXBsZXRpbmcgdGhlIHRvb2wgY2FsbC4KVGhlIHJlc3BvbnNlIHdhcyB0cnVuY2F0ZWQgbWlkLXBhcmFtZXRlciwgbWFraW5nIGl0IGFwcGVhciB0aGF0IHJlcXVpcmVkIHBhcmFtZXRlcnMgYXJlIG1pc3NpbmcuClRvIGZpeCB0aGlzOiBXb3JrIGluIFNNQUxMRVIgQ0hVTktTLiBFZGl0IGZld2VyIGxpbmVzIGF0IGEgdGltZSwgb3IgYnJlYWsgeW91ciB0YXNrIGludG8gbXVsdGlwbGUgc3RlcHMulHSUKIwUX2NvbnZlcnRfdG9vbF9pbnB1dHOUjBRfY29udmVydF90b29sX291dHB1dJSMEUtleWJvYXJkSW50ZXJydXB0lIwSYm90cy51dGlscy5oZWxwZXJzlGgMjBJUb29sRXhlY3V0aW9uRXJyb3KUjANzdHKUjAlUeXBlRXJyb3KUjAlFeGNlcHRpb26UdJQojARhcmdzlIwGa3dhcmdzlIwOY29udmVydGVkX2FyZ3OUjBBjb252ZXJ0ZWRfa3dhcmdzlIwGcmVzdWx0lIwBZZRoDIwKdG9vbF9lcnJvcpSMCWVycm9yX21zZ5SMDmVuaGFuY2VkX2Vycm9ylHSUjAg8c3RyaW5nPpSMB3dyYXBwZXKUjCt0b29saWZ5Ljxsb2NhbHM+LmRlY29yYXRvci48bG9jYWxzPi53cmFwcGVylEsYQ+34gADwBCgNKeQzR8gEyGTQVFrTM1vREDCQDtAgMPEGABoemH7QGULQMUHRGUKQBvQGABgsqEbTFzPQEDP45BMk8gAGDTL1BgARPuQdL9AyTsxz0FNUy3bIaNAwV9MdWJAK2RcloGrTFzHVEDH75BMc8gASDS3kHB+gAZtGkAnYExygCdETKahquEnRLkXIKtBYYdFKYeQlLtgbJJgr8AAEJkIB8AAEGUMB8wMGJhaQTvUOABVCAeEbKagu0xs51RQ55RRB4RspqCHTGyzVFCz73BMc8gADDSndED3hFyWgYdMXKNUQKPvwBwMNKfqUQ0qDIiYApglDFAOvJEEZA8ETAUMUA8EZDEMUA8ElMkIwA8IXAUMUA8IdDUIwA8IqAUMUA8IwDEMUA8I8DUMPA8MJAUMUA8MPBUMUA5SMBGZ1bmOUhZQpdJRSlIwIRXhlY3V0ZSCUjAFflIwBIJR0lCiMCWZ1bmN0b29sc5SMBXdyYXBzlIwHX19kb2NfX5SMCF9fbmFtZV9flIwHcmVwbGFjZZR0lGgsaCiGlGgnjAlkZWNvcmF0b3KUjBp0b29saWZ5Ljxsb2NhbHM+LmRlY29yYXRvcpRLF0Ng+YAA3AkSjx+JH5gU0wke8wIpCSnzAwAKH/ACKQkp8VgBAAwX2B4piEeMT/AKABAXiA7wCQASGZcfkh/gICioFK8dqR3XKT7RKT64c8BD0ylI0ChJ0B5KiEeMT+APFogOlEMAlIwLZGVzY3JpcHRpb26UhZRoLIWUdJRSlIaUKWg/aDuGlGgnjAd0b29saWZ5lGhGSwFDEfiAAPQsNAUX8GwBAAwV0AQUlGg+KWg/hZR0lFKUfZRoN4wiZHluYW1pY19tb2R1bGVfNTAyMTY3NDU4ODUyMzg5MzA5NpRzaEZOhZROdJRSlH2UfZQoaDZoB4wPX19hbm5vdGF0aW9uc19flH2UaD9oAIwKX2xvYWRfdHlwZZSTlGgZhZRSlHN1hpRiaEsoaDdoTGg2TowLX19wYWNrYWdlX1+UTowKX19sb2FkZXJfX5ROjAhfX3NwZWNfX5ROjAhfX2ZpbGVfX5SMImR5bmFtaWNfbW9kdWxlXzgxNDE1MzU1OTQ0OTM5NDIzMjGUaBSME2JvdHMuZGV2LmRlY29yYXRvcnOUaBSTlGgVaF5oFZOUaBhoXmgYk5SMA2FzdJRoAIwOX2ltcG9ydF9tb2R1bGWUk5RoYoWUUpSMCGRhdGV0aW1llGhkaGeFlFKUaDRoZGg0hZRSlIwHaW5zcGVjdJRoZGhshZRSlIwHbG9nZ2luZ5RoZGhvhZRSlIwCb3OUaGRocoWUUpSMA3N5c5RoZIwDc3lzlIWUUpSMCHRleHR3cmFwlGhkaHmFlFKUjAl0cmFjZWJhY2uUaGRofIWUUpRoNWg0aDWTlIwDQW55lIwGdHlwaW5nlGiAk5SMCENhbGxhYmxllGiBaIOTlIwIT3B0aW9uYWyUaIFohZOUjARUeXBllGiBaIeTlIwScmVtb3ZlX2NvZGVfYmxvY2tzlGgXaImTlIwGbG9nZ2VylGhvjAlnZXRMb2dnZXKUk5RoXoWUUpSMDE5vSFRUUEZpbHRlcpRoXmiQk5SMB2xhenlfZm6UaF5okpOUjApsYXp5X2NsYXNzlGheaJSTlIwMX2dldF9jb250ZXh0lGheaJaTlIwRX2dldF9weV9pbnRlcmZhY2WUaF5omJOUjARsYXp5lGheaJqTlIwOZGVidWdfb25fZXJyb3KUaF5onJOUjApsb2dfZXJyb3JzlGheaJ6TlGhGaE+MF19jb252ZXJ0X3N0cmluZ190b190eXBllGheaKCTlIwSX2xvZ19lcnJvcl90b19maWxllGheaKKTlIwEanNvbpRoZGikhZRSlIwETGlzdJRogWink5SMA0JvdJSMFGJvdHMuZm91bmRhdGlvbi5iYXNllGipk5SMEF9nZXRfY2FsbGluZ19ib3SUaAIoaAQoQxICBSgBBAFOAR4BIAEEARj7BgaUSwBLAEsASwJLBEsDQ96XAHQAAAAAAAAAAABqAwAAAAAAAAAAAAAAAAAAAAAAAKsAAAAAAAAAfQB8AHJXfABqBAAAAAAAAAAAAAAAAAAAAAAAAGoGAAAAAAAAAAAAAAAAAAAAAAAAZAFrKAAAci9kAnwAaggAAAAAAAAAAAAAAAAAAAAAAAB2AHIhfABqCAAAAAAAAAAAAAAAAAAAAAAAAGQCGQAAAH0BdAsAAAAAAAAAAHwBdAwAAAAAAAAAAKsCAAAAAAAAcgJ8AVMAfABqDgAAAAAAAAAAAAAAAAAAAAAAAH0AfAByAYxXeQOUKIyRSGVscGVyIGZ1bmN0aW9uIHRvIGdldCBhIHJlZmVyZW5jZSB0byB0aGUgY2FsbGluZyBib3QuCiAgICBSZXR1cm5zOgogICAgICAgIE9wdGlvbmFsW0JvdF06IFJlZmVyZW5jZSB0byB0aGUgY2FsbGluZyBib3Qgb3IgTm9uZSBpZiBub3QgZm91bmQKICAgIJSMDV9jdnNuX3Jlc3BvbmSUjARzZWxmlE50lChobIwMY3VycmVudGZyYW1llIwGZl9jb2RllIwHY29fbmFtZZSMCGZfbG9jYWxzlIwKaXNpbnN0YW5jZZRoqYwGZl9iYWNrlHSUjAVmcmFtZZSMDXBvdGVudGlhbF9ib3SUhpRoJ2isaKxL00NjgAD0CgANFNcMINEMINMMIoBF2QoP2AsQjzyJPNcLH9ELH6A/0gsysHbAFccewR7RN0/YHCGfTplOqDbRHDKITdwPGZgtrBPUDy3YFyTQECTYEBWXDJEMiAXyCwALEPAMAAwQlGg+KSl0lFKUfZRoN2hMc2isTk50lFKUfZR9lChoNmivaFJ9lIwGcmV0dXJulIwJX29wZXJhdG9ylIwHZ2V0aXRlbZSTlGiBjAVVbmlvbpSTlGiraFWMCE5vbmVUeXBllIWUUpSGlIaUUpRzdYaUYmjAKGg3aExoNk5oWU5oWk5oW05oXGhdaBRoX2gVaGBoGGhhaGJoZmhnaGloNGhraGxobmhvaHFocmh0aHVoeGh5aHtofGh+aDVof2iAaIJog2iEaIVohmiHaIhoiWiKaItoj2iQaJFokmiTaJRolWiWaJdomGiZaJpom2icaJ1onmifaEZoT2igaKFoomijaKRopminaKhoqWiraKxowowMZ2V0X293bl9pbmZvlIwVYm90cy50b29scy5zZWxmX3Rvb2xzlGjTk5SMFF9tb2RpZnlfb3duX3NldHRpbmdzlGjUaNaTlIwLYnJhbmNoX3NlbGaUaNRo2JOUjAlhZGRfdG9vbHOUaNRo2pOUjAxsaXN0X2NvbnRleHSUaNRo3JOUjA5yZW1vdmVfY29udGV4dJRoAihoL32UaDdoTHNo3k5oAIwMX2NyZWF0ZV9jZWxslJOUToWUUpSFlHSUUpR9lCiMC19fd3JhcHBlZF9flGgCKGgEKEOsBhYUAQQBAgECARYBBAEC/wIENAEEAgwGEAEEAQICBgkEASIBEAEM/gIDBAEEAQoBCAEqAiT8AgUIAQoBBAEEAQwBAgEYASIBAgEYATABIgECATABIgECAR4BNgEiAQIBHAE2ATYBBAEeAQ4BOAEM/QQFHgEOATj+AgMYAQQBFAEOAQIBGPwGBQ7eAiYEAQoBKgEEASgBBAFGAQQBAgEkqhABLv8KShABOgEU/pRLAUsASwBLFksISwNCRAYAAIcWhxeXAHQBAAAAAAAAAACrAAAAAAAAAH0BfAFzAXkBCQB0AwAAAAAAAAAAfACrAQAAAAAAAH0CfAJzAXkCCQB8AWoIAAAAAAAAAAAAAAAAAAAAAAAAagsAAAAAAAAAAAAAAAAAAAAAAACrAAAAAAAAAH0EZwCKFogWiBdmAmQFhAiKFwIAiRd8BKsBAAAAAAAAAQCJFnMBeQZkB4QAfQVpAH0GdA0AAAAAAAAAAIkWqwEAAAAAAABEAF0SAABcAgAAfQd9CAIAfAV8B6sBAAAAAAAAfQl8CHwGfAk8AAAAjBQEAGcAfQpnAH0LfAJEAF0sAAB9CXwJfAZ2AHIVfApqDwAAAAAAAAAAAAAAAAAAAAAAAHwGfAkZAAAAqwEAAAAAAAABAIwcfAtqDwAAAAAAAAAAAAAAAAAAAAAAAHwJqwEAAAAAAAABAIwuBAB8C3IHfApzBWQIfAubAJ0CUwBkCX0MZwB9DXwKRACQAV2lAAB9DgkAfA5qEAAAAAAAAAAAAAAAAAAAAAAAAHMSfA1qDwAAAAAAAAAAAAAAAAAAAAAAAGQKqwEAAAAAAAABAIwjfA5qEAAAAAAAAAAAAAAAAAAAAAAAAH0PdBMAAAAAAAAAAHwOahQAAAAAAAAAAAAAAAAAAAAAAACrAQAAAAAAAGQJaygAAHISfA1qDwAAAAAAAAAAAAAAAAAAAAAAAGQLqwEAAAAAAAABAIxZdBMAAAAAAAAAAHwOahQAAAAAAAAAAAAAAAAAAAAAAACrAQAAAAAAAGQMa0QAAHISfA1qDwAAAAAAAAAAAAAAAAAAAAAAAGQNqwEAAAAAAAABAIyDfA5qFAAAAAAAAAAAAAAAAAAAAAAAAGQJGQAAAH0QdBcAAAAAAAAAAHwQZA6rAgAAAAAAAHIPfBBqGAAAAAAAAAAAAAAAAAAAAAAAAGQPaygAAHMSfA1qDwAAAAAAAAAAAAAAAAAAAAAAAGQQqwEAAAAAAAABAIy/fA58D2oUAAAAAAAAAAAAAAAAAAAAAAAAdgBycnwPahQAAAAAAAAAAAAAAAAAAAAAAABqGwAAAAAAAAAAAAAAAAAAAAAAAHwOqwEAAAAAAAB9EXwPahQAAAAAAAAAAAAAAAAAAAAAAABqHQAAAAAAAAAAAAAAAAAAAAAAAHwOqwEAAAAAAAABAHwRfRJ8EGoUAAAAAAAAAAAAAAAAAAAAAAAARABdKgAAfRN8D3wTXwgAAAAAAAAAAHwPahQAAAAAAAAAAAAAAAAAAAAAAABqHwAAAAAAAAAAAAAAAAAAAAAAAHwSfBOrAgAAAAAAAAEAfBJkDHoNAAB9EowsBABuM3wQahQAAAAAAAAAAAAAAAAAAAAAAABEAF0kAAB9E3wPfBNfCAAAAAAAAAAAfA9qFAAAAAAAAAAAAAAAAAAAAAAAAGoPAAAAAAAAAAAAAAAAAAAAAAAAfBOrAQAAAAAAAAEAjCYEAHwBaggAAAAAAAAAAAAAAAAAAAAAAAB9FHwUciF8FHwOaygAAHMFfBR8EGsoAAByCHwPfAFfBAAAAAAAAAAAbg98FGoQAAAAAAAAAAAAAAAAAAAAAAAAfRR8FHIBjCF8DGQMeg0AAH0MkAGMqAQAZwB9FXwMZAlrRAAAchV8FWoPAAAAAAAAAAAAAAAAAAAAAAAAZBJ8DJsAZBOdA6sBAAAAAAAAAQB8C3IUfBVqDwAAAAAAAAAAAAAAAAAAAAAAAGQUfAubAJ0CqwEAAAAAAAABAHwNciN8FWoPAAAAAAAAAAAAAAAAAAAAAAAAZBVkFmohAAAAAAAAAAAAAAAAAAAAAAAAfA2rAQAAAAAAAJsAnQKrAQAAAAAAAAEAfBVzAXkXZBhqIQAAAAAAAAAAAAAAAAAAAAAAAHwVqwEAAAAAAABTACMAdAQAAAAAAAAAACQAchh9A2QDdAcAAAAAAAAAAHwDqwEAAAAAAACbAJ0CYwJZAGQEfQN+A1MAZAR9A34DdwF3AHgDWQB3ASMAdAQAAAAAAAAAACQAcih9A3wNag8AAAAAAAAAAAAAAAAAAAAAAABkEXQHAAAAAAAAAAB8A6sBAAAAAAAAmwCdAqsBAAAAAAAAAQBZAGQEfQN+A5ACjGRkBH0DfgN3AXcAeANZAHcBlChY/AIAAFJlbW92ZSBib3QtdXNlciBtZXNzYWdlIHBhaXJzIGZyb20gdGhlIGNvbnZlcnNhdGlvbiBoaXN0b3J5LgoKICAgIFVzZSB3aGVuIHlvdSBuZWVkIHRvIGRlbGV0ZSBzcGVjaWZpYyBtZXNzYWdlcyBmcm9tIHlvdXIgY29udmVyc2F0aW9uIHRyZWUKICAgIHRvIHJlZHVjZSBjb250ZXh0IG9yIHJlbW92ZSBpcnJlbGV2YW50IGluZm9ybWF0aW9uLiBUaGlzIGlzIGEgZGVtbyB0b29sCiAgICB0aGF0IHJlbW92ZXMgbWVzc2FnZSBwYWlycyBieSBzdGl0Y2hpbmcgdGhlIHRyZWUgYWZ0ZXIgZGVsZXRpb24uCgogICAgTm90ZTogVGhpcyB0b29sIGhhcyBsaW1pdGF0aW9ucyB3aXRoIGJyYW5jaGVkIGNvbnZlcnNhdGlvbnMgYW5kIHdpbGwKICAgIGF0dGVtcHQgdG8gaGFuZGxlIHRoZSBzaW1wbGVzdCBjYXNlIChsaW5lYXIgY29udmVyc2F0aW9uIHBhdGhzKS4KCiAgICBQYXJhbWV0ZXJzOgogICAgICAgIGxhYmVscyAoc3RyKTogU3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgbGlzdCBvZiBsYWJlbHMgdG8gcmVtb3ZlLgogICAgICAgICAgICBGb3JtYXQ6ICJbJ0EnLCAnQicsICdDJ10iCiAgICAgICAgICAgIFVzZSBsaXN0X2NvbnRleHQoKSBmaXJzdCB0byBzZWUgYXZhaWxhYmxlIGxhYmVscy4KCiAgICBSZXR1cm5zOgogICAgICAgIHN0cjogU3VjY2VzcyBtZXNzYWdlIHdpdGggY291bnQgb2YgcmVtb3ZlZCBwYWlycywgb3IgZXJyb3IgbWVzc2FnZQoKICAgIEV4YW1wbGU6CiAgICAgICAgcmVtb3ZlX2NvbnRleHQoIlsnQScsICdDJ10iKQogICAglIwhRXJyb3I6IENvdWxkIG5vdCBmaW5kIGNhbGxpbmcgYm90lIwfRXJyb3I6IE5vIHZhbGlkIGxhYmVscyBwcm92aWRlZJSMFkVycm9yIHBhcnNpbmcgbGFiZWxzOiCUTmgEKEMKBAI2ASIBHgES/5RLAUsASwBLAksESxNDkJUClwB0AQAAAAAAAAAAfABkAasCAAAAAAAAciB8AGoCAAAAAAAAAAAAAAAAAAAAAAAAZAJrKAAAchGJAmoFAAAAAAAAAAAAAAAAAAAAAAAAfACrAQAAAAAAAAEAfABqBgAAAAAAAAAAAAAAAAAAAAAAAEQAXQoAAH0BAgCJA3wBqwEAAAAAAAABAIwMBAB5A5QojDdSZWN1cnNpdmVseSBjb2xsZWN0IGFsbCBib3QgKGFzc2lzdGFudCkgbm9kZXMgaW4gb3JkZXIulIwEcm9sZZSMCWFzc2lzdGFudJROdJQojAdoYXNhdHRylGjyjAZhcHBlbmSUjAdyZXBsaWVzlHSUjARub2RllIwFcmVwbHmUhpRoJ4wRY29sbGVjdF9ib3Rfbm9kZXOUjClyZW1vdmVfY29udGV4dC48bG9jYWxzPi5jb2xsZWN0X2JvdF9ub2Rlc5RLcUM8+IAA5AsSkDSYFtQLIKBUp1mhWbAr0iU92AwV1wwc0QwcmFTUDCLYFRmXXJRciEXZDB2YZdUMJPEDABYilGg+jAlib3Rfbm9kZXOUaPyGlCl0lFKUjCxFcnJvcjogTm8gYm90IG1lc3NhZ2VzIGZvdW5kIGluIGNvbnZlcnNhdGlvbpRoBChDEAICBAEKAQoBCgEoAQr9DASUSwFLAEsASwJLBUsTQ2aXAGQBfQF8AGQCeg0AAH0AfABkA2tEAAByJHwAZAJ6FwAAfQB0AQAAAAAAAAAAZAR8AGQFegYAAHoAAACrAQAAAAAAAHwBegAAAH0BfABkBXoPAAB9AHwAZANrRAAAcgGMJHwBUwCUKIw9R2VuZXJhdGUgRXhjZWwtc3R5bGUgY29sdW1uIGxhYmVsczogQSwgQiwgLi4uLCBaLCBBQSwgQUIsIC4uLpSMAJRLAUsAS0FLGnSUjANjaHKUhZSMBWluZGV4lIwFbGFiZWyUhpRoJ4wOZ2VuZXJhdGVfbGFiZWyUjCZyZW1vdmVfY29udGV4dC48bG9jYWxzPi5nZW5lcmF0ZV9sYWJlbJRLe0NQgADgEBKIBdgIDZARiQqIBdgOE5BhimnYDBGQUYlKiEXcFBeYAphVoFKZWpkP0xQoqDXRFDCIRdgMEZBiiUyIRfAHAA8UkGGLafAIABAViAyUaD4pKXSUUpSML0Vycm9yOiBOb25lIG9mIHRoZSBwcm92aWRlZCBsYWJlbHMgd2VyZSBmb3VuZDoglEsAjBdDYW5ub3QgcmVtb3ZlIHJvb3Qgbm9kZZSMKUJvdCBub2RlIGhhcyBubyBjaGlsZCB1c2VyIG5vZGUgdG8gcmVtb3ZllEsBjEFCb3Qgbm9kZSBoYXMgbXVsdGlwbGUgY2hpbGRyZW4gLSBjYW5ub3QgZGV0ZXJtaW5lIHdoaWNoIHRvIHJlbW92ZZRo8owEdXNlcpSMI0JvdCBub2RlJ3MgY2hpbGQgaXMgbm90IGEgdXNlciBub2RllIwcRmFpbGVkIHRvIHJlbW92ZSBub2RlIHBhaXI6IJSMFVN1Y2Nlc3NmdWxseSByZW1vdmVkIJSMECBtZXNzYWdlIHBhaXIocymUjBBNaXNzaW5nIGxhYmVsczoglIwIRXJyb3JzOiCUjAI7IJSMGE5vIG1lc3NhZ2VzIHdlcmUgcmVtb3ZlZJSMAyB8IJR0lChorIwVX3Byb2Nlc3Nfc3RyaW5nX2FycmF5lGgbaBmMDGNvbnZlcnNhdGlvbpSMCl9maW5kX3Jvb3SUjAllbnVtZXJhdGWUaPaMBnBhcmVudJSMA2xlbpRo92j1aPJqCwEAAIwGcmVtb3ZllIwGaW5zZXJ0lIwEam9pbpR0lCiMBmxhYmVsc5SMA2JvdJSMCmxhYmVsX2xpc3SUaCKMBHJvb3SUag4BAACMDWxhYmVsX3RvX25vZGWUjAFplGj5agwBAACMD25vZGVzX3RvX3JlbW92ZZSMDm1pc3NpbmdfbGFiZWxzlIwNcmVtb3ZlZF9jb3VudJSMBmVycm9yc5SMCGJvdF9ub2RllGomAQAAjAl1c2VyX25vZGWUjA5vcmlnaW5hbF9pbmRleJSMDGluc2VydF9pbmRleJSMBWNoaWxklIwHY3VycmVudJSMDHJlc3VsdF9wYXJ0c5R0lGgnaN5o3ktPQj8DAAD5gAD0LAALG9MKHIBD2QsO2A8y8AIFBTHcFSqoNtMVMogK2Q8Z2BM08AMAEBrwCAAMD9cLG9ELG9cLJtELJtMLKIBE2BASgEn1BAUFJfEMAAUWkGTUBBvZCxTYDz3yBAgFFfASABUXgE3cExyYWdYTJ4kHiAGINNkQHphx0xAhiAXYHyOIDZBl0ggc8AUAFCjwBgAXGYBP2BUXgE7bERuIBdgLEJBN0Qsh2Awb1wwi0QwioD2wFdEjN9UMOOAMGtcMIdEMIaAl1Qwo8AkAEhzxCgAIFpl/2BFAwB7QQFDQD1HQCFHYFBWATdgND4BG3BQjiAjwAiQJFdgTG5c/kj/YEBaXDZEN0B431BA42BAY2BUdl1+RX4hG3A8SkDjXEyPREyPTDySoAdIPKdgQFpcNkQ3QHknUEErYEBjcDxKQONcTI9ETI9MPJKBx0g8o2BAWlw2RDdAeYdQQYtgQGNgYINcYKNEYKKgR0RgriEncFBuYSaB21BQusDm3PrE+wFbSM0vYEBaXDZEN0B5D1BBE2BAY2A8XmDafPpk+0Q8p2CEnpx6hHtchNdEhNbBo0yE/kA7YEBaXDpEO1xAl0RAloGjUEC/YHy2QDNgdJtcdLtQdLpBF2CMpkEWUTNgUGpdOkU7XFCnRFCmoLLgF1BQ+2BQgoEHRFCWRTPEHAB4v8AoAHifXHS7UHS6QRdgjKZBFlEzYFBqXTpFO1xQp0RQpqCXVFDDwBQAeL/AGABca1xYm0RYmiEfZEhnYExqYaNITJqgnsFnSKj7YJy2QQ9QUJNgUGdgaIZ8umS6QB/IJABMa8AoADRqYUdEMHopN8EUBABUk8EwBABQWgEzYBxSQcdIHGNgIFNcIG9EIG9AeM7BNsD/QQlLQHFPUCFTZBxXYCBTXCBvRCBvQHi6oftAuPtAcP9QIQNkHDdgIFNcIG9EIG5hooHSneaF5sBbTJzjQJjnQHDrUCDvZCxfYDynYCxCPOok6kGzTCyPQBCP49G0CAAwV8gABBTHYESesA6hBqwageNAPMNUIMPvwAwEFMfv0VAIAEBnyAAIJFdgMEo9NiU3QHDi8E7hRuxa4CNAaQdQMQt0MFPvwBQIJFfqUQ1SRDUsKAMI7HUsuAsMZNUsuAsQPKUsuAsQ5O0suAsU1QyFLLgLJFwVLLgLLCglLKwPLEw1LJgPLIAFLKwPLJgVLKwPLLglMHwXLNx1MGgXMGgVMHwWUKWj/aPyGlHSUUpR9lGg3aExzaN5OTnSUUpR9lH2UKGg2aOtoUn2UKGosAQAAaFdoxmhXdXWGlGKMEl9fbW9kdWxlX2NvbnRleHRfX5RoqowNTW9kdWxlQ29udGV4dJSTlCmBlH2UKIwEbmFtZZRoTIwGc291cmNllFg8IgAAZGVmIHRvb2xpZnkoZGVzY3JpcHRpb246IHN0ciA9IE5vbmUpOgogICAgIiIiCiAgICBDb252ZXJ0IGFueSBmdW5jdGlvbiBpbnRvIGEgYm90IHRvb2wgd2l0aCBzdHJpbmctaW4sIHN0cmluZy1vdXQgaW50ZXJmYWNlLgoKICAgIC0gQ29udmVydHMgc3RyaW5nIGlucHV0cyB0byBwcm9wZXIgdHlwZXMgdXNpbmcgdHlwZSBoaW50cwogICAgLSBFbnN1cmVzIHN0cmluZyBvdXRwdXQgKEpTT04gZm9yIGNvbXBsZXggdHlwZXMpCiAgICAtIFdyYXBzIGluIGVycm9yIGhhbmRsaW5nIChyZXR1cm5zIGVycm9yIHN0cmluZ3MsIG5ldmVyIHJhaXNlcykKICAgIC0gRW5oYW5jZXMgZG9jc3RyaW5nIGlmIGRlc2NyaXB0aW9uIHByb3ZpZGVkCgogICAgQXJnczoKICAgICAgICBkZXNjcmlwdGlvbiAoc3RyLCBvcHRpb25hbCk6IE92ZXJyaWRlIHRoZSBmdW5jdGlvbidzIGRvY3N0cmluZwoKICAgIEV4YW1wbGU6CiAgICAgICAgQHRvb2xpZnkoKQogICAgICAgIGRlZiBhZGRfbnVtYmVycyh4OiBpbnQsIHk6IGludCA9IDApIC0+IGludDoKICAgICAgICAgICAgcmV0dXJuIHggKyB5CgogICAgICAgIEB0b29saWZ5KCJDYWxjdWxhdGUgdGhlIGFyZWEgb2YgYSBjaXJjbGUiKQogICAgICAgIGRlZiBhcmVhKHJhZGl1czogZmxvYXQpIC0+IGZsb2F0OgogICAgICAgICAgICByZXR1cm4gMy4xNDE1OSAqIHJhZGl1cyAqIHJhZGl1cwogICAgIiIiCgogICAgZGVmIGRlY29yYXRvcihmdW5jKToKICAgICAgICBAZnVuY3Rvb2xzLndyYXBzKGZ1bmMpCiAgICAgICAgZGVmIHdyYXBwZXIoKmFyZ3MsICoqa3dhcmdzKToKICAgICAgICAgICAgdHJ5OgogICAgICAgICAgICAgICAgIyBDb252ZXJ0IHN0cmluZyBpbnB1dHMgdG8gcHJvcGVyIHR5cGVzIHVzaW5nIHR5cGUgaGludHMKICAgICAgICAgICAgICAgIGNvbnZlcnRlZF9hcmdzLCBjb252ZXJ0ZWRfa3dhcmdzID0gX2NvbnZlcnRfdG9vbF9pbnB1dHMoZnVuYywgYXJncywga3dhcmdzKQoKICAgICAgICAgICAgICAgICMgQ2FsbCBvcmlnaW5hbCBmdW5jdGlvbgogICAgICAgICAgICAgICAgcmVzdWx0ID0gZnVuYygqY29udmVydGVkX2FyZ3MsICoqY29udmVydGVkX2t3YXJncykKCiAgICAgICAgICAgICAgICAjIENvbnZlcnQgcmVzdWx0IHRvIHN0cmluZwogICAgICAgICAgICAgICAgcmV0dXJuIF9jb252ZXJ0X3Rvb2xfb3V0cHV0KHJlc3VsdCkKCiAgICAgICAgICAgIGV4Y2VwdCBLZXlib2FyZEludGVycnVwdCBhcyBlOgogICAgICAgICAgICAgICAgIyBDb252ZXJ0IEtleWJvYXJkSW50ZXJydXB0IHRvIFRvb2xFeGVjdXRpb25FcnJvciB0byBwcmV2ZW50IGl0IGZyb20KICAgICAgICAgICAgICAgICMgYnViYmxpbmcgdXAgdG8gQ0xJIGFuZCBiZWluZyB0cmVhdGVkIGFzIHVzZXIgQ3RybCtDCiAgICAgICAgICAgICAgICBmcm9tIGJvdHMudXRpbHMuaGVscGVycyBpbXBvcnQgX3Byb2Nlc3NfZXJyb3IKCiAgICAgICAgICAgICAgICB0b29sX2Vycm9yID0gVG9vbEV4ZWN1dGlvbkVycm9yKGYiVG9vbCBleGVjdXRpb24gaW50ZXJydXB0ZWQ6IHtzdHIoZSl9IikKICAgICAgICAgICAgICAgIHJldHVybiBfcHJvY2Vzc19lcnJvcih0b29sX2Vycm9yKQoKICAgICAgICAgICAgZXhjZXB0IFR5cGVFcnJvciBhcyBlOgogICAgICAgICAgICAgICAgIyBDaGVjayBpZiB0aGlzIGlzIGEgbWlzc2luZyByZXF1aXJlZCBhcmd1bWVudCBlcnJvcgogICAgICAgICAgICAgICAgZXJyb3JfbXNnID0gc3RyKGUpCiAgICAgICAgICAgICAgICBpZiAibWlzc2luZyIgaW4gZXJyb3JfbXNnIGFuZCAicmVxdWlyZWQiIGluIGVycm9yX21zZyBhbmQgImFyZ3VtZW50IiBpbiBlcnJvcl9tc2c6CiAgICAgICAgICAgICAgICAgICAgIyBBZGQgc3BlY2lhbCBtZXNzYWdlIGZvciBvdXRwdXQgdG9rZW4gbGltaXRhdGlvbgogICAgICAgICAgICAgICAgICAgIGVuaGFuY2VkX2Vycm9yID0gVHlwZUVycm9yKAogICAgICAgICAgICAgICAgICAgICAgICBmIntlcnJvcl9tc2d9XG5cbiIKICAgICAgICAgICAgICAgICAgICAgICAgZiLimqDvuI8gIFRoaXMgZXJyb3IgaXMgY29tbW9ubHkgY2F1c2VkIGJ5IGhpdHRpbmcgdGhlIG1heF90b2tlbnMgbGltaXQgYmVmb3JlIGNvbXBsZXRpbmcgdGhlIHRvb2wgY2FsbC5cbiIKICAgICAgICAgICAgICAgICAgICAgICAgZiJUaGUgcmVzcG9uc2Ugd2FzIHRydW5jYXRlZCBtaWQtcGFyYW1ldGVyLCBtYWtpbmcgaXQgYXBwZWFyIHRoYXQgcmVxdWlyZWQgcGFyYW1ldGVycyBhcmUgbWlzc2luZy5cbiIKICAgICAgICAgICAgICAgICAgICAgICAgZiJUbyBmaXggdGhpczogV29yayBpbiBTTUFMTEVSIENIVU5LUy4gRWRpdCBmZXdlciBsaW5lcyBhdCBhIHRpbWUsICIKICAgICAgICAgICAgICAgICAgICAgICAgZiJvciBicmVhayB5b3VyIHRhc2sgaW50byBtdWx0aXBsZSBzdGVwcy4iCiAgICAgICAgICAgICAgICAgICAgKQogICAgICAgICAgICAgICAgICAgIGZyb20gYm90cy51dGlscy5oZWxwZXJzIGltcG9ydCBfcHJvY2Vzc19lcnJvcgoKICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3Byb2Nlc3NfZXJyb3IoZW5oYW5jZWRfZXJyb3IpCiAgICAgICAgICAgICAgICBlbHNlOgogICAgICAgICAgICAgICAgICAgIGZyb20gYm90cy51dGlscy5oZWxwZXJzIGltcG9ydCBfcHJvY2Vzc19lcnJvcgoKICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3Byb2Nlc3NfZXJyb3IoZSkKICAgICAgICAgICAgZXhjZXB0IEV4Y2VwdGlvbiBhcyBlOgogICAgICAgICAgICAgICAgZnJvbSBib3RzLnV0aWxzLmhlbHBlcnMgaW1wb3J0IF9wcm9jZXNzX2Vycm9yCgogICAgICAgICAgICAgICAgcmV0dXJuIF9wcm9jZXNzX2Vycm9yKGUpCgogICAgICAgICMgVXBkYXRlIGRvY3N0cmluZyBpZiBkZXNjcmlwdGlvbiBwcm92aWRlZAogICAgICAgIGlmIGRlc2NyaXB0aW9uOgogICAgICAgICAgICB3cmFwcGVyLl9fZG9jX18gPSBkZXNjcmlwdGlvbgogICAgICAgIGVsaWYgbm90IHdyYXBwZXIuX19kb2NfXzoKICAgICAgICAgICAgIyBHZW5lcmF0ZSBtaW5pbWFsIGRvY3N0cmluZyBmcm9tIGZ1bmN0aW9uIG5hbWUKICAgICAgICAgICAgd3JhcHBlci5fX2RvY19fID0gZiJFeGVjdXRlIHtmdW5jLl9fbmFtZV9fLnJlcGxhY2UoJ18nLCAnICcpfSIKCiAgICAgICAgcmV0dXJuIHdyYXBwZXIKCiAgICByZXR1cm4gZGVjb3JhdG9yCgpAdG9vbGlmeSgpCmRlZiByZW1vdmVfY29udGV4dChsYWJlbHM6IHN0cikgLT4gc3RyOgogICAgIiIiUmVtb3ZlIGJvdC11c2VyIG1lc3NhZ2UgcGFpcnMgZnJvbSB0aGUgY29udmVyc2F0aW9uIGhpc3RvcnkuCgogICAgVXNlIHdoZW4geW91IG5lZWQgdG8gZGVsZXRlIHNwZWNpZmljIG1lc3NhZ2VzIGZyb20geW91ciBjb252ZXJzYXRpb24gdHJlZQogICAgdG8gcmVkdWNlIGNvbnRleHQgb3IgcmVtb3ZlIGlycmVsZXZhbnQgaW5mb3JtYXRpb24uIFRoaXMgaXMgYSBkZW1vIHRvb2wKICAgIHRoYXQgcmVtb3ZlcyBtZXNzYWdlIHBhaXJzIGJ5IHN0aXRjaGluZyB0aGUgdHJlZSBhZnRlciBkZWxldGlvbi4KCiAgICBOb3RlOiBUaGlzIHRvb2wgaGFzIGxpbWl0YXRpb25zIHdpdGggYnJhbmNoZWQgY29udmVyc2F0aW9ucyBhbmQgd2lsbAogICAgYXR0ZW1wdCB0byBoYW5kbGUgdGhlIHNpbXBsZXN0IGNhc2UgKGxpbmVhciBjb252ZXJzYXRpb24gcGF0aHMpLgoKICAgIFBhcmFtZXRlcnM6CiAgICAgICAgbGFiZWxzIChzdHIpOiBTdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBsaXN0IG9mIGxhYmVscyB0byByZW1vdmUuCiAgICAgICAgICAgIEZvcm1hdDogIlsnQScsICdCJywgJ0MnXSIKICAgICAgICAgICAgVXNlIGxpc3RfY29udGV4dCgpIGZpcnN0IHRvIHNlZSBhdmFpbGFibGUgbGFiZWxzLgoKICAgIFJldHVybnM6CiAgICAgICAgc3RyOiBTdWNjZXNzIG1lc3NhZ2Ugd2l0aCBjb3VudCBvZiByZW1vdmVkIHBhaXJzLCBvciBlcnJvciBtZXNzYWdlCgogICAgRXhhbXBsZToKICAgICAgICByZW1vdmVfY29udGV4dCgiWydBJywgJ0MnXSIpCiAgICAiIiIKICAgIGJvdCA9IF9nZXRfY2FsbGluZ19ib3QoKQogICAgaWYgbm90IGJvdDoKICAgICAgICByZXR1cm4gJ0Vycm9yOiBDb3VsZCBub3QgZmluZCBjYWxsaW5nIGJvdCcKICAgIHRyeToKICAgICAgICBsYWJlbF9saXN0ID0gX3Byb2Nlc3Nfc3RyaW5nX2FycmF5KGxhYmVscykKICAgICAgICBpZiBub3QgbGFiZWxfbGlzdDoKICAgICAgICAgICAgcmV0dXJuICdFcnJvcjogTm8gdmFsaWQgbGFiZWxzIHByb3ZpZGVkJwogICAgZXhjZXB0IEV4Y2VwdGlvbiBhcyBlOgogICAgICAgIHJldHVybiBmJ0Vycm9yIHBhcnNpbmcgbGFiZWxzOiB7c3RyKGUpfScKICAgIHJvb3QgPSBib3QuY29udmVyc2F0aW9uLl9maW5kX3Jvb3QoKQogICAgYm90X25vZGVzID0gW10KCiAgICBkZWYgY29sbGVjdF9ib3Rfbm9kZXMobm9kZSk6CiAgICAgICAgIiIiUmVjdXJzaXZlbHkgY29sbGVjdCBhbGwgYm90IChhc3Npc3RhbnQpIG5vZGVzIGluIG9yZGVyLiIiIgogICAgICAgIGlmIGhhc2F0dHIobm9kZSwgJ3JvbGUnKSBhbmQgbm9kZS5yb2xlID09ICdhc3Npc3RhbnQnOgogICAgICAgICAgICBib3Rfbm9kZXMuYXBwZW5kKG5vZGUpCiAgICAgICAgZm9yIHJlcGx5IGluIG5vZGUucmVwbGllczoKICAgICAgICAgICAgY29sbGVjdF9ib3Rfbm9kZXMocmVwbHkpCiAgICBjb2xsZWN0X2JvdF9ub2Rlcyhyb290KQogICAgaWYgbm90IGJvdF9ub2RlczoKICAgICAgICByZXR1cm4gJ0Vycm9yOiBObyBib3QgbWVzc2FnZXMgZm91bmQgaW4gY29udmVyc2F0aW9uJwoKICAgIGRlZiBnZW5lcmF0ZV9sYWJlbChpbmRleCk6CiAgICAgICAgIiIiR2VuZXJhdGUgRXhjZWwtc3R5bGUgY29sdW1uIGxhYmVsczogQSwgQiwgLi4uLCBaLCBBQSwgQUIsIC4uLiIiIgogICAgICAgIGxhYmVsID0gJycKICAgICAgICBpbmRleCArPSAxCiAgICAgICAgd2hpbGUgaW5kZXggPiAwOgogICAgICAgICAgICBpbmRleCAtPSAxCiAgICAgICAgICAgIGxhYmVsID0gY2hyKDY1ICsgaW5kZXggJSAyNikgKyBsYWJlbAogICAgICAgICAgICBpbmRleCAvLz0gMjYKICAgICAgICByZXR1cm4gbGFiZWwKICAgIGxhYmVsX3RvX25vZGUgPSB7fQogICAgZm9yIGksIG5vZGUgaW4gZW51bWVyYXRlKGJvdF9ub2Rlcyk6CiAgICAgICAgbGFiZWwgPSBnZW5lcmF0ZV9sYWJlbChpKQogICAgICAgIGxhYmVsX3RvX25vZGVbbGFiZWxdID0gbm9kZQogICAgbm9kZXNfdG9fcmVtb3ZlID0gW10KICAgIG1pc3NpbmdfbGFiZWxzID0gW10KICAgIGZvciBsYWJlbCBpbiBsYWJlbF9saXN0OgogICAgICAgIGlmIGxhYmVsIGluIGxhYmVsX3RvX25vZGU6CiAgICAgICAgICAgIG5vZGVzX3RvX3JlbW92ZS5hcHBlbmQobGFiZWxfdG9fbm9kZVtsYWJlbF0pCiAgICAgICAgZWxzZToKICAgICAgICAgICAgbWlzc2luZ19sYWJlbHMuYXBwZW5kKGxhYmVsKQogICAgaWYgbWlzc2luZ19sYWJlbHMgYW5kIChub3Qgbm9kZXNfdG9fcmVtb3ZlKToKICAgICAgICByZXR1cm4gZidFcnJvcjogTm9uZSBvZiB0aGUgcHJvdmlkZWQgbGFiZWxzIHdlcmUgZm91bmQ6IHttaXNzaW5nX2xhYmVsc30nCiAgICByZW1vdmVkX2NvdW50ID0gMAogICAgZXJyb3JzID0gW10KICAgIGZvciBib3Rfbm9kZSBpbiBub2Rlc190b19yZW1vdmU6CiAgICAgICAgdHJ5OgogICAgICAgICAgICBpZiBub3QgYm90X25vZGUucGFyZW50OgogICAgICAgICAgICAgICAgZXJyb3JzLmFwcGVuZCgnQ2Fubm90IHJlbW92ZSByb290IG5vZGUnKQogICAgICAgICAgICAgICAgY29udGludWUKICAgICAgICAgICAgcGFyZW50ID0gYm90X25vZGUucGFyZW50CiAgICAgICAgICAgIGlmIGxlbihib3Rfbm9kZS5yZXBsaWVzKSA9PSAwOgogICAgICAgICAgICAgICAgZXJyb3JzLmFwcGVuZCgnQm90IG5vZGUgaGFzIG5vIGNoaWxkIHVzZXIgbm9kZSB0byByZW1vdmUnKQogICAgICAgICAgICAgICAgY29udGludWUKICAgICAgICAgICAgaWYgbGVuKGJvdF9ub2RlLnJlcGxpZXMpID4gMToKICAgICAgICAgICAgICAgIGVycm9ycy5hcHBlbmQoJ0JvdCBub2RlIGhhcyBtdWx0aXBsZSBjaGlsZHJlbiAtIGNhbm5vdCBkZXRlcm1pbmUgd2hpY2ggdG8gcmVtb3ZlJykKICAgICAgICAgICAgICAgIGNvbnRpbnVlCiAgICAgICAgICAgIHVzZXJfbm9kZSA9IGJvdF9ub2RlLnJlcGxpZXNbMF0KICAgICAgICAgICAgaWYgbm90IChoYXNhdHRyKHVzZXJfbm9kZSwgJ3JvbGUnKSBhbmQgdXNlcl9ub2RlLnJvbGUgPT0gJ3VzZXInKToKICAgICAgICAgICAgICAgIGVycm9ycy5hcHBlbmQoIkJvdCBub2RlJ3MgY2hpbGQgaXMgbm90IGEgdXNlciBub2RlIikKICAgICAgICAgICAgICAgIGNvbnRpbnVlCiAgICAgICAgICAgIGlmIGJvdF9ub2RlIGluIHBhcmVudC5yZXBsaWVzOgogICAgICAgICAgICAgICAgb3JpZ2luYWxfaW5kZXggPSBwYXJlbnQucmVwbGllcy5pbmRleChib3Rfbm9kZSkKICAgICAgICAgICAgICAgIHBhcmVudC5yZXBsaWVzLnJlbW92ZShib3Rfbm9kZSkKICAgICAgICAgICAgICAgIGluc2VydF9pbmRleCA9IG9yaWdpbmFsX2luZGV4CiAgICAgICAgICAgICAgICBmb3IgY2hpbGQgaW4gdXNlcl9ub2RlLnJlcGxpZXM6CiAgICAgICAgICAgICAgICAgICAgY2hpbGQucGFyZW50ID0gcGFyZW50CiAgICAgICAgICAgICAgICAgICAgcGFyZW50LnJlcGxpZXMuaW5zZXJ0KGluc2VydF9pbmRleCwgY2hpbGQpCiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0X2luZGV4ICs9IDEKICAgICAgICAgICAgZWxzZToKICAgICAgICAgICAgICAgIGZvciBjaGlsZCBpbiB1c2VyX25vZGUucmVwbGllczoKICAgICAgICAgICAgICAgICAgICBjaGlsZC5wYXJlbnQgPSBwYXJlbnQKICAgICAgICAgICAgICAgICAgICBwYXJlbnQucmVwbGllcy5hcHBlbmQoY2hpbGQpCiAgICAgICAgICAgIGN1cnJlbnQgPSBib3QuY29udmVyc2F0aW9uCiAgICAgICAgICAgIHdoaWxlIGN1cnJlbnQ6CiAgICAgICAgICAgICAgICBpZiBjdXJyZW50ID09IGJvdF9ub2RlIG9yIGN1cnJlbnQgPT0gdXNlcl9ub2RlOgogICAgICAgICAgICAgICAgICAgIGJvdC5jb252ZXJzYXRpb24gPSBwYXJlbnQKICAgICAgICAgICAgICAgICAgICBicmVhawogICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50CiAgICAgICAgICAgIHJlbW92ZWRfY291bnQgKz0gMQogICAgICAgIGV4Y2VwdCBFeGNlcHRpb24gYXMgZToKICAgICAgICAgICAgZXJyb3JzLmFwcGVuZChmJ0ZhaWxlZCB0byByZW1vdmUgbm9kZSBwYWlyOiB7c3RyKGUpfScpCiAgICAgICAgICAgIGNvbnRpbnVlCiAgICByZXN1bHRfcGFydHMgPSBbXQogICAgaWYgcmVtb3ZlZF9jb3VudCA+IDA6CiAgICAgICAgcmVzdWx0X3BhcnRzLmFwcGVuZChmJ1N1Y2Nlc3NmdWxseSByZW1vdmVkIHtyZW1vdmVkX2NvdW50fSBtZXNzYWdlIHBhaXIocyknKQogICAgaWYgbWlzc2luZ19sYWJlbHM6CiAgICAgICAgcmVzdWx0X3BhcnRzLmFwcGVuZChmJ01pc3NpbmcgbGFiZWxzOiB7bWlzc2luZ19sYWJlbHN9JykKICAgIGlmIGVycm9yczoKICAgICAgICByZXN1bHRfcGFydHMuYXBwZW5kKGYiRXJyb3JzOiB7JzsgJy5qb2luKGVycm9ycyl9IikKICAgIGlmIG5vdCByZXN1bHRfcGFydHM6CiAgICAgICAgcmV0dXJuICdObyBtZXNzYWdlcyB3ZXJlIHJlbW92ZWQnCiAgICByZXR1cm4gJyB8ICcuam9pbihyZXN1bHRfcGFydHMpCgpkZWYgX3Byb2Nlc3Nfc3RyaW5nX2FycmF5KGlucHV0X3N0cjogc3RyKSAtPiBMaXN0W3N0cl06CiAgICAiIiJQYXJzZSBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhbiBhcnJheSBpbnRvIGEgbGlzdCBvZiBzdHJpbmdzLgogICAgT25seSB3b3JrcyB3aXRoIHByb3Blcmx5IGZvcm1hdHRlZCBQeXRob24gbGlzdCBsaXRlcmFscy4KICAgIEFyZ3M6CiAgICAgICAgaW5wdXRfc3RyIChzdHIpOiBTdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBQeXRob24gbGlzdCBsaXRlcmFsCiAgICBSZXR1cm5zOgogICAgICAgIExpc3Rbc3RyXTogTGlzdCBvZiBwYXJzZWQgc3RyaW5ncwogICAgUmFpc2VzOgogICAgICAgIFZhbHVlRXJyb3I6IElmIHRoZSBpbnB1dCBpcyBub3QgYSB2YWxpZCBQeXRob24gbGlzdCBsaXRlcmFsCiAgICAiIiIKICAgIHJlc3VsdCA9IGFzdC5saXRlcmFsX2V2YWwoaW5wdXRfc3RyKQogICAgaWYgbm90IGlzaW5zdGFuY2UocmVzdWx0LCBsaXN0KSBvciBub3QgYWxsKChpc2luc3RhbmNlKHgsIHN0cikgZm9yIHggaW4gcmVzdWx0KSk6CiAgICAgICAgcmFpc2UgVmFsdWVFcnJvcignSW5wdXQgbXVzdCBldmFsdWF0ZSB0byBhIGxpc3Qgb2Ygc3RyaW5ncycpCiAgICByZXR1cm4gcmVzdWx0CgpkZWYgX2dldF9jYWxsaW5nX2JvdCgpIC0+IE9wdGlvbmFsW0JvdF06CiAgICAiIiJIZWxwZXIgZnVuY3Rpb24gdG8gZ2V0IGEgcmVmZXJlbmNlIHRvIHRoZSBjYWxsaW5nIGJvdC4KICAgIFJldHVybnM6CiAgICAgICAgT3B0aW9uYWxbQm90XTogUmVmZXJlbmNlIHRvIHRoZSBjYWxsaW5nIGJvdCBvciBOb25lIGlmIG5vdCBmb3VuZAogICAgIiIiCiAgICBmcmFtZSA9IGluc3BlY3QuY3VycmVudGZyYW1lKCkKICAgIHdoaWxlIGZyYW1lOgogICAgICAgIGlmIGZyYW1lLmZfY29kZS5jb19uYW1lID09ICdfY3Zzbl9yZXNwb25kJyBhbmQgJ3NlbGYnIGluIGZyYW1lLmZfbG9jYWxzOgogICAgICAgICAgICBwb3RlbnRpYWxfYm90ID0gZnJhbWUuZl9sb2NhbHNbJ3NlbGYnXQogICAgICAgICAgICBpZiBpc2luc3RhbmNlKHBvdGVudGlhbF9ib3QsIEJvdCk6CiAgICAgICAgICAgICAgICBy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aIBogmiDaIRohWiGaIdoiGiJaIpoi2iPaJBokWiSaJNolGiVaJZol2iYaJlommibaJxonWieaJ9oRmhPaKBooWiiaKNopGimaKdoqGipaKtorGjCaNNo1WjWaNdo2GjZaNpo22jcaN1o3mjmaiIBAABqdAEAAGp7AQAAanwBAABqfQEAAGp+AQAAan8BAABqgAEAAGqFAQAAY2J1aWx0aW5zCl9fZGljdF9fCnUwjAhidWlsdGluc5SMB2dldGF0dHKUk5SMBGRpbGyUjAVfZGlsbJSTlIwIX3NldGF0dHKUaoYBAACMB3NldGF0dHKUk5SHlFKUaOOMDWNlbGxfY29udGVudHOUakUBAACHlFIwaN8oaDdoTGg2TmhZTmhaTmhbTmhcaF1oFGhfaBVoYGgYaGFoYmhmaGdoaWg0aGtobGhuaG9ocWhyaHRodWh4aHloe2h8aH5oNWh/aIBogmiDaIRohWiGaIdoiGiJaIpoi2iPaJBokWiSaJNolGiVaJZol2iYaJlommibaJxonWieaJ9oRmhPaKBooWiiaKNopGimaKdoqGipaKtorGjCaNNo1WjWaNdo2GjZaNpo22jcaN1o3mjmaiIBAABqdAEAAGp7AQAAanwBAABqfQEAAGp+AQAAan8BAABqgAEAAGqFAQAAY2J1aWx0aW5zCl9fZGljdF9fCnUwaiIBAABqdAEAAGp7AQAAanwBAABqfQEAAGp+AQAAan8BAABqgAEAAGqFAQAAY2J1aWx0aW5zCl9fZGljdF9fCnUwaNNo1WjWaNdo2GjZaNpo22jcaN1o3mjmaiIBAABqdAEAAGp7AQAAanwBAABqfQEAAGp+AQAAan8BAABqgAEAAGqFAQAAY2J1aWx0aW5zCl9fZGljdF9fCnUwLg==",
      "name": "toolify",
      "hash": "241d7f153db0ac2e547bd17661020d45859d986872e6a1119f609e94a171e5f5",
      "provenance": {
       "module": "dynamic_module_5021674588523893096",
       "qualname": "toolify"
      }
     },
     "_convert_string_to_type": {
      "__helper_func__": true,
      "pickled": "gASVMwAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjBdfY29udmVydF9zdHJpbmdfdG9fdHlwZZSTlC4=",
      "name": "_convert_string_to_type",
      "hash": "024e40c56cb46e6fe9f52fe7e6e64a3effc17736268ef31195596c6a6be4c311",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "_convert_string_to_type"
      }
     },
     "_log_error_to_file": {
      "__helper_func__": true,
      "pickled": "gASVLgAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjBJfbG9nX2Vycm9yX3RvX2ZpbGWUk5Qu",
      "name": "_log_error_to_file",
      "hash": "c02546b672eb25afd5dc51ea7e1967cbb6fd264ca18ffd15c3cbeccebe4046ba",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "_log_error_to_file"
      }
     },
     "json": {
      "__module_type__": true,
      "name": "json",
      "spec": "json"
     },
     "List": {
      "__imported_callable__": true,
      "pickled": "gASVEwAAAAAAAACMBnR5cGluZ5SMBExpc3SUk5Qu",
      "name": "List",
      "hash": "4177cb372f5ac2e670cf003d399db45b34278d8cf8801c6f8c592fc37176022f",
      "provenance": {
       "module": "typing",
       "qualname": "List"
      }
     },
     "Bot": {
      "__imported_callable__": true,
      "pickled": "gASVIAAAAAAAAACMFGJvdHMuZm91bmRhdGlvbi5iYXNllIwDQm90lJOULg==",
      "name": "Bot",
      "hash": "0a4ab7f39ea6cd147bb4589dad55c5e11e3d88deb65d684e7a6c7e8c28fdc6d1",
      "provenance": {
       "module": "bots.foundation.base",
       "qualname": "Bot"
      }
     },
     "get_own_info": {
      "__imported_callable__": true,
      "pickled": "gASVKgAAAAAAAACMFWJvdHMudG9vbHMuc2VsZl90b29sc5SMDGdldF9vd25faW5mb5STlC4=",
      "name": "get_own_info",
      "hash": "a20f468fbbd729bc4fde649cc3830e7b5c2e833d58d43dd03569e6c0ac35033d",
      "provenance": {
       "module": "bots.tools.self_tools",
       "qualname": "get_own_info"
      }
     },
     "_modify_own_settings": {
      "__helper_func__": true,
      "pickled": "gASVMgAAAAAAAACMFWJvdHMudG9vbHMuc2VsZl90b29sc5SMFF9tb2RpZnlfb3duX3NldHRpbmdzlJOULg==",
      "name": "_modify_own_settings",
      "hash": "3fbf37fea12c6b3b0a4306c19e227a47baa08f0d466d9aa96fba9748699c8d87",
      "provenance": {
       "module": "bots.tools.self_tools",
       "qualname": "_modify_own_settings"
      }
     },
     "branch_self": {
      "__imported_callable__": true,
      "pickled": "gASVKQAAAAAAAACMFWJvdHMudG9vbHMuc2VsZl90b29sc5SMC2JyYW5jaF9zZWxmlJOULg==",
      "name": "branch_self",
      "hash": "a4acbba0c53b6a30a2e0f0dc15a52af6e382d0b26eb91622345703c3dc10fc99",
      "provenance": {
       "module": "bots.tools.self_tools",
       "qualname": "branch_self"
      }
     },
     "add_tools": {
      "__imported_callable__": true,
      "pickled": "gASVJwAAAAAAAACMFWJvdHMudG9vbHMuc2VsZl90b29sc5SMCWFkZF90b29sc5STlC4=",
      "name": "add_tools",
      "hash": "e426bca163b5fc4ada03a5244a935139d0d4d742aaec2eb42e1da978c803b0f5",
      "provenance": {
       "module": "bots.tools.self_tools",
       "qualname": "add_tools"
      }
     },
     "list_context": {
      "__imported_callable__": true,
      "pickled": "gASVKgAAAAAAAACMFWJvdHMudG9vbHMuc2VsZl90b29sc5SMDGxpc3RfY29udGV4dJSTlC4=",
      "name": "list_context",
      "hash": "aca8c5a8ea74321c4dc4321a0d13b6543630a1356e337bd5e37aab9705920375",
      "provenance": {
       "module": "bots.tools.self_tools",
       "qualname": "list_context"
      }
     },
     "remove_context": {
      "__imported_callable__": true,
      "pickled": "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LgoKICAgIFVzZSB3aGVuIHlvdSBuZWVkIHRvIGRlbGV0ZSBzcGVjaWZpYyBtZXNzYWdlcyBmcm9tIHlvdXIgY29udmVyc2F0aW9uIHRyZWUKICAgIHRvIHJlZHVjZSBjb250ZXh0IG9yIHJlbW92ZSBpcnJlbGV2YW50IGluZm9ybWF0aW9uLiBUaGlzIGlzIGEgZGVtbyB0b29sCiAgICB0aGF0IHJlbW92ZXMgbWVzc2FnZSBwYWlycyBieSBzdGl0Y2hpbmcgdGhlIHRyZWUgYWZ0ZXIgZGVsZXRpb24uCgogICAgTm90ZTogVGhpcyB0b29sIGhhcyBsaW1pdGF0aW9ucyB3aXRoIGJyYW5jaGVkIGNvbnZlcnNhdGlvbnMgYW5kIHdpbGwKICAgIGF0dGVtcHQgdG8gaGFuZGxlIHRoZSBzaW1wbGVzdCBjYXNlIChsaW5lYXIgY29udmVyc2F0aW9uIHBhdGhzKS4KCiAgICBQYXJhbWV0ZXJzOgogICAgICAgIGxhYmVscyAoc3RyKTogU3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgbGlzdCBvZiBsYWJlbHMgdG8gcmVtb3ZlLgogICAgICAgICAgICBGb3JtYXQ6ICJbJ0EnLCAnQicsICdDJ10iCiAgICAgICAgICAgIFVzZSBsaXN0X2NvbnRleHQoKSBmaXJzdCB0byBzZWUgYXZhaWxhYmxlIGxhYmVscy4KCiAgICBSZXR1cm5zOgogICAgICAgIHN0cjogU3VjY2VzcyBtZXNzYWdlIHdpdGggY291bnQgb2YgcmVtb3ZlZCBwYWlycywgb3IgZXJyb3IgbWVzc2FnZQoKICAgIEV4YW1wbGU6CiAgICAgICAgcmVtb3ZlX2NvbnRleHQoIlsnQScsICdDJ10iKQogICAglIwhRXJyb3I6IENvdWxkIG5vdCBmaW5kIGNhbGxpbmcgYm90lIwfRXJyb3I6IE5vIHZhbGlkIGxhYmVscyBwcm92aWRlZJSMFkVycm9yIHBhcnNpbmcgbGFiZWxzOiCUTmgEKEMKBAI2ASIBHgES/5RLAUsASwBLAksESxNDkJUClwB0AQAAAAAAAAAAfABkAasCAAAAAAAAciB8AGoCAAAAAAAAAAAAAAAAAAAAAAAAZAJrKAAAchGJAmoFAAAAAAAA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dHIgPSBOb25lKToKICAgICIiIgogICAgQ29udmVydCBhbnkgZnVuY3Rpb24gaW50byBhIGJvdCB0b29sIHdpdGggc3RyaW5nLWluLCBzdHJpbmctb3V0IGludGVyZmFjZS4KCiAgICAtIENvbnZlcnRzIHN0cmluZyBpbnB1dHMgdG8gcHJvcGVyIHR5cGVzIHVzaW5nIHR5cGUgaGludHMKICAgIC0gRW5zdXJlcyBzdHJpbmcgb3V0cHV0IChKU09OIGZvciBjb21wbGV4IHR5cGVzKQogICAgLSBXcmFwcyBpbiBlcnJvciBoYW5kbGluZyAocmV0dXJucyBlcnJvciBzdHJpbmdzLCBuZXZlciByYWlzZXMpCiAgICAtIEVuaGFuY2VzIGRvY3N0cmluZyBpZiBkZXNjcmlwdGlvbiBwcm92aWRlZAoKICAgIEFyZ3M6CiAgICAgICAgZGVzY3JpcHRpb24gKHN0ciwgb3B0aW9uYWwpOiBPdmVycmlkZSB0aGUgZnVuY3Rpb24ncyBkb2NzdHJpbmcKCiAgICBFeGFtcGxlOgogICAgICAgIEB0b29saWZ5KCkKICAgICAgICBkZWYgYWRkX251bWJlcnMoeDogaW50LCB5OiBpbnQgPSAwKSAtPiBpbnQ6CiAgICAgICAgICAgIHJldHVybiB4ICsgeQoKICAgICAgICBAdG9vbGlmeSgiQ2FsY3VsYXRlIHRoZSBhcmVhIG9mIGEgY2lyY2xlIikKICAgICAgICBkZWYgYXJlYShyYWRpdXM6IGZsb2F0KSAtPiBmbG9hdDoKICAgICAgICAgICAgcmV0dXJuIDMuMTQxNTkgKiByYWRpdXMgKiByYWRpdXMKICAgICIiIgoKICAgIGRlZiBkZWNvcmF0b3IoZnVuYyk6CiAgICAgICAgQGZ1bmN0b29scy53cmFwcyhmdW5jKQogICAgICAgIGRlZiB3cmFwcGVyKCphcmdzLCAqKmt3YXJncyk6CiAgICAgICAgICAgIHRyeToKICAgICAgICAgICAgICAgICMgQ29udmVydCBzdHJpbmcgaW5wdXRzIHRvIHByb3BlciB0eXBlcyB1c2luZyB0eXBlIGhpbnRzCiAgICAgICAgICAgICAgICBjb252ZXJ0ZWRfYXJncywgY29udmVydGVkX2t3YXJncyA9IF9jb252ZXJ0X3Rvb2xfaW5wdXRzKGZ1bmMsIGFyZ3MsIGt3YXJncykKCiAgICAgICAgICAgICAgICAjIENhbGwgb3JpZ2luYWwgZnVuY3Rpb24KICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmMoKmNvbnZlcnRlZF9hcmdzLCAqKmNvbnZlcnRlZF9rd2FyZ3MpCgogICAgICAgICAgICAgICAgIyBDb252ZXJ0IHJlc3VsdCB0byBzdHJpbmcKICAgICAgICAgICAgICAgIHJldHVybiBfY29udmVydF90b29sX291dHB1dChyZXN1bHQpCgogICAgICAgICAgICBleGNlcHQgS2V5Ym9hcmRJbnRlcnJ1cHQgYXMgZToKICAgICAgICAgICAgICAgICMgQ29udmVydCBLZXlib2FyZEludGVycnVwdCB0byBUb29sRXhlY3V0aW9uRXJyb3IgdG8gcHJldmVudCBpdCBmcm9tCiAgICAgICAgICAgICAgICAjIGJ1YmJsaW5nIHVwIHRvIENMSSBhbmQgYmVpbmcgdHJlYXRlZCBhcyB1c2VyIEN0cmwrQwogICAgICAgICAgICAgICAgZnJvbSBib3RzLnV0aWxzLmhlbHBlcnMgaW1wb3J0IF9wcm9jZXNzX2Vycm9yCgogICAgICAgICAgICAgICAgdG9vbF9lcnJvciA9IFRvb2xFeGVjdXRpb25FcnJvcihmIlRvb2wgZXhlY3V0aW9uIGludGVycnVwdGVkOiB7c3RyKGUpfSIpCiAgICAgICAgICAgICAgICByZXR1cm4gX3Byb2Nlc3NfZXJyb3IodG9vbF9lcnJvcikKCiAgICAgICAgICAgIGV4Y2VwdCBUeXBlRXJyb3IgYXMgZToKICAgICAgICAgICAgICAgICMgQ2hlY2sgaWYgdGhpcyBpcyBhIG1pc3NpbmcgcmVxdWlyZWQgYXJndW1lbnQgZXJyb3IKICAgICAgICAgICAgICAgIGVycm9yX21zZyA9IHN0cihlKQogICAgICAgICAgICAgICAgaWYgIm1pc3NpbmciIGluIGVycm9yX21zZyBhbmQgInJlcXVpcmVkIiBpbiBlcnJvcl9tc2cgYW5kICJhcmd1bWVudCIgaW4gZXJyb3JfbXNnOgogICAgICAgICAgICAgICAgICAgICMgQWRkIHNwZWNpYWwgbWVzc2FnZSBmb3Igb3V0cHV0IHRva2VuIGxpbWl0YXRpb24KICAgICAgICAgICAgICAgICAgICBlbmhhbmNlZF9lcnJvciA9IFR5cGVFcnJvcigKICAgICAgICAgICAgICAgICAgICAgICAgZiJ7ZXJyb3JfbXNnfVxuXG4iCiAgICAgICAgICAgICAgICAgICAgICAgIGYi4pqg77iPICBUaGlzIGVycm9yIGlzIGNvbW1vbmx5IGNhdXNlZCBieSBoaXR0aW5nIHRoZSBtYXhfdG9rZW5zIGxpbWl0IGJlZm9yZSBjb21wbGV0aW5nIHRoZSB0b29sIGNhbGwuXG4iCiAgICAgICAgICAgICAgICAgICAgICAgIGYiVGhlIHJlc3BvbnNlIHdhcyB0cnVuY2F0ZWQgbWlkLXBhcmFtZXRlciwgbWFraW5nIGl0IGFwcGVhciB0aGF0IHJlcXVpcmVkIHBhcmFtZXRlcnMgYXJlIG1pc3NpbmcuXG4iCiAgICAgICAgICAgICAgICAgICAgICAgIGYiVG8gZml4IHRoaXM6IFdvcmsgaW4gU01BTExFUiBDSFVOS1MuIEVkaXQgZmV3ZXIgbGluZXMgYXQgYSB0aW1lLCAiCiAgICAgICAgICAgICAgICAgICAgICAgIGYib3IgYnJlYWsgeW91ciB0YXNrIGludG8gbXVsdGlwbGUgc3RlcHMuIgogICAgICAgICAgICAgICAgICAgICkKICAgICAgICAgICAgICAgICAgICBmcm9tIGJvdHMudXRpbHMuaGVscGVycyBpbXBvcnQgX3Byb2Nlc3NfZXJyb3IKCiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9wcm9jZXNzX2Vycm9yKGVuaGFuY2VkX2Vycm9yKQogICAgICAgICAgICAgICAgZWxzZToKICAgICAgICAgICAgICAgICAgICBmcm9tIGJvdHMudXRpbHMuaGVscGVycyBpbXBvcnQgX3Byb2Nlc3NfZXJyb3IKCiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9wcm9jZXNzX2Vycm9yKGUpCiAgICAgICAgICAgIGV4Y2VwdCBFeGNlcHRpb24gYXMgZToKICAgICAgICAgICAgICAgIGZyb20gYm90cy51dGlscy5oZWxwZXJzIGltcG9ydCBfcHJvY2Vzc19lcnJvcgoKICAgICAgICAgICAgICAgIHJldHVybiBfcHJvY2Vzc19lcnJvcihlKQoKICAgICAgICAjIFVwZGF0ZSBkb2NzdHJpbmcgaWYgZGVzY3JpcHRpb24gcHJvdmlkZWQKICAgICAgICBpZiBkZXNjcmlwdGlvbjoKICAgICAgICAgICAgd3JhcHBlci5fX2RvY19fID0gZGVzY3JpcHRpb24KICAgICAgICBlbGlmIG5vdCB3cmFwcGVyLl9fZG9jX186CiAgICAgICAgICAgICMgR2VuZXJhdGUgbWluaW1hbCBkb2NzdHJpbmcgZnJvbSBmdW5jdGlvbiBuYW1lCiAgICAgICAgICAgIHdyYXBwZXIuX19kb2NfXyA9IGYiRXhlY3V0ZSB7ZnVuYy5fX25hbWVfXy5yZXBsYWNlKCdfJywgJyAnKX0iCgogICAgICAgIHJldHVybiB3cmFwcGVyCgogICAgcmV0dXJuIGRlY29yYXRvcgoKQHRvb2xpZnkoKQpkZWYgcmVtb3ZlX2NvbnRleHQobGFiZWxzOiBzdHIpIC0+IHN0cjoKICAgICIiIlJlbW92ZSBib3QtdXNlciBtZXNzYWdlIHBhaXJzIGZyb20gdGhlIGNvbnZlcnNhdGlvbiBoaXN0b3J5LgoKICAgIFVzZSB3aGVuIHlvdSBuZWVkIHRvIGRlbGV0ZSBzcGVjaWZpYyBtZXNzYWdlcyBmcm9tIHlvdXIgY29udmVyc2F0aW9uIHRyZWUKICAgIHRvIHJlZHVjZSBjb250ZXh0IG9yIHJlbW92ZSBpcnJlbGV2YW50IGluZm9ybWF0aW9uLiBUaGlzIGlzIGEgZGVtbyB0b29sCiAgICB0aGF0IHJlbW92ZXMgbWVzc2FnZSBwYWlycyBieSBzdGl0Y2hpbmcgdGhlIHRyZWUgYWZ0ZXIgZGVsZXRpb24uCgogICAgTm90ZTogVGhpcyB0b29sIGhhcyBsaW1pdGF0aW9ucyB3aXRoIGJyYW5jaGVkIGNvbnZlcnNhdGlvbnMgYW5kIHdpbGwKICAgIGF0dGVtcHQgdG8gaGFuZGxlIHRoZSBzaW1wbGVzdCBjYXNlIChsaW5lYXIgY29udmVyc2F0aW9uIHBhdGhzKS4KCiAgICBQYXJhbWV0ZXJzOgogICAgICAgIGxhYmVscyAoc3RyKTogU3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgbGlzdCBvZiBsYWJlbHMgdG8gcmVtb3ZlLgogICAgICAgICAgICBGb3JtYXQ6ICJbJ0EnLCAnQicsICdDJ10iCiAgICAgICAgICAgIFVzZSBsaXN0X2NvbnRleHQoKSBmaXJzdCB0byBzZWUgYXZhaWxhYmxlIGxhYmVscy4KCiAgICBSZXR1cm5zOgogICAgICAgIHN0cjogU3VjY2VzcyBtZXNzYWdlIHdpdGggY291bnQgb2YgcmVtb3ZlZCBwYWlycywgb3IgZXJyb3IgbWVzc2FnZQoKICAgIEV4YW1wbGU6CiAgICAgICAgcmVtb3ZlX2NvbnRleHQoIlsnQScsICdDJ10iKQogICAgIiIiCiAgICBib3QgPSBfZ2V0X2NhbGxpbmdfYm90KCkKICAgIGlmIG5vdCBib3Q6CiAgICAgICAgcmV0dXJuICdFcnJvcjogQ291bGQgbm90IGZpbmQgY2FsbGluZyBib3QnCiAgICB0cnk6CiAgICAgICAgbGFiZWxfbGlzdCA9IF9wcm9jZXNzX3N0cmluZ19hcnJheShsYWJlbHMpCiAgICAgICAgaWYgbm90IGxhYmVsX2xpc3Q6CiAgICAgICAgICAgIHJldHVybiAnRXJyb3I6IE5vIHZhbGlkIGxhYmVscyBwcm92aWRlZCcKICAgIGV4Y2VwdCBFeGNlcHRpb24gYXMgZToKICAgICAgICByZXR1cm4gZidFcnJvciBwYXJzaW5nIGxhYmVsczoge3N0cihlKX0nCiAgICByb290ID0gYm90LmNvbnZlcnNhdGlvbi5fZmluZF9yb290KCkKICAgIGJvdF9ub2RlcyA9IFtdCgogICAgZGVmIGNvbGxlY3RfYm90X25vZGVzKG5vZGUpOgogICAgICAgICIiIlJlY3Vyc2l2ZWx5IGNvbGxlY3QgYWxsIGJvdCAoYXNzaXN0YW50KSBub2RlcyBpbiBvcmRlci4iIiIKICAgICAgICBpZiBoYXNhdHRyKG5vZGUsICdyb2xlJykgYW5kIG5vZGUucm9sZSA9PSAnYXNzaXN0YW50JzoKICAgICAgICAgICAgYm90X25vZGVzLmFwcGVuZChub2RlKQogICAgICAgIGZvciByZXBseSBpbiBub2RlLnJlcGxpZXM6CiAgICAgICAgICAgIGNvbGxlY3RfYm90X25vZGVzKHJlcGx5KQogICAgY29sbGVjdF9ib3Rfbm9kZXMocm9vdCkKICAgIGlmIG5vdCBib3Rfbm9kZXM6CiAgICAgICAgcmV0dXJuICdFcnJvcjogTm8gYm90IG1lc3NhZ2VzIGZvdW5kIGluIGNvbnZlcnNhdGlvbicKCiAgICBkZWYgZ2VuZXJhdGVfbGFiZWwoaW5kZXgpOgogICAgICAgICIiIkdlbmVyYXRlIEV4Y2VsLXN0eWxlIGNvbHVtbiBsYWJlbHM6IEEsIEIsIC4uLiwgWiwgQUEsIEFCLCAuLi4iIiIKICAgICAgICBsYWJlbCA9ICcnCiAgICAgICAgaW5kZXggKz0gMQogICAgICAgIHdoaWxlIGluZGV4ID4gMDoKICAgICAgICAgICAgaW5kZXggLT0gMQogICAgICAgICAgICBsYWJlbCA9IGNocig2NSArIGluZGV4ICUgMjYpICsgbGFiZWwKICAgICAgICAgICAgaW5kZXggLy89IDI2CiAgICAgICAgcmV0dXJuIGxhYmVsCiAgICBsYWJlbF90b19ub2RlID0ge30KICAgIGZvciBpLCBub2RlIGluIGVudW1lcmF0ZShib3Rfbm9kZXMpOgogICAgICAgIGxhYmVsID0gZ2VuZXJhdGVfbGFiZWwoaSkKICAgICAgICBsYWJlbF90b19ub2RlW2xhYmVsXSA9IG5vZGUKICAgIG5vZGVzX3RvX3JlbW92ZSA9IFtdCiAgICBtaXNzaW5nX2xhYmVscyA9IFtdCiAgICBmb3IgbGFiZWwgaW4gbGFiZWxfbGlzdDoKICAgICAgICBpZiBsYWJlbCBpbiBsYWJlbF90b19ub2RlOgogICAgICAgICAgICBub2Rlc190b19yZW1vdmUuYXBwZW5kKGxhYmVsX3RvX25vZGVbbGFiZWxdKQogICAgICAgIGVsc2U6CiAgICAgICAgICAgIG1pc3NpbmdfbGFiZWxzLmFwcGVuZChsYWJlbCkKICAgIGlmIG1pc3NpbmdfbGFiZWxzIGFuZCAobm90IG5vZGVzX3RvX3JlbW92ZSk6CiAgICAgICAgcmV0dXJuIGYnRXJyb3I6IE5vbmUgb2YgdGhlIHByb3ZpZGVkIGxhYmVscyB3ZXJlIGZvdW5kOiB7bWlzc2luZ19sYWJlbHN9JwogICAgcmVtb3ZlZF9jb3VudCA9IDAKICAgIGVycm9ycyA9IFtdCiAgICBmb3IgYm90X25vZGUgaW4gbm9kZXNfdG9fcmVtb3ZlOgogICAgICAgIHRyeToKICAgICAgICAgICAgaWYgbm90IGJvdF9ub2RlLnBhcmVudDoKICAgICAgICAgICAgICAgIGVycm9ycy5hcHBlbmQoJ0Nhbm5vdCByZW1vdmUgcm9vdCBub2RlJykKICAgICAgICAgICAgICAgIGNvbnRpbnVlCiAgICAgICAgICAgIHBhcmVudCA9IGJvdF9ub2RlLnBhcmVudAogICAgICAgICAgICBpZiBsZW4oYm90X25vZGUucmVwbGllcykgPT0gMDoKICAgICAgICAgICAgICAgIGVycm9ycy5hcHBlbmQoJ0JvdCBub2RlIGhhcyBubyBjaGlsZCB1c2VyIG5vZGUgdG8gcmVtb3ZlJykKICAgICAgICAgICAgICAgIGNvbnRpbnVlCiAgICAgICAgICAgIGlmIGxlbihib3Rfbm9kZS5yZXBsaWVzKSA+IDE6CiAgICAgICAgICAgICAgICBlcnJvcnMuYXBwZW5kKCdCb3Qgbm9kZSBoYXMgbXVsdGlwbGUgY2hpbGRyZW4gLSBjYW5ub3QgZGV0ZXJtaW5lIHdoaWNoIHRvIHJlbW92ZScpCiAgICAgICAgICAgICAgICBjb250aW51ZQogICAgICAgICAgICB1c2VyX25vZGUgPSBib3Rfbm9kZS5yZXBsaWVzWzBdCiAgICAgICAgICAgIGlmIG5vdCAoaGFzYXR0cih1c2VyX25vZGUsICdyb2xlJykgYW5kIHVzZXJfbm9kZS5yb2xlID09ICd1c2VyJyk6CiAgICAgICAgICAgICAgICBlcnJvcnMuYXBwZW5kKCJCb3Qgbm9kZSdzIGNoaWxkIGlzIG5vdCBhIHVzZXIgbm9kZSIpCiAgICAgICAgICAgICAgICBjb250aW51ZQogICAgICAgICAgICBpZiBib3Rfbm9kZSBpbiBwYXJlbnQucmVwbGllczoKICAgICAgICAgICAgICAgIG9yaWdpbmFsX2luZGV4ID0gcGFyZW50LnJlcGxpZXMuaW5kZXgoYm90X25vZGUpCiAgICAgICAgICAgICAgICBwYXJlbnQucmVwbGllcy5yZW1vdmUoYm90X25vZGUpCiAgICAgICAgICAgICAgICBpbnNlcnRfaW5kZXggPSBvcmlnaW5hbF9pbmRleAogICAgICAgICAgICAgICAgZm9yIGNoaWxkIGluIHVzZXJfbm9kZS5yZXBsaWVzOgogICAgICAgICAgICAgICAgICAgIGNoaWxkLnBhcmVudCA9IHBhcmVudAogICAgICAgICAgICAgICAgICAgIHBhcmVudC5yZXBsaWVzLmluc2VydChpbnNlcnRfaW5kZXgsIGNoaWxkKQogICAgICAgICAgICAgICAgICAgIGluc2VydF9pbmRleCArPSAxCiAgICAgICAgICAgIGVsc2U6CiAgICAgICAgICAgICAgICBmb3IgY2hpbGQgaW4gdXNlcl9ub2RlLnJlcGxpZXM6CiAgICAgICAgICAgICAgICAgICAgY2hpbGQucGFyZW50ID0gcGFyZW50CiAgICAgICAgICAgICAgICAgICAgcGFyZW50LnJlcGxpZXMuYXBwZW5kKGNoaWxkKQogICAgICAgICAgICBjdXJyZW50ID0gYm90LmNvbnZlcnNhdGlvbgogICAgICAgICAgICB3aGlsZSBjdXJyZW50OgogICAgICAgICAgICAgICAgaWYgY3VycmVudCA9PSBib3Rfbm9kZSBvciBjdXJyZW50ID09IHVzZXJfbm9kZToKICAgICAgICAgICAgICAgICAgICBib3QuY29udmVyc2F0aW9uID0gcGFyZW50CiAgICAgICAgICAgICAgICAgICAgYnJlYWsKICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudAogICAgICAgICAgICByZW1vdmVkX2NvdW50ICs9IDEKICAgICAgICBleGNlcHQgRXhjZXB0aW9uIGFzIGU6CiAgICAgICAgICAgIGVycm9ycy5hcHBlbmQoZidGYWlsZWQgdG8gcmVtb3ZlIG5vZGUgcGFpcjoge3N0cihlKX0nKQogICAgICAgICAgICBjb250aW51ZQogICAgcmVzdWx0X3BhcnRzID0gW10KICAgIGlmIHJlbW92ZWRfY291bnQgPiAwOgogICAgICAgIHJlc3VsdF9wYXJ0cy5hcHBlbmQoZidTdWNjZXNzZnVsbHkgcmVtb3ZlZCB7cmVtb3ZlZF9jb3VudH0gbWVzc2FnZSBwYWlyKHMpJykKICAgIGlmIG1pc3NpbmdfbGFiZWxzOgogICAgICAgIHJlc3VsdF9wYXJ0cy5hcHBlbmQoZidNaXNzaW5nIGxhYmVsczoge21pc3NpbmdfbGFiZWxzfScpCiAgICBpZiBlcnJvcnM6CiAgICAgICAgcmVzdWx0X3BhcnRzLmFwcGVuZChmIkVycm9yczogeyc7ICcuam9pbihlcnJvcnMpfSIpCiAgICBpZiBub3QgcmVzdWx0X3BhcnRzOgogICAgICAgIHJldHVybiAnTm8gbWVzc2FnZXMgd2VyZSByZW1vdmVkJwogICAgcmV0dXJuICcgfCAnLmpvaW4ocmVzdWx0X3BhcnRzKQoKZGVmIF9wcm9jZXNzX3N0cmluZ19hcnJheShpbnB1dF9zdHI6IHN0cikgLT4gTGlzdFtzdHJdOgogICAgIiIiUGFyc2UgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYW4gYXJyYXkgaW50byBhIGxpc3Qgb2Ygc3RyaW5ncy4KICAgIE9ubHkgd29ya3Mgd2l0aCBwcm9wZXJseSBmb3JtYXR0ZWQgUHl0aG9uIGxpc3QgbGl0ZXJhbHMuCiAgICBBcmdzOgogICAgICAgIGlucHV0X3N0ciAoc3RyKTogU3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgUHl0aG9uIGxpc3QgbGl0ZXJhbAogICAgUmV0dXJuczoKICAgICAgICBMaXN0W3N0cl06IExpc3Qgb2YgcGFyc2VkIHN0cmluZ3MKICAgIFJhaXNlczoKICAgICAgICBWYWx1ZUVycm9yOiBJZiB0aGUgaW5wdXQgaXMgbm90IGEgdmFsaWQgUHl0aG9uIGxpc3QgbGl0ZXJhbAogICAgIiIiCiAgICByZXN1bHQgPSBhc3QubGl0ZXJhbF9ldmFsKGlucHV0X3N0cikKICAgIGlmIG5vdCBpc2luc3RhbmNlKHJlc3VsdCwgbGlzdCkgb3Igbm90IGFsbCgoaXNpbnN0YW5jZSh4LCBzdHIpIGZvciB4IGluIHJlc3VsdCkpOgogICAgICAgIHJhaXNlIFZhbHVlRXJyb3IoJ0lucHV0IG11c3QgZXZhbHVhdGUgdG8gYSBsaXN0IG9mIHN0cmluZ3MnKQogICAgcmV0dXJuIHJlc3VsdAoKZGVmIF9nZXRfY2FsbGluZ19ib3QoKSAtPiBPcHRpb25hbFtCb3RdOgogICAgIiIiSGVscGVyIGZ1bmN0aW9uIHRvIGdldCBhIHJlZmVyZW5jZSB0byB0aGUgY2FsbGluZyBib3QuCiAgICBSZXR1cm5zOgogICAgICAgIE9wdGlvbmFsW0JvdF06IFJlZmVyZW5jZSB0byB0aGUgY2FsbGluZyBib3Qgb3IgTm9uZSBpZiBub3QgZm91bmQKICAgICIiIgogICAgZnJhbWUgPSBpbnNwZWN0LmN1cnJlbnRmcmFtZSgpCiAgICB3aGlsZSBmcmFtZToKICAgICAgICBpZiBmcmFtZS5mX2NvZGUuY29fbmFtZSA9PSAnX2N2c25fcmVzcG9uZCcgYW5kICdzZWxmJyBpbiBmcmFtZS5mX2xvY2FsczoKICAgICAgICAgICAgcG90ZW50aWFsX2JvdCA9IGZyYW1lLmZfbG9jYWxzWydzZWxmJ10KICAgICAgICAgICAgaWYgaXNpbnN0YW5jZShwb3RlbnRpYWxfYm90LCBCb3QpOgogICAgICAgICAgICAgICAgcmV0dXJuIHBvdGVudGlhbF9ib3QKICAgICAgICBmcmFtZSA9IGZyYW1lLmZfYmFjawogICAgcmV0dXJuIE5vbmWUjAlmaWxlX3BhdGiUjCJkeW5hbWljX21vZHVsZV84MTQxNTM1NTk0NDkzOTQyMzIxlIwJbmFtZXNwYWNllGgAjA5faW1wb3J0X21vZHVsZZSTlIwuX19ydW50aW1lX18uZHluYW1pY19tb2R1bGVfNTAyMTY3NDU4ODUyMzg5MzA5NpSFlFKUfZQoaCxoLWiZTowLX19wYWNrYWdlX1+UTowIX19zcGVjX1+UTowIX19maWxlX1+UaKxoD4wTYm90cy5kZXYuZGVjb3JhdG9yc5RoD5OUaBBot2gQk5RoE2i3aBOTlIwDYXN0lGivaLuFlFKUjAhkYXRldGltZZRor2i+hZRSlIwJZnVuY3Rvb2xzlGivaMGFlFKUjAdpbnNwZWN0lGivaMSFlFKUjAdsb2dnaW5nlGivaMeFlFKUjAJvc5Ror2jKhZRSlIwDc3lzlGivjANzeXOUhZRSlIwIdGV4dHdyYXCUaK9o0YWUUpSMCXRyYWNlYmFja5Ror2jUhZRSlIwFd3JhcHOUaMFo15OUjANBbnmUjAZ0eXBpbmeUaNmTlIwIQ2FsbGFibGWUaNpo3JOUjAhPcHRpb25hbJRo2mjek5SMBFR5cGWUaNpo4JOUjBJyZW1vdmVfY29kZV9ibG9ja3OUaBJo4pOUjAZsb2dnZXKUaMeMCWdldExvZ2dlcpSTlGi3hZRSlIwMTm9IVFRQRmlsdGVylGi3aOmTlIwHbGF6eV9mbpRot2jrk5SMCmxhenlfY2xhc3OUaLdo7ZOUjAxfZ2V0X2NvbnRleHSUaLdo75OUjBFfZ2V0X3B5X2ludGVyZmFjZZRot2jxk5SMBGxhenmUaLdo85OUjA5kZWJ1Z19vbl9lcnJvcpRot2j1k5SMCmxvZ19lcnJvcnOUaLdo95OUjAd0b29saWZ5lGgCKGgEKEMEBBYKNpRLAUsASwBLAksCSwNDEocAlwCIAGYBZAGECH0BfAFTAJRYiAIAAAogICAgQ29udmVydCBhbnkgZnVuY3Rpb24gaW50byBhIGJvdCB0b29sIHdpdGggc3RyaW5nLWluLCBzdHJpbmctb3V0IGludGVyZmFjZS4KCiAgICAtIENvbnZlcnRzIHN0cmluZyBpbnB1dHMgdG8gcHJvcGVyIHR5cGVzIHVzaW5nIHR5cGUgaGludHMKICAgIC0gRW5zdXJlcyBzdHJpbmcgb3V0cHV0IChKU09OIGZvciBjb21wbGV4IHR5cGVzKQogICAgLSBXcmFwcyBpbiBlcnJvciBoYW5kbGluZyAocmV0dXJucyBlcnJvciBzdHJpbmdzLCBuZXZlciByYWlzZXMpCiAgICAtIEVuaGFuY2VzIGRvY3N0cmluZyBpZiBkZXNjcmlwdGlvbiBwcm92aWRlZAoKICAgIEFyZ3M6CiAgICAgICAgZGVzY3JpcHRpb24gKHN0ciwgb3B0aW9uYWwpOiBPdmVycmlkZSB0aGUgZnVuY3Rpb24ncyBkb2NzdHJpbmcKCiAgICBFeGFtcGxlOgogICAgICAg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",
      "name": "remove_context",
      "hash": "db055d1203edb03c870e7347b4b29545440f59d5c094c69957fabdf5e3b80800",
      "provenance": {
       "module": "dynamic_module_5021674588523893096",
       "qualname": "remove_context"
      }
     },
     "_verbose_callback": {
      "__helper_func__": true,
      "pickled": "gASVLwAAAAAAAACMFWJvdHMudG9vbHMuc2VsZl90b29sc5SMEV92ZXJib3NlX2NhbGxiYWNrlJOULg==",
      "name": "_verbose_callback",
      "hash": "9c82e7d02bb30f7619e98eb4592178e595349398b083ec309b7df6faf745facb",
      "provenance": {
       "module": "bots.tools.self_tools",
       "qualname": "_verbose_callback"
      }
     },
     "_remove_dummy_from_tree": {
      "__helper_func__": true,
      "pickled": "gASVNQAAAAAAAACMFWJvdHMudG9vbHMuc2VsZl90b29sc5SMF19yZW1vdmVfZHVtbXlfZnJvbV90cmVllJOULg==",
      "name": "_remove_dummy_from_tree",
      "hash": "28ace6295e4d8788a37a54c2b3ad9dd47cd633b12018c5e828417877fdbcf222",
      "provenance": {
       "module": "bots.tools.self_tools",
       "qualname": "_remove_dummy_from_tree"
      }
     },
     "subagent": {
      "__imported_callable__": true,
      "pickled": "gASVJgAAAAAAAACMFWJvdHMudG9vbHMuc2VsZl90b29sc5SMCHN1YmFnZW50lJOULg==",
      "name": "subagent",
      "hash": "7906556f7bb3787822292780a7ca91117f5a21efc476be7449ee5bf3f1da82ca",
      "provenance": {
       "module": "bots.tools.self_tools",
       "qualname": "subagent"
      }
     }
    }
   },
   "dynamic_module_-2907077857284453818": {
    "name": "dynamic_module_-499587220287646394",
    "source": "from bots.utils.helpers import _process_error\nfrom typing import Optional\n\ndef toolify(description: str = None):\n    \"\"\"\n    Convert any function into a bot tool with string-in, string-out interface.\n\n    - Converts string inputs to proper types using type hints\n    - Ensures string output (JSON for complex types)\n    - Wraps in error handling (returns error strings, never raises)\n    - Enhances docstring if description provided\n\n    Args:\n        description (str, optional): Override the function's docstring\n\n    Example:\n        @toolify()\n        def add_numbers(x: int, y: int = 0) -> int:\n            return x + y\n\n        @toolify(\"Calculate the area of a circle\")\n        def area(radius: float) -> float:\n            return 3.14159 * radius * radius\n    \"\"\"\n\n    def decorator(func):\n        @functools.wraps(func)\n        def wrapper(*args, **kwargs):\n            try:\n                # Convert string inputs to proper types using type hints\n                converted_args, converted_kwargs = _convert_tool_inputs(func, args, kwargs)\n\n                # Call original function\n                result = func(*converted_args, **converted_kwargs)\n\n                # Convert result to string\n                return _convert_tool_output(result)\n\n            except KeyboardInterrupt as e:\n                # Convert KeyboardInterrupt to ToolExecutionError to prevent it from\n                # bubbling up to CLI and being treated as user Ctrl+C\n\n                tool_error = ToolExecutionError(f\"Tool execution interrupted: {str(e)}\")\n                return _process_error(tool_error)\n\n            except TypeError as e:\n                # Check if this is a missing required argument error\n                error_msg = str(e)\n                if \"missing\" in error_msg and \"required\" in error_msg and \"argument\" in error_msg:\n                    # Add special message for output token limitation\n                    enhanced_error = TypeError(\n                        f\"{error_msg}\\n\\n\"\n                        f\"\u26a0\ufe0f  This error is commonly caused by hitting the max_tokens limit before completing the tool call.\\n\"\n                        f\"The response was truncated mid-parameter, making it appear that required parameters are missing.\\n\"\n                        f\"To fix this: Work in SMALLER CHUNKS. Edit fewer lines at a time, \"\n                        f\"or break your task into multiple steps.\"\n                    )\n\n                    return _process_error(enhanced_error)\n                else:\n\n                    return _process_error(e)\n            except Exception as e:\n\n                return _process_error(e)\n\n        # Update docstring if description provided\n        if description:\n            wrapper.__doc__ = description\n        elif not wrapper.__doc__:\n            # Generate minimal docstring from function name\n            wrapper.__doc__ = f\"Execute {func.__name__.replace('_', ' ')}\"\n\n        return wrapper\n\n    return decorator\n\n@toolify()\ndef list_context() -> str:\n    \"\"\"List all bot messages in the conversation with labels for removal.\n\n    Use this before remove_context to see what messages are in your conversation.\n    Shows bot messages only (since removal happens in user-bot pairs) with:\n    - A label [A], [B], [C], etc. for reference\n    - Truncated tool calls (if any) with parameters\n    - Truncated response text\n\n    Returns:\n        str: Formatted list of bot messages with labels, or error message\n\n    Example output:\n        [A] Bot: <tool_name param=\"value...\"> | \"Response text...\"\n        [B] Bot: \"Response text without tools...\"\n    \"\"\"\n    bot = _get_calling_bot()\n    if not bot:\n        return 'Error: Could not find calling bot'\n    root = bot.conversation._find_root()\n    bot_nodes = []\n\n    def collect_bot_nodes(node):\n        \"\"\"Recursively collect all bot (assistant) nodes in order.\"\"\"\n        if hasattr(node, 'role') and node.role == 'assistant':\n            bot_nodes.append(node)\n        for reply in node.replies:\n            collect_bot_nodes(reply)\n    collect_bot_nodes(root)\n    if not bot_nodes:\n        return 'No bot messages found in conversation'\n\n    def generate_label(index):\n        \"\"\"Generate Excel-style column labels: A, B, ..., Z, AA, AB, ...\"\"\"\n        label = ''\n        index += 1\n        while index > 0:\n            index -= 1\n            label = chr(65 + index % 26) + label\n            index //= 26\n        return label\n    lines = []\n    for i, node in enumerate(bot_nodes):\n        label = generate_label(i)\n        parts = []\n        if hasattr(node, 'tool_calls') and node.tool_calls:\n            tool_strs = []\n            for tool_call in node.tool_calls:\n                tool_name = tool_call.get('name', 'unknown')\n                tool_input = tool_call.get('input', {})\n                if isinstance(tool_input, dict):\n                    param_parts = []\n                    for key, value in tool_input.items():\n                        value_str = str(value)\n                        if len(value_str) > 20:\n                            value_str = value_str[:20] + '...'\n                        param_parts.append(f'{key}={value_str}')\n                    params_str = ', '.join(param_parts)\n                else:\n                    params_str = str(tool_input)\n                    if len(params_str) > 20:\n                        params_str = params_str[:20] + '...'\n                tool_strs.append(f'<{tool_name} {params_str}>')\n            parts.append(' '.join(tool_strs))\n        if hasattr(node, 'content') and node.content:\n            content = node.content.replace('\\n', ' ')\n            if len(content) > 50:\n                content = content[:50] + '...'\n            parts.append(f'\"{content}\"')\n        if parts:\n            message_str = ' | '.join(parts)\n        else:\n            message_str = '<empty message>'\n        lines.append(f'[{label}] Bot: {message_str}')\n    return '\\n'.join(lines)\n\ndef _get_calling_bot() -> Optional[Bot]:\n    \"\"\"Helper function to get a reference to the calling bot.\n    Returns:\n        Optional[Bot]: Reference to the calling bot or None if not found\n    \"\"\"\n    frame = inspect.currentframe()\n    while frame:\n        if frame.f_code.co_name == '_cvsn_respond' and 'self' in frame.f_locals:\n            potential_bot = frame.f_locals['self']\n            if isinstance(potential_bot, Bot):\n                return potential_bot\n        frame = frame.f_back\n    return None",
    "file_path": "dynamic_module_-2907077857284453818",
    "code_hash": "f91fc251dbbc7e54a9e1a34d18f20343",
    "globals": {
     "_convert_tool_inputs": {
      "__helper_func__": true,
      "pickled": "gASVMAAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjBRfY29udmVydF90b29sX2lucHV0c5STlC4=",
      "name": "_convert_tool_inputs",
      "hash": "8bc4aba1c7d69350a812d8553b6a7ff0cd23ae5c818f3b9533752a69e91acf2e",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "_convert_tool_inputs"
      }
     },
     "_convert_tool_output": {
      "__helper_func__": true,
      "pickled": "gASVMAAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjBRfY29udmVydF90b29sX291dHB1dJSTlC4=",
      "name": "_convert_tool_output",
      "hash": "6c85767d30db1c50646d25d2b954c893aed15774f97345f9b8c99674c59cf928",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "_convert_tool_output"
      }
     },
     "ToolExecutionError": {
      "__imported_callable__": true,
      "pickled": "gASVLgAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjBJUb29sRXhlY3V0aW9uRXJyb3KUk5Qu",
      "name": "ToolExecutionError",
      "hash": "e3f136f46cc3014d1b1a8ac6716adb9da7db1dd83f2ed8529e090d97ae0db998",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "ToolExecutionError"
      }
     },
     "ast": {
      "__module_type__": true,
      "name": "ast",
      "spec": "ast"
     },
     "datetime": {
      "__module_type__": true,
      "name": "datetime",
      "spec": "datetime"
     },
     "functools": {
      "__module_type__": true,
      "name": "functools",
      "spec": "functools"
     },
     "inspect": {
      "__module_type__": true,
      "name": "inspect",
      "spec": "inspect"
     },
     "logging": {
      "__module_type__": true,
      "name": "logging",
      "spec": "logging"
     },
     "os": {
      "__module_type__": true,
      "name": "os",
      "spec": "os"
     },
     "sys": {
      "__module_type__": true,
      "name": "sys",
      "spec": "sys"
     },
     "textwrap": {
      "__module_type__": true,
      "name": "textwrap",
      "spec": "textwrap"
     },
     "traceback": {
      "__module_type__": true,
      "name": "traceback",
      "spec": "traceback"
     },
     "wraps": {
      "__imported_callable__": true,
      "pickled": "gASVFwAAAAAAAACMCWZ1bmN0b29sc5SMBXdyYXBzlJOULg==",
      "name": "wraps",
      "hash": "4c7c8f91a978a903bce2515f7fe83cb09b7074259dabad02b312209312f718ed",
      "provenance": {
       "module": "functools",
       "qualname": "wraps"
      }
     },
     "Any": {
      "__imported_callable__": true,
      "pickled": "gASVEgAAAAAAAACMBnR5cGluZ5SMA0FueZSTlC4=",
      "name": "Any",
      "hash": "fbf19bc6bf716a555ce7094664e2bc898734e4acfc2cd6d9ee399edef2e5c02b",
      "provenance": {
       "module": "typing",
       "qualname": "Any"
      }
     },
     "Callable": {
      "__imported_callable__": true,
      "pickled": "gASVFwAAAAAAAACMBnR5cGluZ5SMCENhbGxhYmxllJOULg==",
      "name": "Callable",
      "hash": "17cf7f09b805961290dccb95aa11199df32c246cb879f355ffa1a31d6285edad",
      "provenance": {
       "module": "typing",
       "qualname": "Callable"
      }
     },
     "Optional": {
      "__imported_callable__": true,
      "pickled": "gASVFwAAAAAAAACMBnR5cGluZ5SMCE9wdGlvbmFslJOULg==",
      "name": "Optional",
      "hash": "d69b63c158dd563d1537447d9d3a68afdda0efb70794ab11c234d01e2e593e56",
      "provenance": {
       "module": "typing",
       "qualname": "Optional"
      }
     },
     "Type": {
      "__imported_callable__": true,
      "pickled": "gASVEwAAAAAAAACMBnR5cGluZ5SMBFR5cGWUk5Qu",
      "name": "Type",
      "hash": "9e98fdb991d3addb0aad6e13cd94b21998f5d97e9f30b15f9c697afe5cde1832",
      "provenance": {
       "module": "typing",
       "qualname": "Type"
      }
     },
     "remove_code_blocks": {
      "__imported_callable__": true,
      "pickled": "gASVLQAAAAAAAACMEmJvdHMudXRpbHMuaGVscGVyc5SMEnJlbW92ZV9jb2RlX2Jsb2Nrc5STlC4=",
      "name": "remove_code_blocks",
      "hash": "44524fda389310a2a28f80da99409efd110baefaa9ea50345d092a634c89fc1d",
      "provenance": {
       "module": "bots.utils.helpers",
       "qualname": "remove_code_blocks"
      }
     },
     "NoHTTPFilter": {
      "__imported_callable__": true,
      "pickled": "gASVKAAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjAxOb0hUVFBGaWx0ZXKUk5Qu",
      "name": "NoHTTPFilter",
      "hash": "9f920bc687c51afef3dea517f9b64393473ed37dac3fda0cedd01a655b483a52",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "NoHTTPFilter"
      }
     },
     "lazy_fn": {
      "__imported_callable__": true,
      "pickled": "gASVIwAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjAdsYXp5X2ZulJOULg==",
      "name": "lazy_fn",
      "hash": "a1737e2cf8adde594f0dd0b3f17ffaad4c126dcf16906e82cb07f18c13d8b7a2",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "lazy_fn"
      }
     },
     "lazy_class": {
      "__imported_callable__": true,
      "pickled": "gASVJgAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjApsYXp5X2NsYXNzlJOULg==",
      "name": "lazy_class",
      "hash": "d1883fc4e7eb2d64f47b4e90b4b6b69d0c5be0d0e3175787058ad631d122e4c6",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "lazy_class"
      }
     },
     "_get_context": {
      "__helper_func__": true,
      "pickled": "gASVKAAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjAxfZ2V0X2NvbnRleHSUk5Qu",
      "name": "_get_context",
      "hash": "979ef249cdc1f76f4020d948ffc352f7c667afb0d89f221770156eebd7717c7a",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "_get_context"
      }
     },
     "_get_py_interface": {
      "__helper_func__": true,
      "pickled": "gASVLQAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjBFfZ2V0X3B5X2ludGVyZmFjZZSTlC4=",
      "name": "_get_py_interface",
      "hash": "d45b0506fb8815e8d9c3a9217b0ca101dac4fb9f51c8546285cf68a95ab027e7",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "_get_py_interface"
      }
     },
     "lazy": {
      "__imported_callable__": true,
      "pickled": "gASVIAAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjARsYXp5lJOULg==",
      "name": "lazy",
      "hash": "6e25446d8765ac65a5518c01582ddf52784eb90c51d57e224c94823d5b7c55cd",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "lazy"
      }
     },
     "debug_on_error": {
      "__imported_callable__": true,
      "pickled": "gASVKgAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjA5kZWJ1Z19vbl9lcnJvcpSTlC4=",
      "name": "debug_on_error",
      "hash": "06d89d594519c41c1dae666437441d4fd4aeeea959f1c905694940a50ae4ddfe",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "debug_on_error"
      }
     },
     "log_errors": {
      "__imported_callable__": true,
      "pickled": "gASVJgAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjApsb2dfZXJyb3JzlJOULg==",
      "name": "log_errors",
      "hash": "f9446c0ae11aa5bb7726b83da744e8dc707a91edc91085abbca1cefd1897d829",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "log_errors"
      }
     },
     "toolify": {
      "__imported_callable__": true,
      "pickled": "gASVUkAAAAAAAACMCmRpbGwuX2RpbGyUjBBfY3JlYXRlX2Z1bmN0aW9ulJOUKGgAjAxfY3JlYXRlX2NvZGWUk5QoQwQEFgo2lEsBSwBLAEsCSwJLA0MShwCXAIgAZgFkAYQIfQF8AVMAlFiIAgAACiAgICBDb252ZXJ0IGFueSBmdW5jdGlvbiBpbnRvIGEgYm90IHRvb2wgd2l0aCBzdHJpbmctaW4sIHN0cmluZy1vdXQgaW50ZXJmYWNlLgoKICAgIC0gQ29udmVydHMgc3RyaW5nIGlucHV0cyB0byBwcm9wZXIgdHlwZXMgdXNpbmcgdHlwZSBoaW50cwogICAgLSBFbnN1cmVzIHN0cmluZyBvdXRwdXQgKEpTT04gZm9yIGNvbXBsZXggdHlwZXMpCiAgICAtIFdyYXBzIGluIGVycm9yIGhhbmRsaW5nIChyZXR1cm5zIGVycm9yIHN0cmluZ3MsIG5ldmVyIHJhaXNlcykKICAgIC0gRW5oYW5jZXMgZG9jc3RyaW5nIGlmIGRlc2NyaXB0aW9uIHByb3ZpZGVkCgogICAgQXJnczoKICAgICAgICBkZXNjcmlwdGlvbiAoc3RyLCBvcHRpb25hbCk6IE92ZXJyaWRlIHRoZSBmdW5jdGlvbidzIGRvY3N0cmluZwoKICAgIEV4YW1wbGU6CiAgICAgICAgQHRvb2xpZnkoKQogICAgICAgIGRlZiBhZGRfbnVtYmVycyh4OiBpbnQsIHk6IGludCA9IDApIC0+IGludDoKICAgICAgICAgICAgcmV0dXJuIHggKyB5CgogICAgICAgIEB0b29saWZ5KCJDYWxjdWxhdGUgdGhlIGFyZWEgb2YgYSBjaXJjbGUiKQogICAgICAgIGRlZiBhcmVhKHJhZGl1czogZmxvYXQpIC0+IGZsb2F0OgogICAgICAgICAgICByZXR1cm4gMy4xNDE1OSAqIHJhZGl1cyAqIHJhZGl1cwogICAglGgEKEMUBgEoAQj/CAECLAQBDgUE/BgCSAKUSwFLAEsASwJLBUsTQ7qVAYcAlwB0AAAAAAAAAAAAagMAAAAAAAAAAAAAAAAAAAAAAACJAKsBAAAAAAAAiABmAWQBhAirAAAAAAAAAH0BiQJyCYkCfAFfAgAAAAAAAAAAfAFTAHwBagQAAAAAAAAAAAAAAAAAAAAAAABzJGQCiQBqBgAAAAAAAAAAAAAAAAAAAAAAAGoJAAAAAAAAAAAAAAAAAAAAAAAAZANkBKsCAAAAAAAAmwCdAnwBXwIAAAAAAAAAAHwBUwCUKE5oBChDLAQCAgIgAxADGAIQAwwCLgEiAhACFgEYAgoBCP8KBwwCGgIMAiIBEAEMAiL9lEsASwBLAEsKSwdLH0KuAQAAlQGXAAkAdAEAAAAAAAAAAIkKfAB8AasDAAAAAAAAXAIAAH0CfQMCAIkKfAJpAHwDpAGOAX0EdAMAAAAAAAAAAHwEqwEAAAAAAABTACMAdAQAAAAAAAAAACQAci99BWQBZAJsA20EfQYBAHQLAAAAAAAAAABkA3QNAAAAAAAAAAB8BasBAAAAAAAAmwCdAqsBAAAAAAAAfQcCAHwGfAerAQAAAAAAAGMCWQBkAH0FfgVTAGQAfQV+BXcBdA4AAAAAAAAAACQAclB9BXQNAAAAAAAAAAB8BasBAAAAAAAAfQhkBHwIdgByKWQFfAh2AHIlZAZ8CHYAciF0DwAAAAAAAAAAfAibAGQHnQKrAQAAAAAAAH0JZAFkAmwDbQR9BgEAAgB8BnwJqwEAAAAAAABjAlkAZAB9BX4FUwBkAWQCbANtBH0GAQACAHwGfAWrAQAAAAAAAGMCWQBkAH0FfgVTAGQAfQV+BXcBdBAAAAAAAAAAACQAchh9BWQBZAJsA20EfQYBAAIAfAZ8BasBAAAAAAAAYwJZAGQAfQV+BVMAZAB9BX4FdwF3AHgDWQB3AZQoTksAjA5fcHJvY2Vzc19lcnJvcpSFlIwcVG9vbCBleGVjdXRpb24gaW50ZXJydXB0ZWQ6IJSMB21pc3NpbmeUjAhyZXF1aXJlZJSMCGFyZ3VtZW50lFgyAQAACgrimqDvuI8gIFRoaXMgZXJyb3IgaXMgY29tbW9ubHkgY2F1c2VkIGJ5IGhpdHRpbmcgdGhlIG1heF90b2tlbnMgbGltaXQgYmVmb3JlIGNvbXBsZXRpbmcgdGhlIHRvb2wgY2FsbC4KVGhlIHJlc3BvbnNlIHdhcyB0cnVuY2F0ZWQgbWlkLXBhcmFtZXRlciwgbWFraW5nIGl0IGFwcGVhciB0aGF0IHJlcXVpcmVkIHBhcmFtZXRlcnMgYXJlIG1pc3NpbmcuClRvIGZpeCB0aGlzOiBXb3JrIGluIFNNQUxMRVIgQ0hVTktTLiBFZGl0IGZld2VyIGxpbmVzIGF0IGEgdGltZSwgb3IgYnJlYWsgeW91ciB0YXNrIGludG8gbXVsdGlwbGUgc3RlcHMulHSUKIwUX2NvbnZlcnRfdG9vbF9pbnB1dHOUjBRfY29udmVydF90b29sX291dHB1dJSMEUtleWJvYXJkSW50ZXJydXB0lIwSYm90cy51dGlscy5oZWxwZXJzlGgMjBJUb29sRXhlY3V0aW9uRXJyb3KUjANzdHKUjAlUeXBlRXJyb3KUjAlFeGNlcHRpb26UdJQojARhcmdzlIwGa3dhcmdzlIwOY29udmVydGVkX2FyZ3OUjBBjb252ZXJ0ZWRfa3dhcmdzlIwGcmVzdWx0lIwBZZRoDIwKdG9vbF9lcnJvcpSMCWVycm9yX21zZ5SMDmVuaGFuY2VkX2Vycm9ylHSUjAg8c3RyaW5nPpSMB3dyYXBwZXKUjCt0b29saWZ5Ljxsb2NhbHM+LmRlY29yYXRvci48bG9jYWxzPi53cmFwcGVylEsYQ+34gADwBCgNKeQzR8gEyGTQVFrTM1vREDCQDtAgMPEGABoemH7QGULQMUHRGUKQBvQGABgsqEbTFzPQEDP45BMk8gAGDTL1BgARPuQdL9AyTsxz0FNUy3bIaNAwV9MdWJAK2RcloGrTFzHVEDH75BMc8gASDS3kHB+gAZtGkAnYExygCdETKahquEnRLkXIKtBYYdFKYeQlLtgbJJgr8AAEJkIB8AAEGUMB8wMGJhaQTvUOABVCAeEbKagu0xs51RQ55RRB4RspqCHTGyzVFCz73BMc8gADDSndED3hFyWgYdMXKNUQKPvwBwMNKfqUQ0qDIiYApglDFAOvJEEZA8ETAUMUA8EZDEMUA8ElMkIwA8IXAUMUA8IdDUIwA8IqAUMUA8IwDEMUA8I8DUMPA8MJAUMUA8MPBUMUA5SMBGZ1bmOUhZQpdJRSlIwIRXhlY3V0ZSCUjAFflIwBIJR0lCiMCWZ1bmN0b29sc5SMBXdyYXBzlIwHX19kb2NfX5SMCF9fbmFtZV9flIwHcmVwbGFjZZR0lGgsaCiGlGgnjAlkZWNvcmF0b3KUjBp0b29saWZ5Ljxsb2NhbHM+LmRlY29yYXRvcpRLF0Ng+YAA3AkSjx+JH5gU0wke8wIpCSnzAwAKH/ACKQkp8VgBAAwX2B4piEeMT/AKABAXiA7wCQASGZcfkh/gICioFK8dqR3XKT7RKT64c8BD0ylI0ChJ0B5KiEeMT+APFogOlEMAlIwLZGVzY3JpcHRpb26UhZRoLIWUdJRSlIaUKWg/aDuGlGgnjAd0b29saWZ5lGhGSwFDEfiAAPQsNAUX8GwBAAwV0AQUlGg+KWg/hZR0lFKUfZRoN4wiZHluYW1pY19tb2R1bGVfLTQ5OTU4NzIyMDI4NzY0NjM5NJRzaEZOhZROdJRSlH2UfZQoaDZoB4wPX19hbm5vdGF0aW9uc19flH2UaD9oAIwKX2xvYWRfdHlwZZSTlGgZhZRSlHN1hpRiaEsoaDdoTGg2TowLX19wYWNrYWdlX1+UTowKX19sb2FkZXJfX5ROjAhfX3NwZWNfX5ROjAhfX2ZpbGVfX5SMI2R5bmFtaWNfbW9kdWxlXy0yOTA3MDc3ODU3Mjg0NDUzODE4lGgUjBNib3RzLmRldi5kZWNvcmF0b3JzlGgUk5RoFWheaBWTlGgYaF5oGJOUjANhc3SUaACMDl9pbXBvcnRfbW9kdWxllJOUaGKFlFKUjAhkYXRldGltZZRoZGhnhZRSlGg0aGRoNIWUUpSMB2luc3BlY3SUaGRobIWUUpSMB2xvZ2dpbmeUaGRob4WUUpSMAm9zlGhkaHKFlFKUjANzeXOUaGSMA3N5c5SFlFKUjAh0ZXh0d3JhcJRoZGh5hZRSlIwJdHJhY2ViYWNrlGhkaHyFlFKUaDVoNGg1k5SMA0FueZSMBnR5cGluZ5RogJOUjAhDYWxsYWJsZZRogWiDk5SMCE9wdGlvbmFslGiBaIWTlIwEVHlwZZRogWiHk5SMEnJlbW92ZV9jb2RlX2Jsb2Nrc5RoF2iJk5SMBmxvZ2dlcpRob4wJZ2V0TG9nZ2VylJOUaF6FlFKUjAxOb0hUVFBGaWx0ZXKUaF5okJOUjAdsYXp5X2ZulGheaJKTlIwKbGF6eV9jbGFzc5RoXmiUk5SMDF9nZXRfY29udGV4dJRoXmiWk5SMEV9nZXRfcHlfaW50ZXJmYWNllGheaJiTlIwEbGF6eZRoXmiak5SMDmRlYnVnX29uX2Vycm9ylGheaJyTlIwKbG9nX2Vycm9yc5RoXmiek5RoRmhPjBdfY29udmVydF9zdHJpbmdfdG9fdHlwZZRoXmigk5SMEl9sb2dfZXJyb3JfdG9fZmlsZZRoXmiik5SMBGpzb26UaGRopIWUUpSMBExpc3SUaIFop5OUjANCb3SUjBRib3RzLmZvdW5kYXRpb24uYmFzZZRoqZOUjBBfZ2V0X2NhbGxpbmdfYm90lGgCKGgEKEMSAgUoAQQBTgEeASABBAEY+wYGlEsASwBLAEsCSwRLA0PelwB0AAAAAAAAAAAAagMAAAAAAAAAAAAAAAAAAAAAAACrAAAAAAAAAH0AfAByV3wAagQAAAAAAAAAAAAAAAAAAAAAAABqBgAAAAAAAAAAAAAAAAAAAAAAAGQBaygAAHIvZAJ8AGoIAAAAAAAAAAAAAAAAAAAAAAAAdgByIXwAaggAAAAAAAAAAAAAAAAAAAAAAABkAhkAAAB9AXQLAAAAAAAAAAB8AXQMAAAAAAAAAACrAgAAAAAAAHICfAFTAHwAag4AAAAAAAAAAAAAAAAAAAAAAAB9AHwAcgGMV3kDlCiMkUhlbHBlciBmdW5jdGlvbiB0byBnZXQgYSByZWZlcmVuY2UgdG8gdGhlIGNhbGxpbmcgYm90LgogICAgUmV0dXJuczoKICAgICAgICBPcHRpb25hbFtCb3RdOiBSZWZlcmVuY2UgdG8gdGhlIGNhbGxpbmcgYm90IG9yIE5vbmUgaWYgbm90IGZvdW5kCiAgICCUjA1fY3Zzbl9yZXNwb25klIwEc2VsZpROdJQoaGyMDGN1cnJlbnRmcmFtZZSMBmZfY29kZZSMB2NvX25hbWWUjAhmX2xvY2Fsc5SMCmlzaW5zdGFuY2WUaKmMBmZfYmFja5R0lIwFZnJhbWWUjA1wb3RlbnRpYWxfYm90lIaUaCdorGisS5xDY4AA9AoADRTXDCDRDCDTDCKARdkKD9gLEI88iTzXCx/RCx+gP9ILMrB2wBXHHsEe0TdP2Bwhn06ZTqg20RwyiE3cDxmYLawT1A8t2Bck0BAk2BAVlwyRDIgF8gsACxDwDAAMEJRoPikpdJRSlH2UaDdoTHNorE5OdJRSlH2UfZQoaDZor2hSfZSMBnJldHVybpSMCV9vcGVyYXRvcpSMB2dldGl0ZW2Uk5RogYwFVW5pb26Uk5Roq2hVjAhOb25lVHlwZZSFlFKUhpSGlFKUc3WGlGJowChoN2hMaDZOaFlOaFpOaFtOaFxoXWgUaF9oFWhgaBhoYWhiaGZoZ2hpaDRoa2hsaG5ob2hxaHJodGh1aHhoeWh7aHxofmg1aH9ogGiCaINohGiFaIZoh2iIaIloimiLaI9okGiRaJJok2iUaJVolmiXaJhomWiaaJtonGidaJ5on2hGaE9ooGihaKJoo2ikaKZop2ioaKloq2isaMKMDGdldF9vd25faW5mb5SMFWJvdHMudG9vbHMuc2VsZl90b29sc5Ro05OUjBRfbW9kaWZ5X293bl9zZXR0aW5nc5Ro1GjWk5SMC2JyYW5jaF9zZWxmlGjUaNiTlIwJYWRkX3Rvb2xzlGjUaNqTlIwMbGlzdF9jb250ZXh0lGgCKGgvfZRoN2hMc2jcTmgAjAxfY3JlYXRlX2NlbGyUk5ROhZRSlIWUdJRSlH2UKIwLX193cmFwcGVkX1+UaAIoaAQoQ1oGERQBBAECATQBBAIMBhABBAECAgYJBAEkARABBAE0AQQBHgEkASQBIAEEASwBFgEcARABLvwCBSQCFgEcARABMvECEEABMAE4ARwBEAEqAQQBJAIEATLhAiCUSwBLAEsASxNLCUsDQjYEAACHE4cUlwB0AQAAAAAAAAAAqwAAAAAAAAB9AHwAcwF5AXwAagIAAAAAAAAAAAAAAAAAAAAAAABqBQAAAAAAAAAAAAAAAAAAAAAAAKsAAAAAAAAAfQFnAIoTiBOIFGYCZAKECIoUAgCJFHwBqwEAAAAAAAABAIkTcwF5A2QEhAB9AmcAfQN0BwAAAAAAAAAAiROrAQAAAAAAAEQAkAFduQAAXAIAAH0EfQUCAHwCfASrAQAAAAAAAH0GZwB9B3QJAAAAAAAAAAB8BWQFqwIAAAAAAACQAXIQfAVqCgAAAAAAAAAAAAAAAAAAAAAAAJABcgNnAH0IfAVqCgAAAAAAAAAAAAAAAAAAAAAAAEQAXdIAAH0JfAlqDQAAAAAAAAAAAAAAAAAAAAAAAGQGZAerAgAAAAAAAH0KfAlqDQAAAAAAAAAAAAAAAAAAAAAAAGQIaQCrAgAAAAAAAH0LdA8AAAAAAAAAAHwLdBAAAAAAAAAAAKsCAAAAAAAAcmNnAH0MfAtqEwAAAAAAAAAAAAAAAAAAAAAAAKsAAAAAAAAARABdPAAAXAIAAH0NfQ50FQAAAAAAAAAAfA6rAQAAAAAAAH0PdBcAAAAAAAAAAHwPqwEAAAAAAABkCWtEAAByCHwPZApkCRoAZAt6AAAAfQ98DGoZAAAAAAAAAAAAAAAAAAAAAAAAfA2bAGQMfA+bAJ0DqwEAAAAAAAABAIw+BABkDWobAAAAAAAAAAAAAAAAAAAAAAAAfAyrAQAAAAAAAH0QbiF0FQAAAAAAAAAAfAurAQAAAAAAAH0QdBcAAAAAAAAAAHwQqwEAAAAAAABkCWtEAAByCHwQZApkCRoAZAt6AAAAfRB8CGoZAAAAAAAAAAAAAAAAAAAAAAAAZA58CpsAZA98EJsAZBCdBasBAAAAAAAAAQCM1AQAfAdqGQAAAAAAAAAAAAAAAAAAAAAAAGQPahsAAAAAAAAAAAAAAAAAAAAAAAB8CKsBAAAAAAAAqwEAAAAAAAABAHQJAAAAAAAAAAB8BWQRqwIAAAAAAAByU3wFahwAAAAAAAAAAAAAAAAAAAAAAAByR3wFahwAAAAAAAAAAAAAAAAAAAAAAABqHwAAAAAAAAAAAAAAAAAAAAAAAGQSZA+rAgAAAAAAAH0RdBcAAAAAAAAAAHwRqwEAAAAAAABkE2tEAAByCHwRZApkExoAZAt6AAAAfRF8B2oZAAAAAAAAAAAAAAAAAAAAAAAAZBR8EZsAZBSdA6sBAAAAAAAAAQB8B3ISZBVqGwAAAAAAAAAAAAAAAAAAAAAAAHwHqwEAAAAAAAB9Em4CZBZ9EnwDahkAAAAAAAAAAAAAAAAAAAAAAABkF3wGmwBkGHwSmwCdBKsBAAAAAAAAAQCQAYy8BABkEmobAAAAAAAAAAAAAAAAAAAAAAAAfAOrAQAAAAAAAFMAlChYSgIAAExpc3QgYWxsIGJvdCBtZXNzYWdlcyBpbiB0aGUgY29udmVyc2F0aW9uIHdpdGggbGFiZWxzIGZvciByZW1vdmFsLgoKICAgIFVzZSB0aGlzIGJlZm9yZSByZW1vdmVfY29udGV4dCB0byBzZWUgd2hhdCBtZXNzYWdlcyBhcmUgaW4geW91ciBjb252ZXJzYXRpb24uCiAgICBTaG93cyBib3QgbWVzc2FnZXMgb25seSAoc2luY2UgcmVtb3ZhbCBoYXBwZW5zIGluIHVzZXItYm90IHBhaXJzKSB3aXRoOgogICAgLSBBIGxhYmVsIFtBXSwgW0JdLCBbQ10sIGV0Yy4gZm9yIHJlZmVyZW5jZQogICAgLSBUcnVuY2F0ZWQgdG9vbCBjYWxscyAoaWYgYW55KSB3aXRoIHBhcmFtZXRlcnMKICAgIC0gVHJ1bmNhdGVkIHJlc3BvbnNlIHRleHQKCiAgICBSZXR1cm5zOgogICAgICAgIHN0cjogRm9ybWF0dGVkIGxpc3Qgb2YgYm90IG1lc3NhZ2VzIHdpdGggbGFiZWxzLCBvciBlcnJvciBtZXNzYWdlCgogICAgRXhhbXBsZSBvdXRwdXQ6CiAgICAgICAgW0FdIEJvdDogPHRvb2xfbmFtZSBwYXJhbT0idmFsdWUuLi4iPiB8ICJSZXNwb25zZSB0ZXh0Li4uIgogICAgICAgIFtCXSBCb3Q6ICJSZXNwb25zZSB0ZXh0IHdpdGhvdXQgdG9vbHMuLi4iCiAgICCUjCFFcnJvcjogQ291bGQgbm90IGZpbmQgY2FsbGluZyBib3SUaAQoQwoEAjYBIgEeARL/lEsBSwBLAEsCSwRLE0OQlQKXAHQBAAAAAAAAAAB8AGQBqwIAAAAAAAByIHwAagIAAAAAAAAAAAAAAAAAAAAAAABkAmsoAAByEYkCagUAAAAAAAAAAAAAAAAAAAAAAAB8AKsBAAAAAAAAAQB8AGoGAAAAAAAAAAAAAAAAAAAAAAAARABdCgAAfQECAIkDfAGrAQAAAAAAAAEAjAwEAHkDlCiMN1JlY3Vyc2l2ZWx5IGNvbGxlY3QgYWxsIGJvdCAoYXNzaXN0YW50KSBub2RlcyBpbiBvcmRlci6UjARyb2xllIwJYXNzaXN0YW50lE50lCiMB2hhc2F0dHKUaO6MBmFwcGVuZJSMB3JlcGxpZXOUdJSMBG5vZGWUjAVyZXBseZSGlGgnjBFjb2xsZWN0X2JvdF9ub2Rlc5SMJ2xpc3RfY29udGV4dC48bG9jYWxzPi5jb2xsZWN0X2JvdF9ub2Rlc5RLZkM8+IAA5AsSkDSYFtQLIKBUp1mhWbAr0iU92AwV1wwc0QwcmFTUDCLYFRmXXJRciEXZDB2YZdUMJPEDABYilGg+jAlib3Rfbm9kZXOUaPiGlCl0lFKUjCVObyBib3QgbWVzc2FnZXMgZm91bmQgaW4gY29udmVyc2F0aW9ulGgEKEMQAgIEAQoBCgEKASgBCv0MBJRLAUsASwBLAksFSxNDZpcAZAF9AXwAZAJ6DQAAfQB8AGQDa0QAAHIkfABkAnoXAAB9AHQBAAAAAAAAAABkBHwAZAV6BgAAegAAAKsBAAAAAAAAfAF6AAAAfQF8AGQFeg8AAH0AfABkA2tEAAByAYwkfAFTAJQojD1HZW5lcmF0ZSBFeGNlbC1zdHlsZSBjb2x1bW4gbGFiZWxzOiBBLCBCLCAuLi4sIFosIEFBLCBBQiwgLi4ulIwAlEsBSwBLQUsadJSMA2NocpSFlIwFaW5kZXiUjAVsYWJlbJSGlGgnjA5nZW5lcmF0ZV9sYWJlbJSMJGxpc3RfY29udGV4dC48bG9jYWxzPi5nZW5lcmF0ZV9sYWJlbJRLcENQgADgEBKIBdgIDZARiQqIBdgOE5BhimnYDBGQUYlKiEXcFBeYAphVoFKZWpkP0xQoqDXRFDCIRdgMEZBiiUyIRfAHAA8UkGGLafAIABAViAyUaD4pKXSUUpSMCnRvb2xfY2FsbHOUjARuYW1llIwHdW5rbm93bpSMBWlucHV0lEsUTowDLi4ulIwBPZSMAiwglIwBPJRoMowBPpSMB2NvbnRlbnSUjAEKlEsyjAEilIwDIHwglIwPPGVtcHR5IG1lc3NhZ2U+lIwBW5SMB10gQm90OiCUdJQoaKyMDGNvbnZlcnNhdGlvbpSMCl9maW5kX3Jvb3SUjAllbnVtZXJhdGWUaPFqDwEAAIwDZ2V0lGi3jARkaWN0lIwFaXRlbXOUaBmMA2xlbpRo8owEam9pbpRqGAEAAGg4dJQojANib3SUjARyb290lGoKAQAAjAVsaW5lc5SMAWmUaPVqCAEAAIwFcGFydHOUjAl0b29sX3N0cnOUjAl0b29sX2NhbGyUjAl0b29sX25hbWWUjAp0b29sX2lucHV0lIwLcGFyYW1fcGFydHOUjANrZXmUjAV2YWx1ZZSMCXZhbHVlX3N0cpSMCnBhcmFtc19zdHKUahgBAACMC21lc3NhZ2Vfc3RylHSUaCdo3GjcS09CFgIAAPmAAPQiAAsb0wocgEPZCw7YDzLYCw7XCxvRCxvXCybRCybTCyiARNgQEoBJ9QQFBSXxDAAFFpBk1AQb2QsU2A828gQIBRXwEgAND4BF3BMcmFnXEyeJB4gBiDTZEB6YcdMQIYgF2BASiAXcCxKQNJgc1QsmqDSvP6s/2BgaiEnYHSGfX5xfkAnYHCWfTZlNqCawKdMcPJAJ2B0mn12ZXag3sELTHTeQCtwTHZhqrCTUEy/YIiSQS9gmMNcmNtEmNtYmOJkKmAOYVdwkJ6gFo0qYCdwbHph5mz6oQtIbLtgoMbAjsDKoDrgV0Sg+mEnYGCPXGCrRGCqoY6hVsCGwSbA70Cs/1RhA8AkAJznwCgAiJqcZoRmoO9MhN5FK5CEkoFqjH5BK3BcamDqTf6gS0hcr2CUvsAOwEqBfsHXRJTyYCtgQGdcQINEQIKAxoFmgS6hxsBqwDLhB0CE+1RA/8B8AHi3wIAANEo9MiUyYE58YmRigKdMZLNQMLdwLEpA0mBnUCyOoBK8MqgzYFhqXbJFs1xYq0RYqqDSwE9MWNYhH3A8SkDeLfJhi0g8g2BohoCOgMpgsqBXRGi6QB9gMEY9MiUyYMZhXmEmgUZge1Awo2QsQ2BofnyqZKqBV0xoriUvgGiuIS9gIDY8MiQyQcZgVmAeYd6B7oG3QFTTWCDXwPwAUKPBAAQAMEI85iTmQVdMLG9AEG5RoPilo+2j4hpR0lFKUfZRoN2hMc2jcTk50lFKUfZR9lChoNmjpaFJ9lGjGaFdzdYaUYowSX19tb2R1bGVfY29udGV4dF9flGiqjA1Nb2R1bGVDb250ZXh0lJOUKYGUfZQoahABAABoTIwGc291cmNllFjeGQAAZGVmIHRvb2xpZnkoZGVzY3JpcHRpb246IHN0ciA9IE5vbmUpOgogICAgIiIiCiAgICBDb252ZXJ0IGFueSBmdW5jdGlvbiBpbnRvIGEgYm90IHRvb2wgd2l0aCBzdHJpbmctaW4sIHN0cmluZy1vdXQgaW50ZXJmYWNlLgoKICAgIC0gQ29udmVydHMgc3RyaW5nIGlucHV0cyB0byBwcm9wZXIgdHlwZXMgdXNpbmcgdHlwZSBoaW50cwogICAgLSBFbnN1cmVzIHN0cmluZyBvdXRwdXQgKEpTT04gZm9yIGNvbXBsZXggdHlwZXMpCiAgICAtIFdyYXBzIGluIGVycm9yIGhhbmRsaW5nIChyZXR1cm5zIGVycm9yIHN0cmluZ3MsIG5ldmVyIHJhaXNlcykKICAgIC0gRW5oYW5jZXMgZG9jc3RyaW5nIGlmIGRlc2NyaXB0aW9uIHByb3ZpZGVkCgogICAgQXJnczoKICAgICAgICBkZXNjcmlwdGlvbiAoc3RyLCBvcHRpb25hbCk6IE92ZXJyaWRlIHRoZSBmdW5jdGlvbidzIGRvY3N0cmluZwoKICAgIEV4YW1wbGU6CiAgICAgICAgQHRvb2xpZnkoKQogICAgICAgIGRlZiBhZGRfbnVtYmVycyh4OiBpbnQsIHk6IGludCA9IDApIC0+IGludDoKICAgICAgICAgICAgcmV0dXJuIHggKyB5CgogICAgICAgIEB0b29saWZ5KCJDYWxjdWxhdGUgdGhlIGFyZWEgb2YgYSBjaXJjbGUiKQogICAgICAgIGRlZiBhcmVhKHJhZGl1czogZmxvYXQpIC0+IGZsb2F0OgogICAgICAgICAgICByZXR1cm4gMy4xNDE1OSAqIHJhZGl1cyAqIHJhZGl1cwogICAgIiIiCgogICAgZGVmIGRlY29yYXRvcihmdW5jKToKICAgICAgICBAZnVuY3Rvb2xzLndyYXBzKGZ1bmMpCiAgICAgICAgZGVmIHdyYXBwZXIoKmFyZ3MsICoqa3dhcmdzKToKICAgICAgICAgICAgdHJ5OgogICAgICAgICAgICAgICAgIyBDb252ZXJ0IHN0cmluZyBpbnB1dHMgdG8gcHJvcGVyIHR5cGVzIHVzaW5nIHR5cGUgaGludHMKICAgICAgICAgICAgICAgIGNvbnZlcnRlZF9hcmdzLCBjb252ZXJ0ZWRfa3dhcmdzID0gX2NvbnZlcnRfdG9vbF9pbnB1dHMoZnVuYywgYXJncywga3dhcmdzKQoKICAgICAgICAgICAgICAgICMgQ2FsbCBvcmlnaW5hbCBmdW5jdGlvbgogICAgICAgICAgICAgICAgcmVzdWx0ID0gZnVuYygqY29udmVydGVkX2FyZ3MsICoqY29udmVydGVkX2t3YXJncykKCiAgICAgICAgICAgICAgICAjIENvbnZlcnQgcmVzdWx0IHRvIHN0cmluZwogICAgICAgICAgICAgICAgcmV0dXJuIF9jb252ZXJ0X3Rvb2xfb3V0cHV0KHJlc3VsdCkKCiAgICAgICAgICAgIGV4Y2VwdCBLZXlib2FyZEludGVycnVwdCBhcyBlOgogICAgICAgICAgICAgICAgIyBDb252ZXJ0IEtleWJvYXJkSW50ZXJydXB0IHRvIFRvb2xFeGVjdXRpb25FcnJvciB0byBwcmV2ZW50IGl0IGZyb20KICAgICAgICAgICAgICAgICMgYnViYmxpbmcgdXAgdG8gQ0xJIGFuZCBiZWluZyB0cmVhdGVkIGFzIHVzZXIgQ3RybCtDCiAgICAgICAgICAgICAgICBmcm9tIGJvdHMudXRpbHMuaGVscGVycyBpbXBvcnQgX3Byb2Nlc3NfZXJyb3IKCiAgICAgICAgICAgICAgICB0b29sX2Vycm9yID0gVG9vbEV4ZWN1dGlvbkVycm9yKGYiVG9vbCBleGVjdXRpb24gaW50ZXJydXB0ZWQ6IHtzdHIoZSl9IikKICAgICAgICAgICAgICAgIHJldHVybiBfcHJvY2Vzc19lcnJvcih0b29sX2Vycm9yKQoKICAgICAgICAgICAgZXhjZXB0IFR5cGVFcnJvciBhcyBlOgogICAgICAgICAgICAgICAgIyBDaGVjayBpZiB0aGlzIGlzIGEgbWlzc2luZyByZXF1aXJlZCBhcmd1bWVudCBlcnJvcgogICAgICAgICAgICAgICAgZXJyb3JfbXNnID0gc3RyKGUpCiAgICAgICAgICAgICAgICBpZiAibWlzc2luZyIgaW4gZXJyb3JfbXNnIGFuZCAicmVxdWlyZWQiIGluIGVycm9yX21zZyBhbmQgImFyZ3VtZW50IiBpbiBlcnJvcl9tc2c6CiAgICAgICAgICAgICAgICAgICAgIyBBZGQgc3BlY2lhbCBtZXNzYWdlIGZvciBvdXRwdXQgdG9rZW4gbGltaXRhdGlvbgogICAgICAgICAgICAgICAgICAgIGVuaGFuY2VkX2Vycm9yID0gVHlwZUVycm9yKAogICAgICAgICAgICAgICAgICAgICAgICBmIntlcnJvcl9tc2d9XG5cbiIKICAgICAgICAgICAgICAgICAgICAgICAgZiLimqDvuI8gIFRoaXMgZXJyb3IgaXMgY29tbW9ubHkgY2F1c2VkIGJ5IGhpdHRpbmcgdGhlIG1heF90b2tlbnMgbGltaXQgYmVmb3JlIGNvbXBsZXRpbmcgdGhlIHRvb2wgY2FsbC5cbiIKICAgICAgICAgICAgICAgICAgICAgICAgZiJUaGUgcmVzcG9uc2Ugd2FzIHRydW5jYXRlZCBtaWQtcGFyYW1ldGVyLCBtYWtpbmcgaXQgYXBwZWFyIHRoYXQgcmVxdWlyZWQgcGFyYW1ldGVycyBhcmUgbWlzc2luZy5cbiIKICAgICAgICAgICAgICAgICAgICAgICAgZiJUbyBmaXggdGhpczogV29yayBpbiBTTUFMTEVSIENIVU5LUy4gRWRpdCBmZXdlciBsaW5lcyBhdCBhIHRpbWUsICIKICAgICAgICAgICAgICAgICAgICAgICAgZiJvciBicmVhayB5b3VyIHRhc2sgaW50byBtdWx0aXBsZSBzdGVwcy4iCiAgICAgICAgICAgICAgICAgICAgKQogICAgICAgICAgICAgICAgICAgIGZyb20gYm90cy51dGlscy5oZWxwZXJzIGltcG9ydCBfcHJvY2Vzc19lcnJvcgoKICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3Byb2Nlc3NfZXJyb3IoZW5oYW5jZWRfZXJyb3IpCiAgICAgICAgICAgICAgICBlbHNlOgogICAgICAgICAgICAgICAgICAgIGZyb20gYm90cy51dGlscy5oZWxwZXJzIGltcG9ydCBfcHJvY2Vzc19lcnJvcgoKICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3Byb2Nlc3NfZXJyb3IoZSkKICAgICAgICAgICAgZXhjZXB0IEV4Y2VwdGlvbiBhcyBlOgogICAgICAgICAgICAgICAgZnJvbSBib3RzLnV0aWxzLmhlbHBlcnMgaW1wb3J0IF9wcm9jZXNzX2Vycm9yCgogICAgICAgICAgICAgICAgcmV0dXJuIF9wcm9jZXNzX2Vycm9yKGUpCgogICAgICAgICMgVXBkYXRlIGRvY3N0cmluZyBpZiBkZXNjcmlwdGlvbiBwcm92aWRlZAogICAgICAgIGlmIGRlc2NyaXB0aW9uOgogICAgICAgICAgICB3cmFwcGVyLl9fZG9jX18gPSBkZXNjcmlwdGlvbgogICAgICAgIGVsaWYgbm90IHdyYXBwZXIuX19kb2NfXzoKICAgICAgICAgICAgIyBHZW5lcmF0ZSBtaW5pbWFsIGRvY3N0cmluZyBmcm9tIGZ1bmN0aW9uIG5hbWUKICAgICAgICAgICAgd3JhcHBlci5fX2RvY19fID0gZiJFeGVjdXRlIHtmdW5jLl9fbmFtZV9fLnJlcGxhY2UoJ18nLCAnICcpfSIKCiAgICAgICAgcmV0dXJuIHdyYXBwZXIKCiAgICByZXR1cm4gZGVjb3JhdG9yCgpAdG9vbGlmeSgpCmRlZiBsaXN0X2NvbnRleHQoKSAtPiBzdHI6CiAgICAiIiJMaXN0IGFsbCBib3QgbWVzc2FnZXMgaW4gdGhlIGNvbnZlcnNhdGlvbiB3aXRoIGxhYmVscyBmb3IgcmVtb3ZhbC4KCiAgICBVc2UgdGhpcyBiZWZvcmUgcmVtb3ZlX2NvbnRleHQgdG8gc2VlIHdoYXQgbWVzc2FnZXMgYXJlIGluIHlvdXIgY29udmVyc2F0aW9uLgogICAgU2hvd3MgYm90IG1lc3NhZ2VzIG9ubHkgKHNpbmNlIHJlbW92YWwgaGFwcGVucyBpbiB1c2VyLWJvdCBwYWlycykgd2l0aDoKICAgIC0gQSBsYWJlbCBbQV0sIFtCXSwgW0NdLCBldGMuIGZvciByZWZlcmVuY2UKICAgIC0gVHJ1bmNhdGVkIHRvb2wgY2FsbHMgKGlmIGFueSkgd2l0aCBwYXJhbWV0ZXJzCiAgICAtIFRydW5jYXRlZCByZXNwb25zZSB0ZXh0CgogICAgUmV0dXJuczoKICAgICAgICBzdHI6IEZvcm1hdHRlZCBsaXN0IG9mIGJvdCBtZXNzYWdlcyB3aXRoIGxhYmVscywgb3IgZXJyb3IgbWVzc2FnZQoKICAgIEV4YW1wbGUgb3V0cHV0OgogICAgICAgIFtBXSBCb3Q6IDx0b29sX25hbWUgcGFyYW09InZhbHVlLi4uIj4gfCAiUmVzcG9uc2UgdGV4dC4uLiIKICAgICAgICBbQl0gQm90OiAiUmVzcG9uc2UgdGV4dCB3aXRob3V0IHRvb2xzLi4uIgogICAgIiIiCiAgICBib3QgPSBfZ2V0X2NhbGxpbmdfYm90KCkKICAgIGlmIG5vdCBib3Q6CiAgICAgICAgcmV0dXJuICdFcnJvcjogQ291bGQgbm90IGZpbmQgY2FsbGluZyBib3QnCiAgICByb290ID0gYm90LmNvbnZlcnNhdGlvbi5fZmluZF9yb290KCkKICAgIGJvdF9ub2RlcyA9IFtdCgogICAgZGVmIGNvbGxlY3RfYm90X25vZGVzKG5vZGUpOgogICAgICAgICIiIlJlY3Vyc2l2ZWx5IGNvbGxlY3QgYWxsIGJvdCAoYXNzaXN0YW50KSBub2RlcyBpbiBvcmRlci4iIiIKICAgICAgICBpZiBoYXNhdHRyKG5vZGUsICdyb2xlJykgYW5kIG5vZGUucm9sZSA9PSAnYXNzaXN0YW50JzoKICAgICAgICAgICAgYm90X25vZGVzLmFwcGVuZChub2RlKQogICAgICAgIGZvciByZXBseSBpbiBub2RlLnJlcGxpZXM6CiAgICAgICAgICAgIGNvbGxlY3RfYm90X25vZGVzKHJlcGx5KQogICAgY29sbGVjdF9ib3Rfbm9kZXMocm9vdCkKICAgIGlmIG5vdCBib3Rfbm9kZXM6CiAgICAgICAgcmV0dXJuICdObyBib3QgbWVzc2FnZXMgZm91bmQgaW4gY29udmVyc2F0aW9uJwoKICAgIGRlZiBnZW5lcmF0ZV9sYWJlbChpbmRleCk6CiAgICAgICAgIiIiR2VuZXJhdGUgRXhjZWwtc3R5bGUgY29sdW1uIGxhYmVsczogQSwgQiwgLi4uLCBaLCBBQSwgQUIsIC4uLiIiIgogICAgICAgIGxhYmVsID0gJycKICAgICAgICBpbmRleCArPSAxCiAgICAgICAgd2hpbGUgaW5kZXggPiAwOgogICAgICAgICAgICBpbmRleCAtPSAxCiAgICAgICAgICAgIGxhYmVsID0gY2hyKDY1ICsgaW5kZXggJSAyNikgKyBsYWJlbAogICAgICAgICAgICBpbmRleCAvLz0gMjYKICAgICAgICByZXR1cm4gbGFiZWwKICAgIGxpbmVzID0gW10KICAgIGZvciBpLCBub2RlIGluIGVudW1lcmF0ZShib3Rfbm9kZXMpOgogICAgICAgIGxhYmVsID0gZ2VuZXJhdGVfbGFiZWwoaSkKICAgICAgICBwYXJ0cyA9IFtdCiAgICAgICAgaWYgaGFzYXR0cihub2RlLCAndG9vbF9jYWxscycpIGFuZCBub2RlLnRvb2xfY2FsbHM6CiAgICAgICAgICAgIHRvb2xfc3RycyA9IFtdCiAgICAgICAgICAgIGZvciB0b29sX2NhbGwgaW4gbm9kZS50b29sX2NhbGxzOgogICAgICAgICAgICAgICAgdG9vbF9uYW1lID0gdG9vbF9jYWxsLmdldCgnbmFtZScsICd1bmtub3duJykKICAgICAgICAgICAgICAgIHRvb2xfaW5wdXQgPSB0b29sX2NhbGwuZ2V0KCdpbnB1dCcsIHt9KQogICAgICAgICAgICAgICAgaWYgaXNpbnN0YW5jZSh0b29sX2lucHV0LCBkaWN0KToKICAgICAgICAgICAgICAgICAgICBwYXJhbV9wYXJ0cyA9IFtdCiAgICAgICAgICAgICAgICAgICAgZm9yIGtleSwgdmFsdWUgaW4gdG9vbF9pbnB1dC5pdGVtcygpOgogICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZV9zdHIgPSBzdHIodmFsdWUpCiAgICAgICAgICAgICAgICAgICAgICAgIGlmIGxlbih2YWx1ZV9zdHIpID4gMjA6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZV9zdHIgPSB2YWx1ZV9zdHJbOjIwXSArICcuLi4nCiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtX3BhcnRzLmFwcGVuZChmJ3trZXl9PXt2YWx1ZV9zdHJ9JykKICAgICAgICAgICAgICAgICAgICBwYXJhbXNfc3RyID0gJywgJy5qb2luKHBhcmFtX3BhcnRzKQogICAgICAgICAgICAgICAgZWxzZToKICAgICAgICAgICAgICAgICAgICBwYXJhbXNfc3RyID0gc3RyKHRvb2xfaW5wdXQpCiAgICAgICAgICAgICAgICAgICAgaWYgbGVuKHBhcmFtc19zdHIpID4gMjA6CiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtc19zdHIgPSBwYXJhbXNfc3RyWzoyMF0gKyAnLi4uJwogICAgICAgICAgICAgICAgdG9vbF9zdHJzLmFwcGVuZChmJzx7dG9vbF9uYW1lfSB7cGFyYW1zX3N0cn0+JykKICAgICAgICAgICAgcGFydHMuYXBwZW5kKCcgJy5qb2luKHRvb2xfc3RycykpCiAgICAgICAgaWYgaGFzYXR0cihub2RlLCAnY29udGVudCcpIGFuZCBub2RlLmNvbnRlbnQ6CiAgICAgICAgICAgIGNvbnRlbnQgPSBub2RlLmNvbnRlbnQucmVwbGFjZSgnXG4nLCAnICcpCiAgICAgICAgICAgIGlmIGxlbihjb250ZW50KSA+IDUwOgogICAgICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnRbOjUwXSArICcuLi4nCiAgICAgICAgICAgIHBhcnRzLmFwcGVuZChmJyJ7Y29udGVudH0iJykKICAgICAgICBpZiBwYXJ0czoKICAgICAgICAgICAgbWVzc2FnZV9zdHIgPSAnIHwgJy5qb2luKHBhcnRzKQogICAgICAgIGVsc2U6CiAgICAgICAgICAgIG1lc3NhZ2Vfc3RyID0gJzxlbXB0eSBtZXNzYWdlPicKICAgICAgICBsaW5lcy5hcHBlbmQoZidbe2xhYmVsfV0gQm90OiB7bWVzc2FnZV9zdHJ9JykKICAgIHJldHVybiAnXG4nLmpvaW4obGluZXMpCgpkZWYgX2dldF9jYWxsaW5nX2JvdCgpIC0+IE9wdGlvbmFsW0JvdF06CiAgICAiIiJIZWxwZXIgZnVuY3Rpb24gdG8gZ2V0IGEgcmVmZXJlbmNlIHRvIHRoZSBjYWxsaW5nIGJvdC4KICAgIFJldHVybnM6CiAgICAgICAgT3B0aW9uYWxbQm90XTogUmVmZXJlbmNlIHRvIHRoZSBjYWxsaW5nIGJvdCBvciBOb25lIGlmIG5vdCBmb3VuZAogICAgIiIiCiAgICBmcmFtZSA9IGluc3BlY3QuY3VycmVudGZyYW1lKCkKICAgIHdoaWxlIGZyYW1lOgogICAgICAgIGlmIGZyYW1lLmZfY29kZS5jb19uYW1lID09ICdfY3Zzbl9yZXNwb25kJyBhbmQgJ3NlbGYnIGluIGZyYW1lLmZfbG9jYWxzOgogICAgICAgICAgICBwb3RlbnRpYWxfYm90ID0gZnJhbWUuZl9sb2NhbHNbJ3NlbGYnXQogICAgICAgICAgICBpZiBpc2luc3RhbmNlKHBvdGVudGlhbF9ib3QsIEJvdCk6CiAgICAgICAgICAgICAgICByZXR1cm4gcG90ZW50aWFsX2JvdAogICAgICAgIGZyYW1lID0gZnJhbWUuZl9iYWNrCiAgICByZXR1cm4gTm9uZZSMCWZpbGVfcGF0aJRoXYwJbmFtZXNwYWNllGhkjC5fX3J1bnRpbWVfXy5keW5hbWljX21vZHVsZV8tNDk5NTg3MjIwMjg3NjQ2Mzk0lIWUUpR9lChoN2hMaDZOaFlOaFtOaFxoXWgUaF9oFWhgaBhoYWhiaGZoZ2hpaDRoa2hsaG5ob2hxaHJodGh1aHhoeWh7aHxofmg1aH9ogGiCaINohGiFaIZoh2iIaIloimiLaI9okGiRaJJok2iUaJVolmiXaJhomWiaaJtonGidaJ5on2hGaE9ooGihaKJoo2ikaKZop2ioaKloq2isaMJo02jVaNZo12jYaNlo2mjbaNxo5IwOcmVtb3ZlX2NvbnRleHSUaNRqUQEAAJOUjBVfcHJvY2Vzc19zdHJpbmdfYXJyYXmUaNRqUwEAAJOUjBFfdmVyYm9zZV9jYWxsYmFja5Ro1GpVAQAAk5SMF19yZW1vdmVfZHVtbXlfZnJvbV90cmVllGjUalcBAACTlIwIc3ViYWdlbnSUaNRqWQEAAJOUdWKMCWNvZGVfaGFzaJSMIDAxN2ZjNTllZGE1ZTNiMzI1MGQ0NTEzZjU4ODVhZTIxlHVidX2UKGg2aOloUmpCAQAAdYaUYmo9AQAAKGg3aExoNk5oWU5oWk5oW05oXGhdaBRoX2gVaGBoGGhhaGJoZmhnaGloNGhraGxobmhvaHFocmh0aHVoeGh5aHtofGh+aDVof2iAaIJog2iEaIVohmiHaIhoiWiKaItoj2iQaJFokmiTaJRolWiWaJdomGiZaJpom2icaJ1onmifaEZoT2igaKFoomijaKRopminaKhoqWiraKxowmjTaNVo1mjXaNho2WjaaNto3GjkalEBAABqUgEAAGpTAQAAalQBAABqVQEAAGpWAQAAalcBAABqWAEAAGpZAQAAaloBAACMDF9fYnVpbHRpbnNfX5RjYnVpbHRpbnMKX19kaWN0X18KdTCMCGJ1aWx0aW5zlIwHZ2V0YXR0cpSTlIwEZGlsbJSMBV9kaWxslJOUjAhfc2V0YXR0cpRqYAEAAIwHc2V0YXR0cpSTlIeUUpRo4YwNY2VsbF9jb250ZW50c5RqPwEAAIeUUjBo3ShoN2hMaDZOaFlOaFpOaFtOaFxoXWgUaF9oFWhgaBhoYWhiaGZoZ2hpaDRoa2hsaG5ob2hxaHJodGh1aHhoeWh7aHxofmg1aH9ogGiCaINohGiFaIZoh2iIaIloimiLaI9okGiRaJJok2iUaJVolmiXaJhomWiaaJtonGidaJ5on2hGaE9ooGihaKJoo2ikaKZop2ioaKloq2isaMJo02jVaNZo12jYaNlo2mjbaNxo5GpRAQAAalIBAABqUwEAAGpUAQAAalUBAABqVgEAAGpXAQAAalgBAABqWQEAAGpaAQAAal8BAABjYnVpbHRpbnMKX19kaWN0X18KdTBqUQEAAGpSAQAAalMBAABqVAEAAGpVAQAAalYBAABqVwEAAGpYAQAAalkBAABqWgEAAGpfAQAAY2J1aWx0aW5zCl9fZGljdF9fCnUwaNNo1WjWaNdo2GjZaNpo22jcaORqUQEAAGpSAQAAalMBAABqVAEAAGpVAQAAalYBAABqVwEAAGpYAQAAalkBAABqWgEAAGpfAQAAY2J1aWx0aW5zCl9fZGljdF9fCnUwLg==",
      "name": "toolify",
      "hash": "b2ae1548b9acbf5a32e959487fa270c23b9ab383e916fcbf90b92ced3ea7bbde",
      "provenance": {
       "module": "dynamic_module_-499587220287646394",
       "qualname": "toolify"
      }
     },
     "_convert_string_to_type": {
      "__helper_func__": true,
      "pickled": "gASVMwAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjBdfY29udmVydF9zdHJpbmdfdG9fdHlwZZSTlC4=",
      "name": "_convert_string_to_type",
      "hash": "024e40c56cb46e6fe9f52fe7e6e64a3effc17736268ef31195596c6a6be4c311",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "_convert_string_to_type"
      }
     },
     "_log_error_to_file": {
      "__helper_func__": true,
      "pickled": "gASVLgAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjBJfbG9nX2Vycm9yX3RvX2ZpbGWUk5Qu",
      "name": "_log_error_to_file",
      "hash": "c02546b672eb25afd5dc51ea7e1967cbb6fd264ca18ffd15c3cbeccebe4046ba",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "_log_error_to_file"
      }
     },
     "json": {
      "__module_type__": true,
      "name": "json",
      "spec": "json"
     },
     "List": {
      "__imported_callable__": true,
      "pickled": "gASVEwAAAAAAAACMBnR5cGluZ5SMBExpc3SUk5Qu",
      "name": "List",
      "hash": "4177cb372f5ac2e670cf003d399db45b34278d8cf8801c6f8c592fc37176022f",
      "provenance": {
       "module": "typing",
       "qualname": "List"
      }
     },
     "Bot": {
      "__imported_callable__": true,
      "pickled": "gASVIAAAAAAAAACMFGJvdHMuZm91bmRhdGlvbi5iYXNllIwDQm90lJOULg==",
      "name": "Bot",
      "hash": "0a4ab7f39ea6cd147bb4589dad55c5e11e3d88deb65d684e7a6c7e8c28fdc6d1",
      "provenance": {
       "module": "bots.foundation.base",
       "qualname": "Bot"
      }
     },
     "get_own_info": {
      "__imported_callable__": true,
      "pickled": "gASVKgAAAAAAAACMFWJvdHMudG9vbHMuc2VsZl90b29sc5SMDGdldF9vd25faW5mb5STlC4=",
      "name": "get_own_info",
      "hash": "a20f468fbbd729bc4fde649cc3830e7b5c2e833d58d43dd03569e6c0ac35033d",
      "provenance": {
       "module": "bots.tools.self_tools",
       "qualname": "get_own_info"
      }
     },
     "_modify_own_settings": {
      "__helper_func__": true,
      "pickled": "gASVMgAAAAAAAACMFWJvdHMudG9vbHMuc2VsZl90b29sc5SMFF9tb2RpZnlfb3duX3NldHRpbmdzlJOULg==",
      "name": "_modify_own_settings",
      "hash": "3fbf37fea12c6b3b0a4306c19e227a47baa08f0d466d9aa96fba9748699c8d87",
      "provenance": {
       "module": "bots.tools.self_tools",
       "qualname": "_modify_own_settings"
      }
     },
     "branch_self": {
      "__imported_callable__": true,
      "pickled": "gASVKQAAAAAAAACMFWJvdHMudG9vbHMuc2VsZl90b29sc5SMC2JyYW5jaF9zZWxmlJOULg==",
      "name": "branch_self",
      "hash": "a4acbba0c53b6a30a2e0f0dc15a52af6e382d0b26eb91622345703c3dc10fc99",
      "provenance": {
       "module": "bots.tools.self_tools",
       "qualname": "branch_self"
      }
     },
     "add_tools": {
      "__imported_callable__": true,
      "pickled": "gASVJwAAAAAAAACMFWJvdHMudG9vbHMuc2VsZl90b29sc5SMCWFkZF90b29sc5STlC4=",
      "name": "add_tools",
      "hash": "e426bca163b5fc4ada03a5244a935139d0d4d742aaec2eb42e1da978c803b0f5",
      "provenance": {
       "module": "bots.tools.self_tools",
       "qualname": "add_tools"
      }
     },
     "list_context": {
      "__imported_callable__": true,
      "pickled": "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jzmJOZBV0wsb0AQblGhMKWhNaEmGlHSUUpR9lGgsaC1zaC5OTnSUUpR9lH2UKIwHX19kb2NfX5RoOowPX19hbm5vdGF0aW9uc19flH2UjAZyZXR1cm6UaACMCl9sb2FkX3R5cGWUk5RoFIWUUpRzdYaUYowSX19tb2R1bGVfY29udGV4dF9flIwUYm90cy5mb3VuZGF0aW9uLmJhc2WUjA1Nb2R1bGVDb250ZXh0lJOUKYGUfZQoaGJoLYwGc291cmNllFjeGQAAZGVmIHRvb2xpZnkoZGVzY3JpcHRpb246IHN0ciA9IE5vbmUpOgogICAgIiIiCiAgICBDb252ZXJ0IGFueSBmdW5jdGlvbiBpbnRvIGEgYm90IHRvb2wgd2l0aCBzdHJpbmctaW4sIHN0cmluZy1vdXQgaW50ZXJmYWNlLgoKICAgIC0gQ29udmVydHMgc3RyaW5nIGlucHV0cyB0byBwcm9wZXIgdHlwZXMgdXNpbmcgdHlwZSBoaW50cwogICAgLSBFbnN1cmVzIHN0cmluZyBvdXRwdXQgKEpTT04gZm9yIGNvbXBsZXggdHlwZXMpCiAgICAtIFdyYXBzIGluIGVycm9yIGhhbmRsaW5nIChyZXR1cm5zIGVycm9yIHN0cmluZ3MsIG5ldmVyIHJhaXNlcykKICAgIC0gRW5oYW5jZXMgZG9jc3RyaW5nIGlmIGRlc2NyaXB0aW9uIHByb3ZpZGVkCgogICAgQXJnczoKICAgICAgICBkZXNjcmlwdGlvbiAoc3RyLCBvcHRpb25hbCk6IE92ZXJyaWRlIHRoZSBmdW5jdGlvbidzIGRvY3N0cmluZwoKICAgIEV4YW1wbGU6CiAgICAgICAgQHRvb2xpZnkoKQogICAgICAgIGRlZiBhZGRfbnVtYmVycyh4OiBpbnQsIHk6IGludCA9IDApIC0+IGludDoKICAgICAgICAgICAgcmV0dXJuIHggKyB5CgogICAgICAgIEB0b29saWZ5KCJDYWxjdWxhdGUgdGhlIGFyZWEgb2YgYSBjaXJjbGUiKQogICAgICAgIGRlZiBhcmVhKHJhZGl1czogZmxvYXQpIC0+IGZsb2F0OgogICAgICAgICAgICByZXR1cm4gMy4xNDE1OSAqIHJhZGl1cyAqIHJhZGl1cwogICAgIiIiCgogICAgZGVmIGRlY29yYXRvcihmdW5jKToKICAgICAgICBAZnVuY3Rvb2xzLndyYXBzKGZ1bmMpCiAgICAgICAgZGVmIHdyYXBwZXIoKmFyZ3MsICoqa3dhcmdzKToKICAgICAgICAgICAgdHJ5OgogICAgICAgICAgICAgICAgIyBDb252ZXJ0IHN0cmluZyBpbnB1dHMgdG8gcHJvcGVyIHR5cGVzIHVzaW5nIHR5cGUgaGludHMKICAgICAgICAgICAgICAgIGNvbnZlcnRlZF9hcmdzLCBjb252ZXJ0ZWRfa3dhcmdzID0gX2NvbnZlcnRfdG9vbF9pbnB1dHMoZnVuYywgYXJncywga3dhcmdzKQoKICAgICAgICAgICAgICAgICMgQ2FsbCBvcmlnaW5hbCBmdW5jdGlvbgogICAgICAgICAgICAgICAgcmVzdWx0ID0gZnVuYygqY29udmVydGVkX2FyZ3MsICoqY29udmVydGVkX2t3YXJncykKCiAgICAgICAgICAgICAgICAjIENvbnZlcnQgcmVzdWx0IHRvIHN0cmluZwogICAgICAgICAgICAgICAgcmV0dXJuIF9jb252ZXJ0X3Rvb2xfb3V0cHV0KHJlc3VsdCkKCiAgICAgICAgICAgIGV4Y2VwdCBLZXlib2FyZEludGVycnVwdCBhcyBlOgogICAgICAgICAgICAgICAgIyBDb252ZXJ0IEtleWJvYXJkSW50ZXJydXB0IHRvIFRvb2xFeGVjdXRpb25FcnJvciB0byBwcmV2ZW50IGl0IGZyb20KICAgICAgICAgICAgICAgICMgYnViYmxpbmcgdXAgdG8gQ0xJIGFuZCBiZWluZyB0cmVhdGVkIGFzIHVzZXIgQ3RybCtDCiAgICAgICAgICAgICAgICBmcm9tIGJvdHMudXRpbHMuaGVscGVycyBpbXBvcnQgX3Byb2Nlc3NfZXJyb3IKCiAgICAgICAgICAgICAgICB0b29sX2Vycm9yID0gVG9vbEV4ZWN1dGlvbkVycm9yKGYiVG9vbCBleGVjdXRpb24gaW50ZXJydXB0ZWQ6IHtzdHIoZSl9IikKICAgICAgICAgICAgICAgIHJldHVybiBfcHJvY2Vzc19lcnJvcih0b29sX2Vycm9yKQoKICAgICAgICAgICAgZXhjZXB0IFR5cGVFcnJvciBhcyBlOgogICAgICAgICAgICAgICAgIyBDaGVjayBpZiB0aGlzIGlzIGEgbWlzc2luZyByZXF1aXJlZCBhcmd1bWVudCBlcnJvcgogICAgICAgICAgICAgICAgZXJyb3JfbXNnID0gc3RyKGUpCiAgICAgICAgICAgICAgICBpZiAibWlzc2luZyIgaW4gZXJyb3JfbXNnIGFuZCAicmVxdWlyZWQiIGluIGVycm9yX21zZyBhbmQgImFyZ3VtZW50IiBpbiBlcnJvcl9tc2c6CiAgICAgICAgICAgICAgICAgICAgIyBBZGQgc3BlY2lhbCBtZXNzYWdlIGZvciBvdXRwdXQgdG9rZW4gbGltaXRhdGlvbgogICAgICAgICAgICAgICAgICAgIGVuaGFuY2VkX2Vycm9yID0gVHlwZUVycm9yKAogICAgICAgICAgICAgICAgICAgICAgICBmIntlcnJvcl9tc2d9XG5cbiIKICAgICAgICAgICAgICAgICAgICAgICAgZiLimqDvuI8gIFRoaXMgZXJyb3IgaXMgY29tbW9ubHkgY2F1c2VkIGJ5IGhpdHRpbmcgdGhlIG1heF90b2tlbnMgbGltaXQgYmVmb3JlIGNvbXBsZXRpbmcgdGhlIHRvb2wgY2FsbC5cbiIKICAgICAgICAgICAgICAgICAgICAgICAgZiJUaGUgcmVzcG9uc2Ugd2FzIHRydW5jYXRlZCBtaWQtcGFyYW1ldGVyLCBtYWtpbmcgaXQgYXBwZWFyIHRoYXQgcmVxdWlyZWQgcGFyYW1ldGVycyBhcmUgbWlzc2luZy5cbiIKICAgICAgICAgICAgICAgICAgICAgICAgZiJUbyBmaXggdGhpczogV29yayBpbiBTTUFMTEVSIENIVU5LUy4gRWRpdCBmZXdlciBsaW5lcyBhdCBhIHRpbWUsICIKICAgICAgICAgICAgICAgICAgICAgICAgZiJvciBicmVhayB5b3VyIHRhc2sgaW50byBtdWx0aXBsZSBzdGVwcy4iCiAgICAgICAgICAgICAgICAgICAgKQogICAgICAgICAgICAgICAgICAgIGZyb20gYm90cy51dGlscy5oZWxwZXJzIGltcG9ydCBfcHJvY2Vzc19lcnJvcgoKICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3Byb2Nlc3NfZXJyb3IoZW5oYW5jZWRfZXJyb3IpCiAgICAgICAgICAgICAgICBlbHNlOgogICAgICAgICAgICAgICAgICAgIGZyb20gYm90cy51dGlscy5oZWxwZXJzIGltcG9ydCBfcHJvY2Vzc19lcnJvcgoKICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3Byb2Nlc3NfZXJyb3IoZSkKICAgICAgICAgICAgZXhjZXB0IEV4Y2VwdGlvbiBhcyBlOgogICAgICAgICAgICAgICAgZnJvbSBib3RzLnV0aWxzLmhlbHBlcnMgaW1wb3J0IF9wcm9jZXNzX2Vycm9yCgogICAgICAgICAgICAgICAgcmV0dXJuIF9wcm9jZXNzX2Vycm9yKGUpCgogICAgICAgICMgVXBkYXRlIGRvY3N0cmluZyBpZiBkZXNjcmlwdGlvbiBwcm92aWRlZAogICAgICAgIGlmIGRlc2NyaXB0aW9uOgogICAgICAgICAgICB3cmFwcGVyLl9fZG9jX18gPSBkZXNjcmlwdGlvbgogICAgICAgIGVsaWYgbm90IHdyYXBwZXIuX19kb2NfXzoKICAgICAgICAgICAgIyBHZW5lcmF0ZSBtaW5pbWFsIGRvY3N0cmluZyBmcm9tIGZ1bmN0aW9uIG5hbWUKICAgICAgICAgICAgd3JhcHBlci5fX2RvY19fID0gZiJFeGVjdXRlIHtmdW5jLl9fbmFtZV9fLnJlcGxhY2UoJ18nLCAnICcpfSIKCiAgICAgICAgcmV0dXJuIHdyYXBwZXIKCiAgICByZXR1cm4gZGVjb3JhdG9yCgpAdG9vbGlmeSgpCmRlZiBsaXN0X2NvbnRleHQoKSAtPiBzdHI6CiAgICAiIiJMaXN0IGFsbCBib3QgbWVzc2FnZXMgaW4gdGhlIGNvbnZlcnNhdGlvbiB3aXRoIGxhYmVscyBmb3IgcmVtb3ZhbC4KCiAgICBVc2UgdGhpcyBiZWZvcmUgcmVtb3ZlX2NvbnRleHQgdG8gc2VlIHdoYXQgbWVzc2FnZXMgYXJlIGluIHlvdXIgY29udmVyc2F0aW9uLgogICAgU2hvd3MgYm90IG1lc3NhZ2VzIG9ubHkgKHNpbmNlIHJlbW92YWwgaGFwcGVucyBpbiB1c2VyLWJvdCBwYWlycykgd2l0aDoKICAgIC0gQSBsYWJlbCBbQV0sIFtCXSwgW0NdLCBldGMuIGZvciByZWZlcmVuY2UKICAgIC0gVHJ1bmNhdGVkIHRvb2wgY2FsbHMgKGlmIGFueSkgd2l0aCBwYXJhbWV0ZXJzCiAgICAtIFRydW5jYXRlZCByZXNwb25zZSB0ZXh0CgogICAgUmV0dXJuczoKICAgICAgICBzdHI6IEZvcm1hdHRlZCBsaXN0IG9mIGJvdCBtZXNzYWdlcyB3aXRoIGxhYmVscywgb3IgZXJyb3IgbWVzc2FnZQoKICAgIEV4YW1wbGUgb3V0cHV0OgogICAgICAgIFtBXSBCb3Q6IDx0b29sX25hbWUgcGFyYW09InZhbHVlLi4uIj4gfCAiUmVzcG9uc2UgdGV4dC4uLiIKICAgICAgICBbQl0gQm90OiAiUmVzcG9uc2UgdGV4dCB3aXRob3V0IHRvb2xzLi4uIgogICAgIiIiCiAgICBib3QgPSBfZ2V0X2NhbGxpbmdfYm90KCkKICAgIGlmIG5vdCBib3Q6CiAgICAgICAgcmV0dXJuICdFcnJvcjogQ291bGQgbm90IGZpbmQgY2FsbGluZyBib3QnCiAgICByb290ID0gYm90LmNvbnZlcnNhdGlvbi5fZmluZF9yb290KCkKICAgIGJvdF9ub2RlcyA9IFtdCgogICAgZGVmIGNvbGxlY3RfYm90X25vZGVzKG5vZGUpOgogICAgICAgICIiIlJlY3Vyc2l2ZWx5IGNvbGxlY3QgYWxsIGJvdCAoYXNzaXN0YW50KSBub2RlcyBpbiBvcmRlci4iIiIKICAgICAgICBpZiBoYXNhdHRyKG5vZGUsICdyb2xlJykgYW5kIG5vZGUucm9sZSA9PSAnYXNzaXN0YW50JzoKICAgICAgICAgICAgYm90X25vZGVzLmFwcGVuZChub2RlKQogICAgICAgIGZvciByZXBseSBpbiBub2RlLnJlcGxpZXM6CiAgICAgICAgICAgIGNvbGxlY3RfYm90X25vZGVzKHJlcGx5KQogICAgY29sbGVjdF9ib3Rfbm9kZXMocm9vdCkKICAgIGlmIG5vdCBib3Rfbm9kZXM6CiAgICAgICAgcmV0dXJuICdObyBib3QgbWVzc2FnZXMgZm91bmQgaW4gY29udmVyc2F0aW9uJwoKICAgIGRlZiBnZW5lcmF0ZV9sYWJlbChpbmRleCk6CiAgICAgICAgIiIiR2VuZXJhdGUgRXhjZWwtc3R5bGUgY29sdW1uIGxhYmVsczogQSwgQiwgLi4uLCBaLCBBQSwgQUIsIC4uLiIiIgogICAgICAgIGxhYmVsID0gJycKICAgICAgICBpbmRleCArPSAxCiAgICAgICAgd2hpbGUgaW5kZXggPiAwOgogICAgICAgICAgICBpbmRleCAtPSAxCiAgICAgICAgICAgIGxhYmVsID0gY2hyKDY1ICsgaW5kZXggJSAyNikgKyBsYWJlbAogICAgICAgICAgICBpbmRleCAvLz0gMjYKICAgICAgICByZXR1cm4gbGFiZWwKICAgIGxpbmVzID0gW10KICAgIGZvciBpLCBub2RlIGluIGVudW1lcmF0ZShib3Rfbm9kZXMpOgogICAgICAgIGxhYmVsID0gZ2VuZXJhdGVfbGFiZWwoaSkKICAgICAgICBwYXJ0cyA9IFtdCiAgICAgICAgaWYgaGFzYXR0cihub2RlLCAndG9vbF9jYWxscycpIGFuZCBub2RlLnRvb2xfY2FsbHM6CiAgICAgICAgICAgIHRvb2xfc3RycyA9IFtdCiAgICAgICAgICAgIGZvciB0b29sX2NhbGwgaW4gbm9kZS50b29sX2NhbGxzOgogICAgICAgICAgICAgICAgdG9vbF9uYW1lID0gdG9vbF9jYWxsLmdldCgnbmFtZScsICd1bmtub3duJykKICAgICAgICAgICAgICAgIHRvb2xfaW5wdXQgPSB0b29sX2NhbGwuZ2V0KCdpbnB1dCcsIHt9KQogICAgICAgICAgICAgICAgaWYgaXNpbnN0YW5jZSh0b29sX2lucHV0LCBkaWN0KToKICAgICAgICAgICAgICAgICAgICBwYXJhbV9wYXJ0cyA9IFtdCiAgICAgICAgICAgICAgICAgICAgZm9yIGtleSwgdmFsdWUgaW4gdG9vbF9pbnB1dC5pdGVtcygpOgogICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZV9zdHIgPSBzdHIodmFsdWUpCiAgICAgICAgICAgICAgICAgICAgICAgIGlmIGxlbih2YWx1ZV9zdHIpID4gMjA6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZV9zdHIgPSB2YWx1ZV9zdHJbOjIwXSArICcuLi4nCiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtX3BhcnRzLmFwcGVuZChmJ3trZXl9PXt2YWx1ZV9zdHJ9JykKICAgICAgICAgICAgICAgICAgICBwYXJhbXNfc3RyID0gJywgJy5qb2luKHBhcmFtX3BhcnRzKQogICAgICAgICAgICAgICAgZWxzZToKICAgICAgICAgICAgICAgICAgICBwYXJhbXNfc3RyID0gc3RyKHRvb2xfaW5wdXQpCiAgICAgICAgICAgICAgICAgICAgaWYgbGVuKHBhcmFtc19zdHIpID4gMjA6CiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtc19zdHIgPSBwYXJhbXNfc3RyWzoyMF0gKyAnLi4uJwogICAgICAgICAgICAgICAgdG9vbF9zdHJzLmFwcGVuZChmJzx7dG9vbF9uYW1lfSB7cGFyYW1zX3N0cn0+JykKICAgICAgICAgICAgcGFydHMuYXBwZW5kKCcgJy5qb2luKHRvb2xfc3RycykpCiAgICAgICAgaWYgaGFzYXR0cihub2RlLCAnY29udGVudCcpIGFuZCBub2RlLmNvbnRlbnQ6CiAgICAgICAgICAgIGNvbnRlbnQgPSBub2RlLmNvbnRlbnQucmVwbGFjZSgnXG4nLCAnICcpCiAgICAgICAgICAgIGlmIGxlbihjb250ZW50KSA+IDUwOgogICAgICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnRbOjUwXSArICcuLi4nCiAgICAgICAgICAgIHBhcnRzLmFwcGVuZChmJyJ7Y29udGVudH0iJykKICAgICAgICBpZiBwYXJ0czoKICAgICAgICAgICAgbWVzc2FnZV9zdHIgPSAnIHwgJy5qb2luKHBhcnRzKQogICAgICAgIGVsc2U6CiAgICAgICAgICAgIG1lc3NhZ2Vfc3RyID0gJzxlbXB0eSBtZXNzYWdlPicKICAgICAgICBsaW5lcy5hcHBlbmQoZidbe2xhYmVsfV0gQm90OiB7bWVzc2FnZV9zdHJ9JykKICAgIHJldHVybiAnXG4nLmpvaW4obGluZXMpCgpkZWYgX2dldF9jYWxsaW5nX2JvdCgpIC0+IE9wdGlvbmFsW0JvdF06CiAgICAiIiJIZWxwZXIgZnVuY3Rpb24gdG8gZ2V0IGEgcmVmZXJlbmNlIHRvIHRoZSBjYWxsaW5nIGJvdC4KICAgIFJldHVybnM6CiAgICAgICAgT3B0aW9uYWxbQm90XTogUmVmZXJlbmNlIHRvIHRoZSBjYWxsaW5nIGJvdCBvciBOb25lIGlmIG5vdCBmb3VuZAogICAgIiIiCiAgICBmcmFtZSA9IGluc3BlY3QuY3VycmVudGZyYW1lKCkKICAgIHdoaWxlIGZyYW1lOgogICAgICAgIGlmIGZyYW1lLmZfY29kZS5jb19uYW1lID09ICdfY3Zzbl9yZXNwb25kJyBhbmQgJ3NlbGYnIGluIGZyYW1lLmZfbG9jYWxzOgogICAgICAgICAgICBwb3RlbnRpYWxfYm90ID0gZnJhbWUuZl9sb2NhbHNbJ3NlbGYnXQogICAgICAgICAgICBpZiBpc2luc3RhbmNlKHBvdGVudGlhbF9ib3QsIEJvdCk6CiAgICAgICAgICAgICAgICByZXR1cm4gcG90ZW50aWFsX2JvdAogICAgICAgIGZyYW1lID0gZnJhbWUuZl9iYWNrCiAgICByZXR1cm4gTm9uZZSMCWZpbGVfcGF0aJSMI2R5bmFtaWNfbW9kdWxlXy0yOTA3MDc3ODU3Mjg0NDUzODE4lIwJbmFtZXNwYWNllGgAjA5faW1wb3J0X21vZHVsZZSTlIwuX19ydW50aW1lX18uZHluYW1pY19tb2R1bGVfLTQ5OTU4NzIyMDI4NzY0NjM5NJSFlFKUfZQoaCxoLWiYTowLX19wYWNrYWdlX1+UTowIX19zcGVjX1+UTowIX19maWxlX1+UaKpoD4wTYm90cy5kZXYuZGVjb3JhdG9yc5RoD5OUaBBotWgQk5RoE2i1aBOTlIwDYXN0lGitaLmFlFKUjAhkYXRldGltZZRorWi8hZRSlIwJZnVuY3Rvb2xzlGitaL+FlFKUjAdpbnNwZWN0lGitaMKFlFKUjAdsb2dnaW5nlGitaMWFlFKUjAJvc5RorWjIhZRSlIwDc3lzlGitjANzeXOUhZRSlIwIdGV4dHdyYXCUaK1oz4WUUpSMCXRyYWNlYmFja5RorWjShZRSlIwFd3JhcHOUaL9o1ZOUjANBbnmUjAZ0eXBpbmeUaNeTlIwIQ2FsbGFibGWUaNho2pOUjAhPcHRpb25hbJRo2Gjck5SMBFR5cGWUaNho3pOUjBJyZW1vdmVfY29kZV9ibG9ja3OUaBJo4JOUjAZsb2dnZXKUaMWMCWdldExvZ2dlcpSTlGi1hZRSlIwMTm9IVFRQRmlsdGVylGi1aOeTlIwHbGF6eV9mbpRotWjpk5SMCmxhenlfY2xhc3OUaLVo65OUjAxfZ2V0X2NvbnRleHSUaLVo7ZOUjBFfZ2V0X3B5X2ludGVyZmFjZZRotWjvk5SMBGxhenmUaLVo8ZOUjA5kZWJ1Z19vbl9lcnJvcpRotWjzk5SMCmxvZ19lcnJvcnOUaLVo9ZOUjAd0b29saWZ5lGgCKGgEKEMEBBYKNpRLAUsASwBLAksCSwNDEocAlwCIAGYBZAGECH0BfAFTAJRYiAIAAAogICAgQ29udmVydCBhbnkgZnVuY3Rpb24gaW50byBhIGJvdCB0b29sIHdpdGggc3RyaW5nLWluLCBzdHJpbmctb3V0IGludGVyZmFjZS4KCiAgICAtIENvbnZlcnRzIHN0cmluZyBpbnB1dHMgdG8gcHJvcGVyIHR5cGVzIHVzaW5nIHR5cGUgaGludHMKICAgIC0gRW5zdXJlcyBzdHJpbmcgb3V0cHV0IChKU09OIGZvciBjb21wbGV4IHR5cGVzKQogICAgLSBXcmFwcyBpbiBlcnJvciBoYW5kbGluZyAocmV0dXJucyBlcnJvciBzdHJpbmdzLCBuZXZlciByYWlzZXMpCiAgICAtIEVuaGFuY2VzIGRvY3N0cmluZyBpZiBkZXNjcmlwdGlvbiBwcm92aWRlZAoKICAgIEFyZ3M6CiAgICAgICAgZGVzY3JpcHRpb24gKHN0ciwgb3B0aW9uYWwpOiBPdmVycmlkZSB0aGUgZnVuY3Rpb24ncyBkb2NzdHJpbmcKCiAgICBFeGFtcGxlOgogICAgICAgIEB0b29saWZ5KCkKICAgICAgICBkZWYgYWRkX251bWJlcnMoeDogaW50LCB5OiBpbnQgPSAwKSAtPiBpbnQ6CiAgICAgICAgICAgIHJldHVybiB4ICsgeQoKICAgICAgICBAdG9vbGlmeSgiQ2FsY3Vs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",
      "name": "list_context",
      "hash": "0ad2362a54d265b8d646c7b8e4e760c66e6549aa00a8468511eca421c5d046e5",
      "provenance": {
       "module": "dynamic_module_-499587220287646394",
       "qualname": "list_context"
      }
     },
     "remove_context": {
      "__imported_callable__": true,
      "pickled": "gASVLAAAAAAAAACMFWJvdHMudG9vbHMuc2VsZl90b29sc5SMDnJlbW92ZV9jb250ZXh0lJOULg==",
      "name": "remove_context",
      "hash": "844c0a8c9292aa5651b8dbf5a4ed403cef362e98c3448da0d83540e8db749da8",
      "provenance": {
       "module": "bots.tools.self_tools",
       "qualname": "remove_context"
      }
     },
     "_process_string_array": {
      "__helper_func__": true,
      "pickled": "gASVMwAAAAAAAACMFWJvdHMudG9vbHMuc2VsZl90b29sc5SMFV9wcm9jZXNzX3N0cmluZ19hcnJheZSTlC4=",
      "name": "_process_string_array",
      "hash": "f3aebb07568e95aad0a7a83d3370d686fdc8246126c06a3a6383db492f8762ea",
      "provenance": {
       "module": "bots.tools.self_tools",
       "qualname": "_process_string_array"
      }
     },
     "_verbose_callback": {
      "__helper_func__": true,
      "pickled": "gASVLwAAAAAAAACMFWJvdHMudG9vbHMuc2VsZl90b29sc5SMEV92ZXJib3NlX2NhbGxiYWNrlJOULg==",
      "name": "_verbose_callback",
      "hash": "9c82e7d02bb30f7619e98eb4592178e595349398b083ec309b7df6faf745facb",
      "provenance": {
       "module": "bots.tools.self_tools",
       "qualname": "_verbose_callback"
      }
     },
     "_remove_dummy_from_tree": {
      "__helper_func__": true,
      "pickled": "gASVNQAAAAAAAACMFWJvdHMudG9vbHMuc2VsZl90b29sc5SMF19yZW1vdmVfZHVtbXlfZnJvbV90cmVllJOULg==",
      "name": "_remove_dummy_from_tree",
      "hash": "28ace6295e4d8788a37a54c2b3ad9dd47cd633b12018c5e828417877fdbcf222",
      "provenance": {
       "module": "bots.tools.self_tools",
       "qualname": "_remove_dummy_from_tree"
      }
     },
     "subagent": {
      "__imported_callable__": true,
      "pickled": "gASVJgAAAAAAAACMFWJvdHMudG9vbHMuc2VsZl90b29sc5SMCHN1YmFnZW50lJOULg==",
      "name": "subagent",
      "hash": "7906556f7bb3787822292780a7ca91117f5a21efc476be7449ee5bf3f1da82ca",
      "provenance": {
       "module": "bots.tools.self_tools",
       "qualname": "subagent"
      }
     }
    }
   },
   "dynamic_module_7773849607267627855": {
    "name": "dynamic_module_-5621591935247001235",
    "source": "from bots.utils.helpers import _process_error\n\ndef toolify(description: str = None):\n    \"\"\"\n    Convert any function into a bot tool with string-in, string-out interface.\n\n    - Converts string inputs to proper types using type hints\n    - Ensures string output (JSON for complex types)\n    - Wraps in error handling (returns error strings, never raises)\n    - Enhances docstring if description provided\n\n    Args:\n        description (str, optional): Override the function's docstring\n\n    Example:\n        @toolify()\n        def add_numbers(x: int, y: int = 0) -> int:\n            return x + y\n\n        @toolify(\"Calculate the area of a circle\")\n        def area(radius: float) -> float:\n            return 3.14159 * radius * radius\n    \"\"\"\n\n    def decorator(func):\n        @functools.wraps(func)\n        def wrapper(*args, **kwargs):\n            try:\n                # Convert string inputs to proper types using type hints\n                converted_args, converted_kwargs = _convert_tool_inputs(func, args, kwargs)\n\n                # Call original function\n                result = func(*converted_args, **converted_kwargs)\n\n                # Convert result to string\n                return _convert_tool_output(result)\n\n            except KeyboardInterrupt as e:\n                # Convert KeyboardInterrupt to ToolExecutionError to prevent it from\n                # bubbling up to CLI and being treated as user Ctrl+C\n\n                tool_error = ToolExecutionError(f\"Tool execution interrupted: {str(e)}\")\n                return _process_error(tool_error)\n\n            except TypeError as e:\n                # Check if this is a missing required argument error\n                error_msg = str(e)\n                if \"missing\" in error_msg and \"required\" in error_msg and \"argument\" in error_msg:\n                    # Add special message for output token limitation\n                    enhanced_error = TypeError(\n                        f\"{error_msg}\\n\\n\"\n                        f\"\u26a0\ufe0f  This error is commonly caused by hitting the max_tokens limit before completing the tool call.\\n\"\n                        f\"The response was truncated mid-parameter, making it appear that required parameters are missing.\\n\"\n                        f\"To fix this: Work in SMALLER CHUNKS. Edit fewer lines at a time, \"\n                        f\"or break your task into multiple steps.\"\n                    )\n\n                    return _process_error(enhanced_error)\n                else:\n\n                    return _process_error(e)\n            except Exception as e:\n\n                return _process_error(e)\n\n        # Update docstring if description provided\n        if description:\n            wrapper.__doc__ = description\n        elif not wrapper.__doc__:\n            # Generate minimal docstring from function name\n            wrapper.__doc__ = f\"Execute {func.__name__.replace('_', ' ')}\"\n\n        return wrapper\n\n    return decorator\n\n@toolify(\"Perform an agentic web search using Claude's internal web search capabilities\")\ndef web_search(question: str) -> str:\n    \"\"\"Perform an intelligent web search and return organized results.\n\n    This tool uses Claude's built-in web search functionality to perform searches\n    and returns organized, pertinent information extracted from the results.\n\n    Args:\n        question (str): The search goal framed as a question.\n        Good examples:\n            \"Who is Ben Rinauto?\"\n            \"What is the connection between Paris, France and Buffalo, NY?\"\n        Bad examples:\n            \"Ben R wrestling\"\n            \"paris buffalo\"\n\n    Returns:\n        str: Organized search results with key information extracted\n    \"\"\"\n    try:\n        _validate_question_format(question)\n        api_key = os.getenv('ANTHROPIC_API_KEY')\n        if not api_key:\n            return 'Error: ANTHROPIC_API_KEY environment variable not set'\n        client = anthropic.Anthropic(api_key=api_key)\n        tools = [{'type': 'web_search_20250305', 'name': 'web_search', 'max_uses': 10}]\n        search_prompt = f'I need you to search the web answers to this question: \"{question}\"\\n\\n        Please use the web search tool to find current, relevant information to precisely and\\n        accurately answer this question.'\n        response = client.messages.create(model='claude-opus-4-1', max_tokens=16384, temperature=0.3, tools=tools, messages=[{'role': 'user', 'content': search_prompt}])\n\n        def extract_clean_content(response):\n            \"\"\"Extract only the essential content from web search response.\"\"\"\n            result = []\n            result.append('=== WEB SEARCH RESULTS ===\\n')\n            result.append(f'Search: \"{question}\"\\n')\n            if hasattr(response, 'content') and response.content:\n                text_responses = []\n                search_results = []\n                for block in response.content:\n                    if hasattr(block, 'type') and block.type == 'text' and hasattr(block, 'text') and block.text:\n                        text_responses.append(block.text)\n                    elif hasattr(block, 'type') and block.type == 'web_search_tool_result':\n                        if hasattr(block, 'content') and block.content:\n                            for item in block.content:\n                                if isinstance(item, dict) and item.get('type') == 'web_search_result':\n                                    search_results.append({'title': item.get('title', 'No title'), 'url': item.get('url', 'No URL'), 'age': item.get('page_age', 'Unknown age')})\n                if text_responses:\n                    result.append(\"=== CLAUDE'S ANALYSIS ===\\n\")\n                    for i, text in enumerate(text_responses, 1):\n                        result.append(f'{i}. {text}\\n')\n                    result.append('')\n                if search_results:\n                    result.append('=== SOURCES FOUND ===\\n')\n                    for i, item in enumerate(search_results, 1):\n                        result.append(f\"{i}. {item['title']}\")\n                        result.append(f\"   {item['url']}\")\n                        if item['age'] and item['age'] != 'Unknown age':\n                            result.append(f\"   ({item['age']})\")\n                        result.append('')\n                result.append(f\"Search performed: {datetime.datetime.now().strftime('%Y-%m-%d %H:%M UTC')}\")\n            return '\\n'.join(result)\n        clean_content = extract_clean_content(response)\n        return clean_content\n    except Exception as e:\n        return f'Web search failed: {str(e)}'\n\ndef _validate_question_format(query: str) -> bool:\n    \"\"\"Use a simple Haiku bot to validate if input is formatted as a question.\n\n    Args:\n        query (str): The input query to validate\n\n    Returns:\n        bool: True if formatted as a question, False otherwise\n\n    Raises:\n        ValueError: If query is not formatted as a question\n    \"\"\"\n    try:\n        api_key = os.getenv('ANTHROPIC_API_KEY')\n        if not api_key:\n            return True\n        client = anthropic.Anthropic(api_key=api_key)\n        validation_prompt = f'Is this text formatted as a question? Answer only Y or N.\\n\\nText: \"{query}\"\\n\\nAnswer:'\n        response = client.messages.create(model='claude-3-haiku-20240307', max_tokens=10, temperature=0.0, messages=[{'role': 'user', 'content': validation_prompt}])\n        answer = response.content[0].text.strip().upper()\n        if answer.startswith('N'):\n            raise ValueError(\"Input queries must be formatted as questions. Good examples: 'Who is...?', 'What is...?', 'How does...?' Bad examples: 'Ben R wrestling', 'paris buffalo'The more information, and the more specific, the better. You are asking an AI to answer a question, not performing a traditional web keyword search.\")\n        return True\n    except ValueError:\n        raise\n    except Exception:\n        return True",
    "file_path": "dynamic_module_7773849607267627855",
    "code_hash": "e934b67b958e266c3f865b32cf38b49c",
    "globals": {
     "_convert_tool_inputs": {
      "__helper_func__": true,
      "pickled": "gASVMAAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjBRfY29udmVydF90b29sX2lucHV0c5STlC4=",
      "name": "_convert_tool_inputs",
      "hash": "8bc4aba1c7d69350a812d8553b6a7ff0cd23ae5c818f3b9533752a69e91acf2e",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "_convert_tool_inputs"
      }
     },
     "_convert_tool_output": {
      "__helper_func__": true,
      "pickled": "gASVMAAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjBRfY29udmVydF90b29sX291dHB1dJSTlC4=",
      "name": "_convert_tool_output",
      "hash": "6c85767d30db1c50646d25d2b954c893aed15774f97345f9b8c99674c59cf928",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "_convert_tool_output"
      }
     },
     "ToolExecutionError": {
      "__imported_callable__": true,
      "pickled": "gASVLgAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjBJUb29sRXhlY3V0aW9uRXJyb3KUk5Qu",
      "name": "ToolExecutionError",
      "hash": "e3f136f46cc3014d1b1a8ac6716adb9da7db1dd83f2ed8529e090d97ae0db998",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "ToolExecutionError"
      }
     },
     "ast": {
      "__module_type__": true,
      "name": "ast",
      "spec": "ast"
     },
     "datetime": {
      "__module_type__": true,
      "name": "datetime",
      "spec": "datetime"
     },
     "functools": {
      "__module_type__": true,
      "name": "functools",
      "spec": "functools"
     },
     "inspect": {
      "__module_type__": true,
      "name": "inspect",
      "spec": "inspect"
     },
     "logging": {
      "__module_type__": true,
      "name": "logging",
      "spec": "logging"
     },
     "os": {
      "__module_type__": true,
      "name": "os",
      "spec": "os"
     },
     "sys": {
      "__module_type__": true,
      "name": "sys",
      "spec": "sys"
     },
     "textwrap": {
      "__module_type__": true,
      "name": "textwrap",
      "spec": "textwrap"
     },
     "traceback": {
      "__module_type__": true,
      "name": "traceback",
      "spec": "traceback"
     },
     "wraps": {
      "__imported_callable__": true,
      "pickled": "gASVFwAAAAAAAACMCWZ1bmN0b29sc5SMBXdyYXBzlJOULg==",
      "name": "wraps",
      "hash": "4c7c8f91a978a903bce2515f7fe83cb09b7074259dabad02b312209312f718ed",
      "provenance": {
       "module": "functools",
       "qualname": "wraps"
      }
     },
     "Any": {
      "__imported_callable__": true,
      "pickled": "gASVEgAAAAAAAACMBnR5cGluZ5SMA0FueZSTlC4=",
      "name": "Any",
      "hash": "fbf19bc6bf716a555ce7094664e2bc898734e4acfc2cd6d9ee399edef2e5c02b",
      "provenance": {
       "module": "typing",
       "qualname": "Any"
      }
     },
     "Callable": {
      "__imported_callable__": true,
      "pickled": "gASVFwAAAAAAAACMBnR5cGluZ5SMCENhbGxhYmxllJOULg==",
      "name": "Callable",
      "hash": "17cf7f09b805961290dccb95aa11199df32c246cb879f355ffa1a31d6285edad",
      "provenance": {
       "module": "typing",
       "qualname": "Callable"
      }
     },
     "Optional": {
      "__imported_callable__": true,
      "pickled": "gASVFwAAAAAAAACMBnR5cGluZ5SMCE9wdGlvbmFslJOULg==",
      "name": "Optional",
      "hash": "d69b63c158dd563d1537447d9d3a68afdda0efb70794ab11c234d01e2e593e56",
      "provenance": {
       "module": "typing",
       "qualname": "Optional"
      }
     },
     "Type": {
      "__imported_callable__": true,
      "pickled": "gASVEwAAAAAAAACMBnR5cGluZ5SMBFR5cGWUk5Qu",
      "name": "Type",
      "hash": "9e98fdb991d3addb0aad6e13cd94b21998f5d97e9f30b15f9c697afe5cde1832",
      "provenance": {
       "module": "typing",
       "qualname": "Type"
      }
     },
     "remove_code_blocks": {
      "__imported_callable__": true,
      "pickled": "gASVLQAAAAAAAACMEmJvdHMudXRpbHMuaGVscGVyc5SMEnJlbW92ZV9jb2RlX2Jsb2Nrc5STlC4=",
      "name": "remove_code_blocks",
      "hash": "44524fda389310a2a28f80da99409efd110baefaa9ea50345d092a634c89fc1d",
      "provenance": {
       "module": "bots.utils.helpers",
       "qualname": "remove_code_blocks"
      }
     },
     "NoHTTPFilter": {
      "__imported_callable__": true,
      "pickled": "gASVKAAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjAxOb0hUVFBGaWx0ZXKUk5Qu",
      "name": "NoHTTPFilter",
      "hash": "9f920bc687c51afef3dea517f9b64393473ed37dac3fda0cedd01a655b483a52",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "NoHTTPFilter"
      }
     },
     "lazy_fn": {
      "__imported_callable__": true,
      "pickled": "gASVIwAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjAdsYXp5X2ZulJOULg==",
      "name": "lazy_fn",
      "hash": "a1737e2cf8adde594f0dd0b3f17ffaad4c126dcf16906e82cb07f18c13d8b7a2",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "lazy_fn"
      }
     },
     "lazy_class": {
      "__imported_callable__": true,
      "pickled": "gASVJgAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjApsYXp5X2NsYXNzlJOULg==",
      "name": "lazy_class",
      "hash": "d1883fc4e7eb2d64f47b4e90b4b6b69d0c5be0d0e3175787058ad631d122e4c6",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "lazy_class"
      }
     },
     "_get_context": {
      "__helper_func__": true,
      "pickled": "gASVKAAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjAxfZ2V0X2NvbnRleHSUk5Qu",
      "name": "_get_context",
      "hash": "979ef249cdc1f76f4020d948ffc352f7c667afb0d89f221770156eebd7717c7a",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "_get_context"
      }
     },
     "_get_py_interface": {
      "__helper_func__": true,
      "pickled": "gASVLQAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjBFfZ2V0X3B5X2ludGVyZmFjZZSTlC4=",
      "name": "_get_py_interface",
      "hash": "d45b0506fb8815e8d9c3a9217b0ca101dac4fb9f51c8546285cf68a95ab027e7",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "_get_py_interface"
      }
     },
     "lazy": {
      "__imported_callable__": true,
      "pickled": "gASVIAAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjARsYXp5lJOULg==",
      "name": "lazy",
      "hash": "6e25446d8765ac65a5518c01582ddf52784eb90c51d57e224c94823d5b7c55cd",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "lazy"
      }
     },
     "debug_on_error": {
      "__imported_callable__": true,
      "pickled": "gASVKgAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjA5kZWJ1Z19vbl9lcnJvcpSTlC4=",
      "name": "debug_on_error",
      "hash": "06d89d594519c41c1dae666437441d4fd4aeeea959f1c905694940a50ae4ddfe",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "debug_on_error"
      }
     },
     "log_errors": {
      "__imported_callable__": true,
      "pickled": "gASVJgAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjApsb2dfZXJyb3JzlJOULg==",
      "name": "log_errors",
      "hash": "f9446c0ae11aa5bb7726b83da744e8dc707a91edc91085abbca1cefd1897d829",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "log_errors"
      }
     },
     "toolify": {
      "__imported_callable__": true,
      "pickled": "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ICAgcmV0dXJuIDMuMTQxNTkgKiByYWRpdXMgKiByYWRpdXMKICAgICIiIgoKICAgIGRlZiBkZWNvcmF0b3IoZnVuYyk6CiAgICAgICAgQGZ1bmN0b29scy53cmFwcyhmdW5jKQogICAgICAgIGRlZiB3cmFwcGVyKCphcmdzLCAqKmt3YXJncyk6CiAgICAgICAgICAgIHRyeToKICAgICAgICAgICAgICAgICMgQ29udmVydCBzdHJpbmcgaW5wdXRzIHRvIHByb3BlciB0eXBlcyB1c2luZyB0eXBlIGhpbnRzCiAgICAgICAgICAgICAgICBjb252ZXJ0ZWRfYXJncywgY29udmVydGVkX2t3YXJncyA9IF9jb252ZXJ0X3Rvb2xfaW5wdXRzKGZ1bmMsIGFyZ3MsIGt3YXJncykKCiAgICAgICAgICAgICAgICAjIENhbGwgb3JpZ2luYWwgZnVuY3Rpb24KICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmMoKmNvbnZlcnRlZF9hcmdzLCAqKmNvbnZlcnRlZF9rd2FyZ3MpCgogICAgICAgICAgICAgICAgIyBDb252ZXJ0IHJlc3VsdCB0byBzdHJpbmcKICAgICAgICAgICAgICAgIHJldHVybiBfY29udmVydF90b29sX291dHB1dChyZXN1bHQpCgogICAgICAgICAgICBleGNlcHQgS2V5Ym9hcmRJbnRlcnJ1cHQgYXMgZToKICAgICAgICAgICAgICAgICMgQ29udmVydCBLZXlib2FyZEludGVycnVwdCB0byBUb29sRXhlY3V0aW9uRXJyb3IgdG8gcHJldmVudCBpdCBmcm9tCiAgICAgICAgICAgICAgICAjIGJ1YmJsaW5nIHVwIHRvIENMSSBhbmQgYmVpbmcgdHJlYXRlZCBhcyB1c2VyIEN0cmwrQwogICAgICAgICAgICAgICAgZnJvbSBib3RzLnV0aWxzLmhlbHBlcnMgaW1wb3J0IF9wcm9jZXNzX2Vycm9yCgogICAgICAgICAgICAgICAgdG9vbF9lcnJvciA9IFRvb2xFeGVjdXRpb25FcnJvcihmIlRvb2wgZXhlY3V0aW9uIGludGVycnVwdGVkOiB7c3RyKGUpfSIpCiAgICAgICAgICAgICAgICByZXR1cm4gX3Byb2Nlc3NfZXJyb3IodG9vbF9lcnJvcikKCiAgICAgICAgICAgIGV4Y2VwdCBUeXBlRXJyb3IgYXMgZToKICAgICAgICAgICAgICAgICMgQ2hlY2sgaWYgdGhpcyBpcyBhIG1pc3NpbmcgcmVxdWlyZWQgYXJndW1lbnQgZXJyb3IKICAgICAgICAgICAgICAgIGVycm9yX21zZyA9IHN0cihlKQogICAgICAgICAgICAgICAgaWYgIm1pc3NpbmciIGluIGVycm9yX21zZyBhbmQgInJlcXVpcmVkIiBpbiBlcnJvcl9tc2cgYW5kICJhcmd1bWVudCIgaW4gZXJyb3JfbXNnOgogICAgICAgICAgICAgICAgICAgICMgQWRkIHNwZWNpYWwgbWVzc2FnZSBmb3Igb3V0cHV0IHRva2VuIGxpbWl0YXRpb24KICAgICAgICAgICAgICAgICAgICBlbmhhbmNlZF9lcnJvciA9IFR5cGVFcnJvcigKICAgICAgICAgICAgICAgICAgICAgICAgZiJ7ZXJyb3JfbXNnfVxuXG4iCiAgICAgICAgICAgICAgICAgICAgICAgIGYi4pqg77iPICBUaGlzIGVycm9yIGlzIGNvbW1vbmx5IGNhdXNlZCBieSBoaXR0aW5nIHRoZSBtYXhfdG9rZW5zIGxpbWl0IGJlZm9yZSBjb21wbGV0aW5nIHRoZSB0b29sIGNhbGwuXG4iCiAgICAgICAgICAgICAgICAgICAgICAgIGYiVGhlIHJlc3BvbnNlIHdhcyB0cnVuY2F0ZWQgbWlkLXBhcmFtZXRlciwgbWFraW5nIGl0IGFwcGVhciB0aGF0IHJlcXVpcmVkIHBhcmFtZXRlcnMgYXJlIG1pc3NpbmcuXG4iCiAgICAgICAgICAgICAgICAgICAgICAgIGYiVG8gZml4IHRoaXM6IFdvcmsgaW4gU01BTExFUiBDSFVOS1MuIEVkaXQgZmV3ZXIgbGluZXMgYXQgYSB0aW1lLCAiCiAgICAgICAgICAgICAgICAgICAgICAgIGYib3IgYnJlYWsgeW91ciB0YXNrIGludG8gbXVsdGlwbGUgc3RlcHMuIgogICAgICAgICAgICAgICAgICAgICkKICAgICAgICAgICAgICAgICAgICBmcm9tIGJvdHMudXRpbHMuaGVscGVycyBpbXBvcnQgX3Byb2Nlc3NfZXJyb3IKCiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9wcm9jZXNzX2Vycm9yKGVuaGFuY2VkX2Vycm9yKQogICAgICAgICAgICAgICAgZWxzZToKICAgICAgICAgICAgICAgICAgICBmcm9tIGJvdHMudXRpbHMuaGVscGVycyBpbXBvcnQgX3Byb2Nlc3NfZXJyb3IKCiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9wcm9jZXNzX2Vycm9yKGUpCiAgICAgICAgICAgIGV4Y2VwdCBFeGNlcHRpb24gYXMgZToKICAgICAgICAgICAgICAgIGZyb20gYm90cy51dGlscy5oZWxwZXJzIGltcG9ydCBfcHJvY2Vzc19lcnJvcgoKICAgICAgICAgICAgICAgIHJldHVybiBfcHJvY2Vzc19lcnJvcihlKQoKICAgICAgICAjIFVwZGF0ZSBkb2NzdHJpbmcgaWYgZGVzY3JpcHRpb24gcHJvdmlkZWQKICAgICAgICBpZiBkZXNjcmlwdGlvbjoKICAgICAgICAgICAgd3JhcHBlci5fX2RvY19fID0gZGVzY3JpcHRpb24KICAgICAgICBlbGlmIG5vdCB3cmFwcGVyLl9fZG9jX186CiAgICAgICAgICAgICMgR2VuZXJhdGUgbWluaW1hbCBkb2NzdHJpbmcgZnJvbSBmdW5jdGlvbiBuYW1lCiAgICAgICAgICAgIHdyYXBwZXIuX19kb2NfXyA9IGYiRXhlY3V0ZSB7ZnVuYy5fX25hbWVfXy5yZXBsYWNlKCdfJywgJyAnKX0iCgogICAgICAgIHJldHVybiB3cmFwcGVyCgogICAgcmV0dXJuIGRlY29yYXRvcgoKQHRvb2xpZnkoIlBlcmZvcm0gYW4gYWdlbnRpYyB3ZWIgc2VhcmNoIHVzaW5nIENsYXVkZSdzIGludGVybmFsIHdlYiBzZWFyY2ggY2FwYWJpbGl0aWVzIikKZGVmIHdlYl9zZWFyY2gocXVlc3Rpb246IHN0cikgLT4gc3RyOgogICAgIiIiUGVyZm9ybSBhbiBpbnRlbGxpZ2VudCB3ZWIgc2VhcmNoIGFuZCByZXR1cm4gb3JnYW5pemVkIHJlc3VsdHMuCgogICAgVGhpcyB0b29sIHVzZXMgQ2xhdWRlJ3MgYnVpbHQtaW4gd2ViIHNlYXJjaCBmdW5jdGlvbmFsaXR5IHRvIHBlcmZvcm0gc2VhcmNoZXMKICAgIGFuZCByZXR1cm5zIG9yZ2FuaXplZCwgcGVydGluZW50IGluZm9ybWF0aW9uIGV4dHJhY3RlZCBmcm9tIHRoZSByZXN1bHRzLgoKICAgIEFyZ3M6CiAgICAgICAgcXVlc3Rpb24gKHN0cik6IFRoZSBzZWFyY2ggZ29hbCBmcmFtZWQgYXMgYSBxdWVzdGlvbi4KICAgICAgICBHb29kIGV4YW1wbGVzOgogICAgICAgICAgICAiV2hvIGlzIEJlbiBSaW5hdXRvPyIKICAgICAgICAgICAgIldoYXQgaXMgdGhlIGNvbm5lY3Rpb24gYmV0d2VlbiBQYXJpcywgRnJhbmNlIGFuZCBCdWZmYWxvLCBOWT8iCiAgICAgICAgQmFkIGV4YW1wbGVzOgogICAgICAgICAgICAiQmVuIFIgd3Jlc3RsaW5nIgogICAgICAgICAgICAicGFyaXMgYnVmZmFsbyIKCiAgICBSZXR1cm5zOgogICAgICAgIHN0cjogT3JnYW5pemVkIHNlYXJjaCByZXN1bHRzIHdpdGgga2V5IGluZm9ybWF0aW9uIGV4dHJhY3RlZAogICAgIiIiCiAgICB0cnk6CiAgICAgICAgX3ZhbGlkYXRlX3F1ZXN0aW9uX2Zvcm1hdChxdWVzdGlvbikKICAgICAgICBhcGlfa2V5ID0gb3MuZ2V0ZW52KCdBTlRIUk9QSUNfQVBJX0tFWScpCiAgICAgICAgaWYgbm90IGFwaV9rZXk6CiAgICAgICAgICAgIHJldHVybiAnRXJyb3I6IEFOVEhST1BJQ19BUElfS0VZIGVudmlyb25tZW50IHZhcmlhYmxlIG5vdCBzZXQnCiAgICAgICAgY2xpZW50ID0gYW50aHJvcGljLkFudGhyb3BpYyhhcGlfa2V5PWFwaV9rZXkpCiAgICAgICAgdG9vbHMgPSBbeyd0eXBlJzogJ3dlYl9zZWFyY2hfMjAyNTAzMDUnLCAnbmFtZSc6ICd3ZWJfc2VhcmNoJywgJ21heF91c2VzJzogMTB9XQogICAgICAgIHNlYXJjaF9wcm9tcHQgPSBmJ0kgbmVlZCB5b3UgdG8gc2VhcmNoIHRoZSB3ZWIgYW5zd2VycyB0byB0aGlzIHF1ZXN0aW9uOiAie3F1ZXN0aW9ufSJcblxuICAgICAgICBQbGVhc2UgdXNlIHRoZSB3ZWIgc2VhcmNoIHRvb2wgdG8gZmluZCBjdXJyZW50LCByZWxldmFudCBpbmZvcm1hdGlvbiB0byBwcmVjaXNlbHkgYW5kXG4gICAgICAgIGFjY3VyYXRlbHkgYW5zd2VyIHRoaXMgcXVlc3Rpb24uJwogICAgICAgIHJlc3BvbnNlID0gY2xpZW50Lm1lc3NhZ2VzLmNyZWF0ZShtb2RlbD0nY2xhdWRlLW9wdXMtNC0xJywgbWF4X3Rva2Vucz0xNjM4NCwgdGVtcGVyYXR1cmU9MC4zLCB0b29scz10b29scywgbWVzc2FnZXM9W3sncm9sZSc6ICd1c2VyJywgJ2NvbnRlbnQnOiBzZWFyY2hfcHJvbXB0fV0pCgogICAgICAgIGRlZiBleHRyYWN0X2NsZWFuX2NvbnRlbnQocmVzcG9uc2UpOgogICAgICAgICAgICAiIiJFeHRyYWN0IG9ubHkgdGhlIGVzc2VudGlhbCBjb250ZW50IGZyb20gd2ViIHNlYXJjaCByZXNwb25zZS4iIiIKICAgICAgICAgICAgcmVzdWx0ID0gW10KICAgICAgICAgICAgcmVzdWx0LmFwcGVuZCgnPT09IFdFQiBTRUFSQ0ggUkVTVUxUUyA9PT1cbicpCiAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoZidTZWFyY2g6ICJ7cXVlc3Rpb259IlxuJykKICAgICAgICAgICAgaWYgaGFzYXR0cihyZXNwb25zZSwgJ2NvbnRlbnQnKSBhbmQgcmVzcG9uc2UuY29udGVudDoKICAgICAgICAgICAgICAgIHRleHRfcmVzcG9uc2VzID0gW10KICAgICAgICAgICAgICAgIHNlYXJjaF9yZXN1bHRzID0gW10KICAgICAgICAgICAgICAgIGZvciBibG9jayBpbiByZXNwb25zZS5jb250ZW50OgogICAgICAgICAgICAgICAgICAgIGlmIGhhc2F0dHIoYmxvY2ssICd0eXBlJykgYW5kIGJsb2NrLnR5cGUgPT0gJ3RleHQnIGFuZCBoYXNhdHRyKGJsb2NrLCAndGV4dCcpIGFuZCBibG9jay50ZXh0OgogICAgICAgICAgICAgICAgICAgICAgICB0ZXh0X3Jlc3BvbnNlcy5hcHBlbmQoYmxvY2sudGV4dCkKICAgICAgICAgICAgICAgICAgICBlbGlmIGhhc2F0dHIoYmxvY2ssICd0eXBlJykgYW5kIGJsb2NrLnR5cGUgPT0gJ3dlYl9zZWFyY2hfdG9vbF9yZXN1bHQnOgogICAgICAgICAgICAgICAgICAgICAgICBpZiBoYXNhdHRyKGJsb2NrLCAnY29udGVudCcpIGFuZCBibG9jay5jb250ZW50OgogICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIGl0ZW0gaW4gYmxvY2suY29udGVudDoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiBpc2luc3RhbmNlKGl0ZW0sIGRpY3QpIGFuZCBpdGVtLmdldCgndHlwZScpID09ICd3ZWJfc2VhcmNoX3Jlc3VsdCc6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlYXJjaF9yZXN1bHRzLmFwcGVuZCh7J3RpdGxlJzogaXRlbS5nZXQoJ3RpdGxlJywgJ05vIHRpdGxlJyksICd1cmwnOiBpdGVtLmdldCgndXJsJywgJ05vIFVSTCcpLCAnYWdlJzogaXRlbS5nZXQoJ3BhZ2VfYWdlJywgJ1Vua25vd24gYWdlJyl9KQogICAgICAgICAgICAgICAgaWYgdGV4dF9yZXNwb25zZXM6CiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZCgiPT09IENMQVVERSdTIEFOQUxZU0lTID09PVxuIikKICAgICAgICAgICAgICAgICAgICBmb3IgaSwgdGV4dCBpbiBlbnVtZXJhdGUodGV4dF9yZXNwb25zZXMsIDEpOgogICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKGYne2l9LiB7dGV4dH1cbicpCiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZCgnJykKICAgICAgICAgICAgICAgIGlmIHNlYXJjaF9yZXN1bHRzOgogICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoJz09PSBTT1VSQ0VTIEZPVU5EID09PVxuJykKICAgICAgICAgICAgICAgICAgICBmb3IgaSwgaXRlbSBpbiBlbnVtZXJhdGUoc2VhcmNoX3Jlc3VsdHMsIDEpOgogICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKGYie2l9LiB7aXRlbVsndGl0bGUnXX0iKQogICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKGYiICAge2l0ZW1bJ3VybCddfSIpCiAgICAgICAgICAgICAgICAgICAgICAgIGlmIGl0ZW1bJ2FnZSddIGFuZCBpdGVtWydhZ2UnXSAhPSAnVW5rbm93biBhZ2UnOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZChmIiAgICh7aXRlbVsnYWdlJ119KSIpCiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoJycpCiAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKGYiU2VhcmNoIHBlcmZvcm1lZDoge2RhdGV0aW1lLmRhdGV0aW1lLm5vdygpLnN0cmZ0aW1lKCclWS0lbS0lZCAlSDolTSBVVEMnKX0iKQogICAgICAgICAgICByZXR1cm4gJ1xuJy5qb2luKHJlc3VsdCkKICAgICAgICBjbGVhbl9jb250ZW50ID0gZXh0cmFjdF9jbGVhbl9jb250ZW50KHJlc3BvbnNlKQogICAgICAgIHJldHVybiBjbGVhbl9jb250ZW50CiAgICBleGNlcHQgRXhjZXB0aW9uIGFzIGU6CiAgICAgICAgcmV0dXJuIGYnV2ViIHNlYXJjaCBmYWlsZWQ6IHtzdHIoZSl9JwoKZGVmIF92YWxpZGF0ZV9xdWVzdGlvbl9mb3JtYXQocXVlcnk6IHN0cikgLT4gYm9vbDoKICAgICIiIlVzZSBhIHNpbXBsZSBIYWlrdSBib3QgdG8gdmFsaWRhdGUgaWYgaW5wdXQgaXMgZm9ybWF0dGVkIGFzIGEgcXVlc3Rpb24uCgogICAgQXJnczoKICAgICAgICBxdWVyeSAoc3RyKTogVGhlIGlucHV0IHF1ZXJ5IHRvIHZhbGlkYXRlCgogICAgUmV0dXJuczoKICAgICAgICBib29sOiBUcnVlIGlmIGZvcm1hdHRlZCBhcyBhIHF1ZXN0aW9uLCBGYWxzZSBvdGhlcndpc2UKCiAgICBSYWlzZXM6CiAgICAgICAgVmFsdWVFcnJvcjogSWYgcXVlcnkgaXMgbm90IGZvcm1hdHRlZCBhcyBhIHF1ZXN0aW9uCiAgICAiIiIKICAgIHRyeToKICAgICAgICBhcGlfa2V5ID0gb3MuZ2V0ZW52KCdBTlRIUk9QSUNfQVBJX0tFWScpCiAgICAgICAgaWYgbm90IGFwaV9rZXk6CiAgICAgICAgICAgIHJldHVybiBUcnVlCiAgICAgICAgY2xpZW50ID0gYW50aHJvcGljLkFudGhyb3BpYyhhcGlfa2V5PWFwaV9rZXkpCiAgICAgICAgdmFsaWRhdGlvbl9wcm9tcHQgPSBmJ0lzIHRoaXMgdGV4dCBmb3JtYXR0ZWQgYXMgYSBxdWVzdGlvbj8gQW5zd2VyIG9ubHkgWSBvciBOLlxuXG5UZXh0OiAie3F1ZXJ5fSJcblxuQW5zd2VyOicKICAgICAgICByZXNwb25zZSA9IGNsaWVudC5tZXNzYWdlcy5jcmVhdGUobW9kZWw9J2NsYXVkZS0zLWhhaWt1LTIwMjQwMzA3JywgbWF4X3Rva2Vucz0xMCwgdGVtcGVyYXR1cmU9MC4wLCBtZXNzYWdlcz1beydyb2xlJzogJ3VzZXInLCAnY29udGVudCc6IHZhbGlkYXRpb25fcHJvbXB0fV0pCiAgICAgICAgYW5zd2VyID0gcmVzcG9uc2UuY29udGVudFswXS50ZXh0LnN0cmlwKCkudXBwZXIoKQogICAgICAgIGlmIGFuc3dlci5zdGFydHN3aXRoKCdOJyk6CiAgICAgICAgICAgIHJhaXNlIFZhbHVlRXJyb3IoIklucHV0IHF1ZXJpZXMgbXVzdCBiZSBmb3JtYXR0ZWQgYXMgcXVlc3Rpb25zLiBHb29kIGV4YW1wbGVzOiAnV2hvIGlzLi4uPycsICdXaGF0IGlzLi4uPycsICdIb3cgZG9lcy4uLj8nIEJhZCBleGFtcGxlczogJ0JlbiBSIHdyZXN0bGluZycsICdwYXJpcyBidWZmYWxvJ1RoZSBtb3JlIGluZm9ybWF0aW9uLCBhbmQgdGhlIG1vcmUgc3BlY2lmaWMsIHRoZSBiZXR0ZXIuIFlvdSBhcmUgYXNraW5nIGFuIEFJIHRvIGFuc3dlciBhIHF1ZXN0aW9uLCBub3QgcGVyZm9ybWluZyBhIHRyYWRpdGlvbmFsIHdlYiBrZXl3b3JkIHNlYXJjaC4iKQogICAgICAgIHJldHVybiBUcnVlCiAgICBleGNlcHQgVmFsdWVFcnJvcjoKICAgICAgICByYWlzZQogICAgZXhjZXB0IEV4Y2VwdGlvbjoKICAgICAgICByZXR1cm4gVHJ1ZZSMCWZpbGVfcGF0aJRoXYwJbmFtZXNwYWNllGhkjC9fX3J1bnRpbWVfXy5keW5hbWljX21vZHVsZV8tNTYyMTU5MTkzNTI0NzAwMTIzNZSFlFKUfZQoaDdoTGg2TmhZTmhbTmhcaF1oFGhfaBVoYGgYaGFoYmhmaGdoaWg0aGtobGhuaG9ocWhyaHRodWh4aHloe2h8aH5oNWh/aIBogmiDaIRohWiGaIdoiGiJaIpoi2iPaJBokWiSaJNolGiVaJZol2iYaJlommibaJxonWieaJ9oRmhPaKBooWiiaKNopGimaKdo0mjbaON1YowJY29kZV9oYXNolIwgOTQ5N2EwZDllODgwNzlhYjE1OTRmYTY3OTBiMTYyMGaUdWJ1fZQoaDaMTVBlcmZvcm0gYW4gYWdlbnRpYyB3ZWIgc2VhcmNoIHVzaW5nIENsYXVkZSdzIGludGVybmFsIHdlYiBzZWFyY2ggY2FwYWJpbGl0aWVzlGhSajYBAAB1hpRiajEBAAAoaDdoTGg2TmhZTmhaTmhbTmhcaF1oFGhfaBVoYGgYaGFoYmhmaGdoaWg0aGtobGhuaG9ocWhyaHRodWh4aHloe2h8aH5oNWh/aIBogmiDaIRohWiGaIdoiGiJaIpoi2iPaJBokWiSaJNolGiVaJZol2iYaJlommibaJxonWieaJ9oRmhPaKBooWiiaKNopGimaKdo0mjbaOOMDF9fYnVpbHRpbnNfX5RjYnVpbHRpbnMKX19kaWN0X18KdTCMCGJ1aWx0aW5zlIwHZ2V0YXR0cpSTlIwEZGlsbJSMBV9kaWxslJOUjAhfc2V0YXR0cpRqTAEAAIwHc2V0YXR0cpSTlIeUUpRo4IwNY2VsbF9jb250ZW50c5RqMwEAAIeUUjBo3ChoN2hMaDZOaFlOaFpOaFtOaFxoXWgUaF9oFWhgaBhoYWhiaGZoZ2hpaDRoa2hsaG5ob2hxaHJodGh1aHhoeWh7aHxofmg1aH9ogGiCaINohGiFaIZoh2iIaIloimiLaI9okGiRaJJok2iUaJVolmiXaJhomWiaaJtonGidaJ5on2hGaE9ooGihaKJoo2ikaKZop2jSaNto42pLAQAAY2J1aWx0aW5zCl9fZGljdF9fCnUwaksBAABjYnVpbHRpbnMKX19kaWN0X18KdTBo22jjaksBAABjYnVpbHRpbnMKX19kaWN0X18KdTAu",
      "name": "toolify",
      "hash": "d75ba33799e7f6ffa50251badc3dd75563164fae4d50b1cf477df7ed37fd74a1",
      "provenance": {
       "module": "dynamic_module_-5621591935247001235",
       "qualname": "toolify"
      }
     },
     "_convert_string_to_type": {
      "__helper_func__": true,
      "pickled": "gASVMwAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjBdfY29udmVydF9zdHJpbmdfdG9fdHlwZZSTlC4=",
      "name": "_convert_string_to_type",
      "hash": "024e40c56cb46e6fe9f52fe7e6e64a3effc17736268ef31195596c6a6be4c311",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "_convert_string_to_type"
      }
     },
     "_log_error_to_file": {
      "__helper_func__": true,
      "pickled": "gASVLgAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjBJfbG9nX2Vycm9yX3RvX2ZpbGWUk5Qu",
      "name": "_log_error_to_file",
      "hash": "c02546b672eb25afd5dc51ea7e1967cbb6fd264ca18ffd15c3cbeccebe4046ba",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "_log_error_to_file"
      }
     },
     "anthropic": {
      "__module_type__": true,
      "name": "anthropic",
      "spec": "anthropic"
     },
     "web_search": {
      "__imported_callable__": true,
      "pickled": "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X2xvYWRfdHlwZZSTlGgUhZRSlIwGcmV0dXJulGikdXWGlGKMEl9fbW9kdWxlX2NvbnRleHRfX5SMFGJvdHMuZm91bmRhdGlvbi5iYXNllIwNTW9kdWxlQ29udGV4dJSTlCmBlH2UKGhBaC2MBnNvdXJjZZRYoR8AAGRlZiB0b29saWZ5KGRlc2NyaXB0aW9uOiBzdHIgPSBOb25lKToKICAgICIiIgogICAgQ29udmVydCBhbnkgZnVuY3Rpb24gaW50byBhIGJvdCB0b29sIHdpdGggc3RyaW5nLWluLCBzdHJpbmctb3V0IGludGVyZmFjZS4KCiAgICAtIENvbnZlcnRzIHN0cmluZyBpbnB1dHMgdG8gcHJvcGVyIHR5cGVzIHVzaW5nIHR5cGUgaGludHMKICAgIC0gRW5zdXJlcyBzdHJpbmcgb3V0cHV0IChKU09OIGZvciBjb21wbGV4IHR5cGVzKQogICAgLSBXcmFwcyBpbiBlcnJvciBoYW5kbGluZyAocmV0dXJucyBlcnJvciBzdHJpbmdzLCBuZXZlciByYWlzZXMpCiAgICAtIEVuaGFuY2VzIGRvY3N0cmluZyBpZiBkZXNjcmlwdGlvbiBwcm92aWRlZAoKICAgIEFyZ3M6CiAgICAgICAgZGVzY3JpcHRpb24gKHN0ciwgb3B0aW9uYWwpOiBPdmVycmlkZSB0aGUgZnVuY3Rpb24ncyBkb2NzdHJpbmcKCiAgICBFeGFtcGxlOgogICAgICAgIEB0b29saWZ5KCkKICAgICAgICBkZWYgYWRkX251bWJlcnMoeDogaW50LCB5OiBpbnQgPSAwKSAtPiBpbnQ6CiAgICAgICAgICAgIHJldHVybiB4ICsgeQoKICAgICAgICBAdG9vbGlmeSgiQ2FsY3VsYXRlIHRoZSBhcmVhIG9mIGEgY2lyY2xlIikKICAgICAgICBkZWYgYXJlYShyYWRpdXM6IGZsb2F0KSAtPiBmbG9hdDoKICAgICAgICAgICAgcmV0dXJuIDMuMTQxNTkgKiByYWRpdXMgKiByYWRpdXMKICAgICIiIgoKICAgIGRlZiBkZWNvcmF0b3IoZnVuYyk6CiAgICAgICAgQGZ1bmN0b29scy53cmFwcyhmdW5jKQogICAgICAgIGRlZiB3cmFwcGVyKCphcmdzLCAqKmt3YXJncyk6CiAgICAgICAgICAgIHRyeToKICAgICAgICAgICAgICAgICMgQ29udmVydCBzdHJpbmcgaW5wdXRzIHRvIHByb3BlciB0eXBlcyB1c2luZyB0eXBlIGhpbnRzCiAgICAgICAgICAgICAgICBjb252ZXJ0ZWRfYXJncywgY29udmVydGVkX2t3YXJncyA9IF9jb252ZXJ0X3Rvb2xfaW5wdXRzKGZ1bmMsIGFyZ3MsIGt3YXJncykKCiAgICAgICAgICAgICAgICAjIENhbGwgb3JpZ2luYWwgZnVuY3Rpb24KICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmMoKmNvbnZlcnRlZF9hcmdzLCAqKmNvbnZlcnRlZF9rd2FyZ3MpCgogICAgICAgICAgICAgICAgIyBDb252ZXJ0IHJlc3VsdCB0byBzdHJpbmcKICAgICAgICAgICAgICAgIHJldHVybiBfY29udmVydF90b29sX291dHB1dChyZXN1bHQpCgogICAgICAgICAgICBleGNlcHQgS2V5Ym9hcmRJbnRlcnJ1cHQgYXMgZToKICAgICAgICAgICAgICAgICMgQ29udmVydCBLZXlib2FyZEludGVycnVwdCB0byBUb29sRXhlY3V0aW9uRXJyb3IgdG8gcHJldmVudCBpdCBmcm9tCiAgICAgICAgICAgICAgICAjIGJ1YmJsaW5nIHVwIHRvIENMSSBhbmQgYmVpbmcgdHJlYXRlZCBhcyB1c2VyIEN0cmwrQwogICAgICAgICAgICAgICAgZnJvbSBib3RzLnV0aWxzLmhlbHBlcnMgaW1wb3J0IF9wcm9jZXNzX2Vycm9yCgogICAgICAgICAgICAgICAgdG9vbF9lcnJvciA9IFRvb2xFeGVjdXRpb25FcnJvcihmIlRvb2wgZXhlY3V0aW9uIGludGVycnVwdGVkOiB7c3RyKGUpfSIpCiAgICAgICAgICAgICAgICByZXR1cm4gX3Byb2Nlc3NfZXJyb3IodG9vbF9lcnJvcikKCiAgICAgICAgICAgIGV4Y2VwdCBUeXBlRXJyb3IgYXMgZToKICAgICAgICAgICAgICAgICMgQ2hlY2sgaWYgdGhpcyBpcyBhIG1pc3NpbmcgcmVxdWlyZWQgYXJndW1lbnQgZXJyb3IKICAgICAgICAgICAgICAgIGVycm9yX21zZyA9IHN0cihlKQogICAgICAgICAgICAgICAgaWYgIm1pc3NpbmciIGluIGVycm9yX21zZyBhbmQgInJlcXVpcmVkIiBpbiBlcnJvcl9tc2cgYW5kICJhcmd1bWVudCIgaW4gZXJyb3JfbXNnOgogICAgICAgICAgICAgICAgICAgICMgQWRkIHNwZWNpYWwgbWVzc2FnZSBmb3Igb3V0cHV0IHRva2VuIGxpbWl0YXRpb24KICAgICAgICAgICAgICAgICAgICBlbmhhbmNlZF9lcnJvciA9IFR5cGVFcnJvcigKICAgICAgICAgICAgICAgICAgICAgICAgZiJ7ZXJyb3JfbXNnfVxuXG4iCiAgICAgICAgICAgICAgICAgICAgICAgIGYi4pqg77iPICBUaGlzIGVycm9yIGlzIGNvbW1vbmx5IGNhdXNlZCBieSBoaXR0aW5nIHRoZSBtYXhfdG9rZW5zIGxpbWl0IGJlZm9yZSBjb21wbGV0aW5nIHRoZSB0b29sIGNhbGwuXG4iCiAgICAgICAgICAgICAgICAgICAgICAgIGYiVGhlIHJlc3BvbnNlIHdhcyB0cnVuY2F0ZWQgbWlkLXBhcmFtZXRlciwgbWFraW5nIGl0IGFwcGVhciB0aGF0IHJlcXVpcmVkIHBhcmFtZXRlcnMgYXJlIG1pc3NpbmcuXG4iCiAgICAgICAgICAgICAgICAgICAgICAgIGYiVG8gZml4IHRoaXM6IFdvcmsgaW4gU01BTExFUiBDSFVOS1MuIEVkaXQgZmV3ZXIgbGluZXMgYXQgYSB0aW1lLCAiCiAgICAgICAgICAgICAgICAgICAgICAgIGYib3IgYnJlYWsgeW91ciB0YXNrIGludG8gbXVsdGlwbGUgc3RlcHMuIgogICAgICAgICAgICAgICAgICAgICkKICAgICAgICAgICAgICAgICAgICBmcm9tIGJvdHMudXRpbHMuaGVscGVycyBpbXBvcnQgX3Byb2Nlc3NfZXJyb3IKCiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9wcm9jZXNzX2Vycm9yKGVuaGFuY2VkX2Vycm9yKQogICAgICAgICAgICAgICAgZWxzZToKICAgICAgICAgICAgICAgICAgICBmcm9tIGJvdHMudXRpbHMuaGVscGVycyBpbXBvcnQgX3Byb2Nlc3NfZXJyb3IKCiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9wcm9jZXNzX2Vycm9yKGUpCiAgICAgICAgICAgIGV4Y2VwdCBFeGNlcHRpb24gYXMgZToKICAgICAgICAgICAgICAgIGZyb20gYm90cy51dGlscy5oZWxwZXJzIGltcG9ydCBfcHJvY2Vzc19lcnJvcgoKICAgICAgICAgICAgICAgIHJldHVybiBfcHJvY2Vzc19lcnJvcihlKQoKICAgICAgICAjIFVwZGF0ZSBkb2NzdHJpbmcgaWYgZGVzY3JpcHRpb24gcHJvdmlkZWQKICAgICAgICBpZiBkZXNjcmlwdGlvbjoKICAgICAgICAgICAgd3JhcHBlci5fX2RvY19fID0gZGVzY3JpcHRpb24KICAgICAgICBlbGlmIG5vdCB3cmFwcGVyLl9fZG9jX186CiAgICAgICAgICAgICMgR2VuZXJhdGUgbWluaW1hbCBkb2NzdHJpbmcgZnJvbSBmdW5jdGlvbiBuYW1lCiAgICAgICAgICAgIHdyYXBwZXIuX19kb2NfXyA9IGYiRXhlY3V0ZSB7ZnVuYy5fX25hbWVfXy5yZXBsYWNlKCdfJywgJyAnKX0iCgogICAgICAgIHJldHVybiB3cmFwcGVyCgogICAgcmV0dXJuIGRlY29yYXRvcgoKQHRvb2xpZnkoIlBlcmZvcm0gYW4gYWdlbnRpYyB3ZWIgc2VhcmNoIHVzaW5nIENsYXVkZSdzIGludGVybmFsIHdlYiBzZWFyY2ggY2FwYWJpbGl0aWVzIikKZGVmIHdlYl9zZWFyY2gocXVlc3Rpb246IHN0cikgLT4gc3RyOgogICAgIiIiUGVyZm9ybSBhbiBpbnRlbGxpZ2VudCB3ZWIgc2VhcmNoIGFuZCByZXR1cm4gb3JnYW5pemVkIHJlc3VsdHMuCgogICAgVGhpcyB0b29sIHVzZXMgQ2xhdWRlJ3MgYnVpbHQtaW4gd2ViIHNlYXJjaCBmdW5jdGlvbmFsaXR5IHRvIHBlcmZvcm0gc2VhcmNoZXMKICAgIGFuZCByZXR1cm5zIG9yZ2FuaXplZCwgcGVydGluZW50IGluZm9ybWF0aW9uIGV4dHJhY3RlZCBmcm9tIHRoZSByZXN1bHRzLgoKICAgIEFyZ3M6CiAgICAgICAgcXVlc3Rpb24gKHN0cik6IFRoZSBzZWFyY2ggZ29hbCBmcmFtZWQgYXMgYSBxdWVzdGlvbi4KICAgICAgICBHb29kIGV4YW1wbGVzOgogICAgICAgICAgICAiV2hvIGlzIEJlbiBSaW5hdXRvPyIKICAgICAgICAgICAgIldoYXQgaXMgdGhlIGNvbm5lY3Rpb24gYmV0d2VlbiBQYXJpcywgRnJhbmNlIGFuZCBCdWZmYWxvLCBOWT8iCiAgICAgICAgQmFkIGV4YW1wbGVzOgogICAgICAgICAgICAiQmVuIFIgd3Jlc3RsaW5nIgogICAgICAgICAgICAicGFyaXMgYnVmZmFsbyIKCiAgICBSZXR1cm5zOgogICAgICAgIHN0cjogT3JnYW5pemVkIHNlYXJjaCByZXN1bHRzIHdpdGgga2V5IGluZm9ybWF0aW9uIGV4dHJhY3RlZAogICAgIiIiCiAgICB0cnk6CiAgICAgICAgX3ZhbGlkYXRlX3F1ZXN0aW9uX2Zvcm1hdChxdWVzdGlvbikKICAgICAgICBhcGlfa2V5ID0gb3MuZ2V0ZW52KCdBTlRIUk9QSUNfQVBJX0tFWScpCiAgICAgICAgaWYgbm90IGFwaV9rZXk6CiAgICAgICAgICAgIHJldHVybiAnRXJyb3I6IEFOVEhST1BJQ19BUElfS0VZIGVudmlyb25tZW50IHZhcmlhYmxlIG5vdCBzZXQnCiAgICAgICAgY2xpZW50ID0gYW50aHJvcGljLkFudGhyb3BpYyhhcGlfa2V5PWFwaV9rZXkpCiAgICAgICAgdG9vbHMgPSBbeyd0eXBlJzogJ3dlYl9zZWFyY2hfMjAyNTAzMDUnLCAnbmFtZSc6ICd3ZWJfc2VhcmNoJywgJ21heF91c2VzJzogMTB9XQogICAgICAgIHNlYXJjaF9wcm9tcHQgPSBmJ0kgbmVlZCB5b3UgdG8gc2VhcmNoIHRoZSB3ZWIgYW5zd2VycyB0byB0aGlzIHF1ZXN0aW9uOiAie3F1ZXN0aW9ufSJcblxuICAgICAgICBQbGVhc2UgdXNlIHRoZSB3ZWIgc2VhcmNoIHRvb2wgdG8gZmluZCBjdXJyZW50LCByZWxldmFudCBpbmZvcm1hdGlvbiB0byBwcmVjaXNlbHkgYW5kXG4gICAgICAgIGFjY3VyYXRlbHkgYW5zd2VyIHRoaXMgcXVlc3Rpb24uJwogICAgICAgIHJlc3BvbnNlID0gY2xpZW50Lm1lc3NhZ2VzLmNyZWF0ZShtb2RlbD0nY2xhdWRlLW9wdXMtNC0xJywgbWF4X3Rva2Vucz0xNjM4NCwgdGVtcGVyYXR1cmU9MC4zLCB0b29scz10b29scywgbWVzc2FnZXM9W3sncm9sZSc6ICd1c2VyJywgJ2NvbnRlbnQnOiBzZWFyY2hfcHJvbXB0fV0pCgogICAgICAgIGRlZiBleHRyYWN0X2NsZWFuX2NvbnRlbnQocmVzcG9uc2UpOgogICAgICAgICAgICAiIiJFeHRyYWN0IG9ubHkgdGhlIGVzc2VudGlhbCBjb250ZW50IGZyb20gd2ViIHNlYXJjaCByZXNwb25zZS4iIiIKICAgICAgICAgICAgcmVzdWx0ID0gW10KICAgICAgICAgICAgcmVzdWx0LmFwcGVuZCgnPT09IFdFQiBTRUFSQ0ggUkVTVUxUUyA9PT1cbicpCiAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoZidTZWFyY2g6ICJ7cXVlc3Rpb259IlxuJykKICAgICAgICAgICAgaWYgaGFzYXR0cihyZXNwb25zZSwgJ2NvbnRlbnQnKSBhbmQgcmVzcG9uc2UuY29udGVudDoKICAgICAgICAgICAgICAgIHRleHRfcmVzcG9uc2VzID0gW10KICAgICAgICAgICAgICAgIHNlYXJjaF9yZXN1bHRzID0gW10KICAgICAgICAgICAgICAgIGZvciBibG9jayBpbiByZXNwb25zZS5jb250ZW50OgogICAgICAgICAgICAgICAgICAgIGlmIGhhc2F0dHIoYmxvY2ssICd0eXBlJykgYW5kIGJsb2NrLnR5cGUgPT0gJ3RleHQnIGFuZCBoYXNhdHRyKGJsb2NrLCAndGV4dCcpIGFuZCBibG9jay50ZXh0OgogICAgICAgICAgICAgICAgICAgICAgICB0ZXh0X3Jlc3BvbnNlcy5hcHBlbmQoYmxvY2sudGV4dCkKICAgICAgICAgICAgICAgICAgICBlbGlmIGhhc2F0dHIoYmxvY2ssICd0eXBlJykgYW5kIGJsb2NrLnR5cGUgPT0gJ3dlYl9zZWFyY2hfdG9vbF9yZXN1bHQnOgogICAgICAgICAgICAgICAgICAgICAgICBpZiBoYXNhdHRyKGJsb2NrLCAnY29udGVudCcpIGFuZCBibG9jay5jb250ZW50OgogICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIGl0ZW0gaW4gYmxvY2suY29udGVudDoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiBpc2luc3RhbmNlKGl0ZW0sIGRpY3QpIGFuZCBpdGVtLmdldCgndHlwZScpID09ICd3ZWJfc2VhcmNoX3Jlc3VsdCc6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlYXJjaF9yZXN1bHRzLmFwcGVuZCh7J3RpdGxlJzogaXRlbS5nZXQoJ3RpdGxlJywgJ05vIHRpdGxlJyksICd1cmwnOiBpdGVtLmdldCgndXJsJywgJ05vIFVSTCcpLCAnYWdlJzogaXRlbS5nZXQoJ3BhZ2VfYWdlJywgJ1Vua25vd24gYWdlJyl9KQogICAgICAgICAgICAgICAgaWYgdGV4dF9yZXNwb25zZXM6CiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZCgiPT09IENMQVVERSdTIEFOQUxZU0lTID09PVxuIikKICAgICAgICAgICAgICAgICAgICBmb3IgaSwgdGV4dCBpbiBlbnVtZXJhdGUodGV4dF9yZXNwb25zZXMsIDEpOgogICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKGYne2l9LiB7dGV4dH1cbicpCiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZCgnJykKICAgICAgICAgICAgICAgIGlmIHNlYXJjaF9yZXN1bHRzOgogICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoJz09PSBTT1VSQ0VTIEZPVU5EID09PVxuJykKICAgICAgICAgICAgICAgICAgICBmb3IgaSwgaXRlbSBpbiBlbnVtZXJhdGUoc2VhcmNoX3Jlc3VsdHMsIDEpOgogICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKGYie2l9LiB7aXRlbVsndGl0bGUnXX0iKQogICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKGYiICAge2l0ZW1bJ3VybCddfSIpCiAgICAgICAgICAgICAgICAgICAgICAgIGlmIGl0ZW1bJ2FnZSddIGFuZCBpdGVtWydhZ2UnXSAhPSAnVW5rbm93biBhZ2UnOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZChmIiAgICh7aXRlbVsnYWdlJ119KSIpCiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoJycpCiAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKGYiU2VhcmNoIHBlcmZvcm1lZDoge2RhdGV0aW1lLmRhdGV0aW1lLm5vdygpLnN0cmZ0aW1lKCclWS0lbS0lZCAlSDolTSBVVEMnKX0iKQogICAgICAgICAgICByZXR1cm4gJ1xuJy5qb2luKHJlc3VsdCkKICAgICAgICBjbGVhbl9jb250ZW50ID0gZXh0cmFjdF9jbGVhbl9jb250ZW50KHJlc3BvbnNlKQogICAgICAgIHJldHVybiBjbGVhbl9jb250ZW50CiAgICBleGNlcHQgRXhjZXB0aW9uIGFzIGU6CiAgICAgICAgcmV0dXJuIGYnV2ViIHNlYXJjaCBmYWlsZWQ6IHtzdHIoZSl9JwoKZGVmIF92YWxpZGF0ZV9xdWVzdGlvbl9mb3JtYXQocXVlcnk6IHN0cikgLT4gYm9vbDoKICAgICIiIlVzZSBhIHNpbXBsZSBIYWlrdSBib3QgdG8gdmFsaWRhdGUgaWYgaW5wdXQgaXMgZm9ybWF0dGVkIGFzIGEgcXVlc3Rpb24uCgogICAgQXJnczoKICAgICAgICBxdWVyeSAoc3RyKTogVGhlIGlucHV0IHF1ZXJ5IHRvIHZhbGlkYXRlCgogICAgUmV0dXJuczoKICAgICAgICBib29sOiBUcnVlIGlmIGZvcm1hdHRlZCBhcyBhIHF1ZXN0aW9uLCBGYWxzZSBvdGhlcndpc2UKCiAgICBSYWlzZXM6CiAgICAgICAgVmFsdWVFcnJvcjogSWYgcXVlcnkgaXMgbm90IGZvcm1hdHRlZCBhcyBhIHF1ZXN0aW9uCiAgICAiIiIKICAgIHRyeToKICAgICAgICBhcGlfa2V5ID0gb3MuZ2V0ZW52KCdBTlRIUk9QSUNfQVBJX0tFWScpCiAgICAgICAgaWYgbm90IGFwaV9rZXk6CiAgICAgICAgICAgIHJldHVybiBUcnVlCiAgICAgICAgY2xpZW50ID0gYW50aHJvcGljLkFudGhyb3BpYyhhcGlfa2V5PWFwaV9rZXkpCiAgICAgICAgdmFsaWRhdGlvbl9wcm9tcHQgPSBmJ0lzIHRoaXMgdGV4dCBmb3JtYXR0ZWQgYXMgYSBxdWVzdGlvbj8gQW5zd2VyIG9ubHkgWSBvciBOLlxuXG5UZXh0OiAie3F1ZXJ5fSJcblxuQW5zd2VyOicKICAgICAgICByZXNwb25zZSA9IGNsaWVudC5tZXNzYWdlcy5jcmVhdGUobW9kZWw9J2NsYXVkZS0zLWhhaWt1LTIwMjQwMzA3JywgbWF4X3Rva2Vucz0xMCwgdGVtcGVyYXR1cmU9MC4wLCBtZXNzYWdlcz1beydyb2xlJzogJ3VzZXInLCAnY29udGVudCc6IHZhbGlkYXRpb25fcHJvbXB0fV0pCiAgICAgICAgYW5zd2VyID0gcmVzcG9uc2UuY29udGVudFswXS50ZXh0LnN0cmlwKCkudXBwZXIoKQogICAgICAgIGlmIGFuc3dlci5zdGFydHN3aXRoKCdOJyk6CiAgICAgICAgICAgIHJhaXNlIFZhbHVlRXJyb3IoIklucHV0IHF1ZXJpZXMgbXVzdCBiZSBmb3JtYXR0ZWQgYXMgcXVlc3Rpb25zLiBHb29kIGV4YW1wbGVzOiAnV2hvIGlzLi4uPycsICdXaGF0IGlzLi4uPycsICdIb3cgZG9lcy4uLj8nIEJhZCBleGFtcGxlczogJ0JlbiBSIHdyZXN0bGluZycsICdwYXJpcyBidWZmYWxvJ1RoZSBtb3JlIGluZm9ybWF0aW9uLCBhbmQgdGhlIG1vcmUgc3BlY2lmaWMsIHRoZSBiZXR0ZXIuIFlvdSBhcmUgYXNraW5nIGFuIEFJIHRvIGFuc3dlciBhIHF1ZXN0aW9uLCBub3QgcGVyZm9ybWluZyBhIHRyYWRpdGlvbmFsIHdlYiBrZXl3b3JkIHNlYXJjaC4iKQogICAgICAgIHJldHVybiBUcnVlCiAgICBleGNlcHQgVmFsdWVFcnJvcjoKICAgICAgICByYWlzZQogICAgZXhjZXB0IEV4Y2VwdGlvbjoKICAgICAgICByZXR1cm4gVHJ1ZZSMCWZpbGVfcGF0aJSMImR5bmFtaWNfbW9kdWxlXzc3NzM4NDk2MDcyNjc2Mjc4NTWUjAluYW1lc3BhY2WUaACMDl9pbXBvcnRfbW9kdWxllJOUjC9fX3J1bnRpbWVfXy5keW5hbWljX21vZHVsZV8tNTYyMTU5MTkzNTI0NzAwMTIzNZSFlFKUfZQoaCxoLWieTowLX19wYWNrYWdlX1+UTowIX19zcGVjX1+UTowIX19maWxlX1+UaLBoD4wTYm90cy5kZXYuZGVjb3JhdG9yc5RoD5OUaBBou2gQk5RoE2i7aBOTlIwDYXN0lGizaL+FlFKUaHNos2hzhZRSlIwJZnVuY3Rvb2xzlGizaMSFlFKUjAdpbnNwZWN0lGizaMeFlFKUjAdsb2dnaW5nlGizaMqFlFKUaIpos2iKhZRSlIwDc3lzlGizjANzeXOUhZRSlIwIdGV4dHdyYXCUaLNo04WUUpSMCXRyYWNlYmFja5Ros2jWhZRSlIwFd3JhcHOUaMRo2ZOUjANBbnmUjAZ0eXBpbmeUaNuTlIwIQ2FsbGFibGWUaNxo3pOUjAhPcHRpb25hbJRo3Gjgk5SMBFR5cGWUaNxo4pOUjBJyZW1vdmVfY29kZV9ibG9ja3OUaBJo5JOUjAZsb2dnZXKUaMqMCWdldExvZ2dlcpSTlGi7hZRSlIwMTm9IVFRQRmlsdGVylGi7aOuTlIwHbGF6eV9mbpRou2jtk5SMCmxhenlfY2xhc3OUaLto75OUjAxfZ2V0X2NvbnRleHSUaLto8ZOUjBFfZ2V0X3B5X2ludGVyZmFjZZRou2jzk5SMBGxhenmUaLto9ZOUjA5kZWJ1Z19vbl9lcnJvcpRou2j3k5SMCmxvZ19lcnJvcnOUaLto+ZOUjAd0b29saWZ5lGgCKGgEKEMEBBYKNpRLAUsASwBLAksCSwNDEocAlwCIAGYBZAGECH0BfAFTAJRYiAIAAAogICAgQ29udmVydCBhbnkgZnVuY3Rpb24gaW50byBhIGJvdCB0b29sIHdpdGgg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",
      "name": "web_search",
      "hash": "5323a46b256ce3c9ad9c0793230109fab75faddc2de6919684aa810f61bf5e0b",
      "provenance": {
       "module": "dynamic_module_-5621591935247001235",
       "qualname": "web_search"
      }
     }
    }
   },
   "dynamic_module_3232420128943804863": {
    "name": "dynamic_module_250906616726654990",
    "source": "import textwrap\nfrom bots.utils.helpers import _process_error\nfrom typing import List, Optional\n\ndef toolify(description: str = None):\n    \"\"\"\n    Convert any function into a bot tool with string-in, string-out interface.\n\n    - Converts string inputs to proper types using type hints\n    - Ensures string output (JSON for complex types)\n    - Wraps in error handling (returns error strings, never raises)\n    - Enhances docstring if description provided\n\n    Args:\n        description (str, optional): Override the function's docstring\n\n    Example:\n        @toolify()\n        def add_numbers(x: int, y: int = 0) -> int:\n            return x + y\n\n        @toolify(\"Calculate the area of a circle\")\n        def area(radius: float) -> float:\n            return 3.14159 * radius * radius\n    \"\"\"\n\n    def decorator(func):\n        @functools.wraps(func)\n        def wrapper(*args, **kwargs):\n            try:\n                # Convert string inputs to proper types using type hints\n                converted_args, converted_kwargs = _convert_tool_inputs(func, args, kwargs)\n\n                # Call original function\n                result = func(*converted_args, **converted_kwargs)\n\n                # Convert result to string\n                return _convert_tool_output(result)\n\n            except KeyboardInterrupt as e:\n                # Convert KeyboardInterrupt to ToolExecutionError to prevent it from\n                # bubbling up to CLI and being treated as user Ctrl+C\n\n                tool_error = ToolExecutionError(f\"Tool execution interrupted: {str(e)}\")\n                return _process_error(tool_error)\n\n            except TypeError as e:\n                # Check if this is a missing required argument error\n                error_msg = str(e)\n                if \"missing\" in error_msg and \"required\" in error_msg and \"argument\" in error_msg:\n                    # Add special message for output token limitation\n                    enhanced_error = TypeError(\n                        f\"{error_msg}\\n\\n\"\n                        f\"\u26a0\ufe0f  This error is commonly caused by hitting the max_tokens limit before completing the tool call.\\n\"\n                        f\"The response was truncated mid-parameter, making it appear that required parameters are missing.\\n\"\n                        f\"To fix this: Work in SMALLER CHUNKS. Edit fewer lines at a time, \"\n                        f\"or break your task into multiple steps.\"\n                    )\n\n                    return _process_error(enhanced_error)\n                else:\n\n                    return _process_error(e)\n            except Exception as e:\n\n                return _process_error(e)\n\n        # Update docstring if description provided\n        if description:\n            wrapper.__doc__ = description\n        elif not wrapper.__doc__:\n            # Generate minimal docstring from function name\n            wrapper.__doc__ = f\"Execute {func.__name__.replace('_', ' ')}\"\n\n        return wrapper\n\n    return decorator\n\n@toolify()\ndef python_edit(target_scope: str, code: str, *, coscope_with: str=None, delete_a_lot: bool=False) -> str:\n    \"\"\"\n        Edit Python code using pytest-style scope syntax and optional expression matching.\n\n        Parameters:\n        -----------\n        target_scope : str\n            Location to edit in pytest-style scope syntax:\n            - \"file.py\" (whole file)\n            - \"file.py::MyClass\" (class)\n            - \"file.py::my_function\" (function)\n            - \"file.py::MyClass::method\" (method)\n            - \"file.py::__FIRST__\" (first top-level definition)\n\n        code : str\n            Python code. This code will replace the entire target scope by default,\n            or insert after (if coscope_with is specified). Code is indented automatically\n            to match to scope.\n\n        coscope_with : str, optional\n            If specified, code is inserted in the same scope as the specified code,\n            and immediately after it. Uses the same syntax as target_scope with\n            optional expression at the end in quotes.\n\n\n                Scope:\n                    - a\n                    - b\n\n                - python edit called with coscope_with = \"a\", code = \"- c\" -\n\n                Scope:\n                    - a\n                    - c\n                    - b\n\n            - \"__FILE_START__\" (special token for file beginning)\n            - \"MyClass::method\" (insert after this method within the target scope)\n            - '\"expression\"' (insert after a line matching this expression)\n        delete_a_lot : bool, optional\n    - \"__FILE_END__\" (special token for file end)\n            Safety parameter. Must be True to allow operations that delete more than 100 lines.\n            Helps prevent accidental file overwrites. Default False.\n\n        Returns:\n        --------\n        str\n            Description of what was modified or error message\n    \"\"\"\n    try:\n        file_path, *path_elements = target_scope.split('::')\n        if not file_path.endswith('.py'):\n            return _process_error(ValueError(f'File path must end with .py: {file_path}'))\n        for element in path_elements:\n            if not element.isidentifier() and element != '__FIRST__':\n                return _process_error(ValueError(f'Invalid identifier in path: {element}'))\n        abs_path = _make_file(file_path)\n        try:\n            original_content = _read_file_bom_safe(abs_path)\n            was_originally_empty = not original_content.strip()\n        except Exception as e:\n            return _process_error(ValueError(f'Error reading file {abs_path}: {str(e)}'))\n        try:\n            if original_content.strip():\n                tree = cst.parse_module(original_content)\n            else:\n                tree = cst.parse_module('')\n        except Exception as e:\n            return _process_error(ValueError(f'Error parsing file {abs_path}: {str(e)}'))\n        try:\n            cleaned_code = textwrap.dedent(code).strip()\n            if not cleaned_code:\n                if coscope_with:\n                    return _process_error(ValueError('Cannot use empty code with insert_after - nothing to insert'))\n                return _handle_deletion(abs_path, target_scope, path_elements, original_content, tree, delete_a_lot)\n            elif was_originally_empty and (not path_elements):\n                _write_file_bom_safe(abs_path, cleaned_code)\n                return f\"Code added to '{abs_path}'.\"\n            new_module = None\n            if cleaned_code:\n                try:\n                    new_module = cst.parse_module(cleaned_code)\n                except Exception as e:\n                    if cleaned_code.strip().startswith('#'):\n                        comment_stmt = _create_statement_with_comment(cleaned_code.strip())\n                        new_module = cst.Module(body=[comment_stmt])\n                    else:\n                        return _process_error(ValueError(f'Error parsing new code: {str(e)}'))\n        except Exception as e:\n            return _process_error(ValueError(f'Error processing new code: {str(e)}'))\n        if path_elements and path_elements[0] == '__FIRST__':\n            if len(path_elements) > 1:\n                return _process_error(ValueError('__FIRST__ cannot be combined with other path elements'))\n            return _handle_first_definition(abs_path, tree, new_module, coscope_with)\n        duplicate_warning = None\n        if coscope_with and new_module:\n            duplicate_warning = _check_for_duplicates(tree, new_module, path_elements)\n        if coscope_with in ('__FILE_START__', '__FILE_END__') and path_elements:\n            return _process_error(ValueError(f\"Cannot use {coscope_with} with scoped target '{target_scope}'. File-level tokens (__FILE_START__, __FILE_END__) can only be used with file-level targets (e.g., 'file.py').\"))\n        if coscope_with == '__FILE_START__':\n            result = _handle_file_start_insertion(abs_path, tree, new_module)\n            if duplicate_warning:\n                result = duplicate_warning + ' ' + result\n            return result\n        elif coscope_with == '__FILE_END__':\n            result = _handle_file_end_insertion(abs_path, tree, new_module)\n            if duplicate_warning:\n                result = duplicate_warning + ' ' + result\n            return result\n        elif not path_elements:\n            if coscope_with:\n                result = _handle_file_level_insertion(abs_path, tree, new_module, coscope_with)\n                if duplicate_warning:\n                    result = duplicate_warning + ' ' + result\n                return result\n            else:\n                lines_to_delete = _count_lines_to_be_deleted(original_content, cleaned_code)\n                if lines_to_delete > 100 and (not delete_a_lot):\n                    return _process_error(ValueError(f'Safety check: this operation would delete {lines_to_delete} lines. ' + \"If intentional, set delete_a_lot=True. Consider using 'insert_after' parameter to add code without deleting existing content.\"))\n                _write_file_bom_safe(abs_path, cleaned_code)\n                return f\"Code replaced at file level in '{abs_path}'.\"\n        else:\n            replacer = ScopeReplacer(path_elements, new_module, coscope_with, tree)\n            modified_tree = tree.visit(replacer)\n            if not replacer.modified:\n                if coscope_with:\n                    return _process_error(ValueError(f'Insert point not found: {coscope_with}'))\n                else:\n                    return _process_error(ValueError(f'Target scope not found: {target_scope}'))\n            _write_file_bom_safe(abs_path, modified_tree.code)\n            if coscope_with:\n                result = f\"Code inserted after '{coscope_with}' in '{abs_path}'.\"\n                if duplicate_warning:\n                    result = duplicate_warning + ' ' + result\n                return result\n            else:\n                return f\"Code replaced at '{target_scope}'.\"\n    except Exception as e:\n        return _process_error(e)\n\ndef _handle_file_start_insertion(abs_path: str, tree: cst.Module, new_module: cst.Module) -> str:\n    \"\"\"Handle insertion at the beginning of a file, avoiding duplicate imports.\"\"\"\n    existing_imports = set()\n    for stmt in tree.body:\n        if isinstance(stmt, (cst.SimpleStatementLine,)):\n            for s in stmt.body:\n                if isinstance(s, cst.Import):\n                    for name in s.names:\n                        if isinstance(name, cst.ImportAlias):\n                            import_name = _get_module_name(name.name)\n                            existing_imports.add(('import', import_name))\n                elif isinstance(s, cst.ImportFrom):\n                    if s.module:\n                        module_name = _get_module_name(s.module)\n                        for name in s.names:\n                            if isinstance(name, cst.ImportAlias):\n                                imported_name = _get_module_name(name.name)\n                                existing_imports.add(('from', module_name, imported_name))\n                            elif isinstance(name, cst.ImportStar):\n                                existing_imports.add(('from', module_name, '*'))\n    new_body = []\n    for stmt in new_module.body:\n        if isinstance(stmt, (cst.SimpleStatementLine,)):\n            filtered_imports = []\n            non_import_stmts = []\n            for s in stmt.body:\n                if isinstance(s, cst.Import):\n                    new_names = []\n                    for name in s.names:\n                        if isinstance(name, cst.ImportAlias):\n                            import_name = _get_module_name(name.name)\n                            if ('import', import_name) not in existing_imports:\n                                new_names.append(name)\n                    if new_names:\n                        filtered_imports.append(s.with_changes(names=new_names))\n                elif isinstance(s, cst.ImportFrom):\n                    if s.module:\n                        module_name = _get_module_name(s.module)\n                        new_names = []\n                        for name in s.names:\n                            if isinstance(name, cst.ImportAlias):\n                                imported_name = _get_module_name(name.name)\n                                if ('from', module_name, imported_name) not in existing_imports:\n                                    new_names.append(name)\n                            elif isinstance(name, cst.ImportStar):\n                                if ('from', module_name, '*') not in existing_imports:\n                                    new_names.append(name)\n                        if new_names:\n                            filtered_imports.append(s.with_changes(names=new_names))\n                else:\n                    non_import_stmts.append(s)\n            if filtered_imports or non_import_stmts:\n                new_body.append(stmt.with_changes(body=filtered_imports + non_import_stmts))\n        else:\n            new_body.append(stmt)\n    combined_body = new_body + list(tree.body)\n    modified_tree = tree.with_changes(body=combined_body)\n    _write_file_bom_safe(abs_path, modified_tree.code)\n    return f\"Code inserted at start of '{abs_path}' (duplicate imports filtered).\"\n\ndef _read_file_bom_safe(file_path: str) -> str:\n    \"\"\"Read a file with BOM protection.\"\"\"\n    with open(file_path, 'r', encoding='utf-8') as file:\n        content = file.read()\n    return clean_unicode_string(content)\n\ndef _handle_file_end_insertion(abs_path: str, tree: cst.Module, new_module: cst.Module) -> str:\n    \"\"\"Handle insertion at the end of a file.\"\"\"\n    if len(new_module.body) == 0 and new_module.code.strip():\n        comment_stmt = _create_statement_with_comment(new_module.code.strip())\n        new_body = list(tree.body) + [comment_stmt]\n    else:\n        new_body = list(tree.body) + list(new_module.body)\n    modified_tree = tree.with_changes(body=new_body)\n    final_code = modified_tree.code\n    if final_code and (not final_code.endswith('\\n')):\n        final_code += '\\n'\n    _write_file_bom_safe(abs_path, final_code)\n    return f\"Code inserted at end of '{abs_path}'.\"\n\ndef _check_for_duplicates(tree: cst.Module, new_module: cst.Module, path_elements: List[str]) -> Optional[str]:\n    \"\"\"\n    Check if new code would create duplicate definitions.\n\n    Returns:\n        Optional[str]: Warning message if duplicates found, None otherwise\n    \"\"\"\n    new_names = _extract_definition_names(new_module)\n    if not new_names:\n        return None\n    if not path_elements:\n        existing_names = _extract_definition_names(tree)\n        duplicates = set(new_names) & set(existing_names)\n        if duplicates:\n            dup_list = ', '.join(sorted(duplicates))\n            return f'Warning: Adding duplicate definition(s): {dup_list}. This will create multiple definitions with the same name.'\n    else:\n        finder = ScopeFinder(path_elements)\n        tree.visit(finder)\n        if finder.target_node and isinstance(finder.target_node, cst.ClassDef):\n            existing_methods = []\n            for item in finder.target_node.body.body:\n                if isinstance(item, cst.FunctionDef):\n                    existing_methods.append(item.name.value)\n            duplicates = set(new_names) & set(existing_methods)\n            if duplicates:\n                dup_list = ', '.join(sorted(duplicates))\n                class_name = finder.target_node.name.value\n                return f\"Warning: Adding duplicate method(s) to class '{class_name}': {dup_list}. This will create multiple methods with the same name.\"\n    return None\n\ndef _count_lines_to_be_deleted(original_content: str, new_content: str) -> int:\n    \"\"\"\n    Count how many lines would be deleted by comparing original vs new content.\n\n    Parameters:\n    -----------\n    original_content : str\n        The original file content\n    new_content : str\n        The new content that would replace it\n\n    Returns:\n    --------\n    int\n        Number of lines that would be deleted\n    \"\"\"\n    original_lines = len(original_content.splitlines()) if original_content.strip() else 0\n    new_lines = len(new_content.splitlines()) if new_content.strip() else 0\n    return max(0, original_lines - new_lines)\n\ndef _handle_file_level_insertion(abs_path: str, tree: cst.Module, new_module: cst.Module, insert_after: str) -> str:\n    \"\"\"Handle insertion at file level after a specific pattern.\"\"\"\n    pattern = insert_after.strip()\n    if pattern.startswith('\"') and pattern.endswith('\"') or (pattern.startswith(\"'\") and pattern.endswith(\"'\")):\n        pattern = pattern[1:-1]\n\n    class FileOnlyInserter(cst.CSTTransformer):\n\n        def __init__(self, pattern: str, new_nodes: List[cst.CSTNode]):\n            self.pattern = pattern.strip()\n            self.new_nodes = new_nodes\n            self.modified = False\n\n        def leave_Module(self, original_node: cst.Module, updated_node: cst.Module) -> cst.Module:\n            new_body = []\n            for stmt in updated_node.body:\n                new_body.append(stmt)\n                match_found = False\n                if isinstance(stmt, (cst.FunctionDef, cst.ClassDef)) and stmt.name.value == self.pattern:\n                    match_found = True\n                else:\n                    try:\n                        stmt_code = updated_node.code_for_node(stmt).strip()\n                        if self.pattern in stmt_code:\n                            match_found = True\n                    except Exception:\n                        pass\n                if match_found:\n                    new_body.extend(self.new_nodes)\n                    self.modified = True\n            if self.modified:\n                return updated_node.with_changes(body=new_body)\n            return updated_node\n    inserter = FileOnlyInserter(pattern, new_module.body)\n    modified_tree = tree.visit(inserter)\n    if not inserter.modified:\n        return _process_error(ValueError(f'Insert point not found at file level: {insert_after}'))\n    _write_file_bom_safe(abs_path, modified_tree.code)\n    return f\"Code inserted after '{insert_after}' in '{abs_path}'.\"\n\ndef _handle_deletion(abs_path: str, target_scope: str, path_elements: list, original_content: str, tree: cst.Module, delete_a_lot: bool=False) -> str:\n    \"\"\"Handle deletion of a target section when empty code is provided.\"\"\"\n    try:\n        lines_to_delete = _count_lines_to_be_deleted(original_content, '')\n        if lines_to_delete > 100 and (not delete_a_lot):\n            return _process_error(ValueError(f'Safety check: this operation would delete {lines_to_delete} lines. ' + \"If intentional, set delete_a_lot=True. Consider using 'insert_after' parameter to add code without deleting existing content.\"))\n        if not path_elements:\n            _write_file_bom_safe(abs_path, '')\n            return f\"File '{abs_path}' cleared (deleted all content).\"\n        else:\n            deleter = ScopeDeleter(path_elements)\n            modified_tree = tree.visit(deleter)\n            if not deleter.modified:\n                return _process_error(ValueError(f'Target scope not found for deletion: {target_scope}'))\n            _write_file_bom_safe(abs_path, modified_tree.code)\n            return f\"Deleted scope '{target_scope}' from '{abs_path}'.\"\n    except Exception as e:\n        return _process_error(e)\n\ndef _write_file_bom_safe(file_path: str, content: str) -> None:\n    \"\"\"Write a file with BOM protection.\"\"\"\n    ends_with_newline = content.endswith('\\n')\n    clean_content = clean_unicode_string(content)\n    if ends_with_newline and (not clean_content.endswith('\\n')):\n        clean_content += '\\n'\n    with open(file_path, 'w', encoding='utf-8') as file:\n        file.write(clean_content)\n\ndef _make_file(file_path: str) -> str:\n    \"\"\"\n    Create a file and its parent directories if they don't exist.\n\n    Parameters:\n    -----------\n    file_path : str\n        Path to the file to create\n\n    Returns:\n    --------\n    str\n        Absolute path to the created/existing file\n\n    Raises:\n    -------\n    ValueError\n        If there's an error creating the file or directories\n    \"\"\"\n    if not file_path:\n        raise ValueError('File path cannot be empty')\n    abs_path = os.path.abspath(file_path)\n    dir_path = os.path.dirname(abs_path)\n    if dir_path:\n        try:\n            os.makedirs(dir_path, exist_ok=True)\n        except Exception as e:\n            raise ValueError(f'Error creating directories {dir_path}: {str(e)}')\n    if not os.path.exists(abs_path):\n        try:\n            with open(abs_path, 'w', encoding='utf-8') as f:\n                f.write('')\n        except Exception as e:\n            raise ValueError(f'Error creating file {abs_path}: {str(e)}')\n    return abs_path\n\ndef _create_statement_with_comment(comment_text: str, indent_level: int=0) -> cst.SimpleStatementLine:\n    \"\"\"\n    Create a statement that contains just a comment.\n    Since LibCST requires statements to have actual code, we create a pass statement\n    with a trailing comment.\n    \"\"\"\n    lines = comment_text.strip().split('\\n')\n    if len(lines) > 1:\n        comment_text = lines[0]\n    comment_text = comment_text.strip()\n    if comment_text.startswith('#'):\n        comment_text = comment_text[1:].strip()\n    comment = cst.Comment(f'# {comment_text}')\n    return cst.SimpleStatementLine(body=[cst.Pass()], trailing_whitespace=cst.TrailingWhitespace(whitespace=cst.SimpleWhitespace('  '), comment=comment))\n\ndef _handle_first_definition(abs_path: str, tree: cst.Module, new_module: cst.Module, coscope_with: str=None) -> str:\n    \"\"\"Handle editing the first top-level definition in a file.\"\"\"\n    if not tree.body:\n        return _process_error(ValueError('File has no top-level definitions to edit'))\n    first_def_index = None\n    for i, stmt in enumerate(tree.body):\n        if isinstance(stmt, (cst.FunctionDef, cst.ClassDef)):\n            first_def_index = i\n            break\n    if first_def_index is None:\n        return _process_error(ValueError('No function or class definition found in file'))\n    if coscope_with:\n        new_body = list(tree.body[:first_def_index + 1]) + list(new_module.body) + list(tree.body[first_def_index + 1:])\n        modified_tree = tree.with_changes(body=new_body)\n        _write_file_bom_safe(abs_path, modified_tree.code)\n        return f\"Code inserted after first definition in '{abs_path}'.\"\n    else:\n        new_body = list(tree.body[:first_def_index]) + list(new_module.body) + list(tree.body[first_def_index + 1:])\n        modified_tree = tree.with_changes(body=new_body)\n        _write_file_bom_safe(abs_path, modified_tree.code)\n        return f\"First definition replaced in '{abs_path}'.\"",
    "file_path": "dynamic_module_3232420128943804863",
    "code_hash": "29f58e3f21dab4baf490622932b274fb",
    "globals": {
     "_convert_tool_inputs": {
      "__helper_func__": true,
      "pickled": "gASVMAAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjBRfY29udmVydF90b29sX2lucHV0c5STlC4=",
      "name": "_convert_tool_inputs",
      "hash": "8bc4aba1c7d69350a812d8553b6a7ff0cd23ae5c818f3b9533752a69e91acf2e",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "_convert_tool_inputs"
      }
     },
     "_convert_tool_output": {
      "__helper_func__": true,
      "pickled": "gASVMAAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjBRfY29udmVydF90b29sX291dHB1dJSTlC4=",
      "name": "_convert_tool_output",
      "hash": "6c85767d30db1c50646d25d2b954c893aed15774f97345f9b8c99674c59cf928",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "_convert_tool_output"
      }
     },
     "ToolExecutionError": {
      "__imported_callable__": true,
      "pickled": "gASVLgAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjBJUb29sRXhlY3V0aW9uRXJyb3KUk5Qu",
      "name": "ToolExecutionError",
      "hash": "e3f136f46cc3014d1b1a8ac6716adb9da7db1dd83f2ed8529e090d97ae0db998",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "ToolExecutionError"
      }
     },
     "ast": {
      "__module_type__": true,
      "name": "ast",
      "spec": "ast"
     },
     "datetime": {
      "__module_type__": true,
      "name": "datetime",
      "spec": "datetime"
     },
     "functools": {
      "__module_type__": true,
      "name": "functools",
      "spec": "functools"
     },
     "inspect": {
      "__module_type__": true,
      "name": "inspect",
      "spec": "inspect"
     },
     "logging": {
      "__module_type__": true,
      "name": "logging",
      "spec": "logging"
     },
     "os": {
      "__module_type__": true,
      "name": "os",
      "spec": "os"
     },
     "sys": {
      "__module_type__": true,
      "name": "sys",
      "spec": "sys"
     },
     "textwrap": {
      "__module_type__": true,
      "name": "textwrap",
      "spec": "textwrap"
     },
     "traceback": {
      "__module_type__": true,
      "name": "traceback",
      "spec": "traceback"
     },
     "wraps": {
      "__imported_callable__": true,
      "pickled": "gASVFwAAAAAAAACMCWZ1bmN0b29sc5SMBXdyYXBzlJOULg==",
      "name": "wraps",
      "hash": "4c7c8f91a978a903bce2515f7fe83cb09b7074259dabad02b312209312f718ed",
      "provenance": {
       "module": "functools",
       "qualname": "wraps"
      }
     },
     "Any": {
      "__imported_callable__": true,
      "pickled": "gASVEgAAAAAAAACMBnR5cGluZ5SMA0FueZSTlC4=",
      "name": "Any",
      "hash": "fbf19bc6bf716a555ce7094664e2bc898734e4acfc2cd6d9ee399edef2e5c02b",
      "provenance": {
       "module": "typing",
       "qualname": "Any"
      }
     },
     "Callable": {
      "__imported_callable__": true,
      "pickled": "gASVFwAAAAAAAACMBnR5cGluZ5SMCENhbGxhYmxllJOULg==",
      "name": "Callable",
      "hash": "17cf7f09b805961290dccb95aa11199df32c246cb879f355ffa1a31d6285edad",
      "provenance": {
       "module": "typing",
       "qualname": "Callable"
      }
     },
     "Optional": {
      "__imported_callable__": true,
      "pickled": "gASVFwAAAAAAAACMBnR5cGluZ5SMCE9wdGlvbmFslJOULg==",
      "name": "Optional",
      "hash": "d69b63c158dd563d1537447d9d3a68afdda0efb70794ab11c234d01e2e593e56",
      "provenance": {
       "module": "typing",
       "qualname": "Optional"
      }
     },
     "Type": {
      "__imported_callable__": true,
      "pickled": "gASVEwAAAAAAAACMBnR5cGluZ5SMBFR5cGWUk5Qu",
      "name": "Type",
      "hash": "9e98fdb991d3addb0aad6e13cd94b21998f5d97e9f30b15f9c697afe5cde1832",
      "provenance": {
       "module": "typing",
       "qualname": "Type"
      }
     },
     "remove_code_blocks": {
      "__imported_callable__": true,
      "pickled": "gASVLQAAAAAAAACMEmJvdHMudXRpbHMuaGVscGVyc5SMEnJlbW92ZV9jb2RlX2Jsb2Nrc5STlC4=",
      "name": "remove_code_blocks",
      "hash": "44524fda389310a2a28f80da99409efd110baefaa9ea50345d092a634c89fc1d",
      "provenance": {
       "module": "bots.utils.helpers",
       "qualname": "remove_code_blocks"
      }
     },
     "NoHTTPFilter": {
      "__imported_callable__": true,
      "pickled": "gASVKAAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjAxOb0hUVFBGaWx0ZXKUk5Qu",
      "name": "NoHTTPFilter",
      "hash": "9f920bc687c51afef3dea517f9b64393473ed37dac3fda0cedd01a655b483a52",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "NoHTTPFilter"
      }
     },
     "lazy_fn": {
      "__imported_callable__": true,
      "pickled": "gASVIwAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjAdsYXp5X2ZulJOULg==",
      "name": "lazy_fn",
      "hash": "a1737e2cf8adde594f0dd0b3f17ffaad4c126dcf16906e82cb07f18c13d8b7a2",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "lazy_fn"
      }
     },
     "lazy_class": {
      "__imported_callable__": true,
      "pickled": "gASVJgAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjApsYXp5X2NsYXNzlJOULg==",
      "name": "lazy_class",
      "hash": "d1883fc4e7eb2d64f47b4e90b4b6b69d0c5be0d0e3175787058ad631d122e4c6",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "lazy_class"
      }
     },
     "_get_context": {
      "__helper_func__": true,
      "pickled": "gASVKAAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjAxfZ2V0X2NvbnRleHSUk5Qu",
      "name": "_get_context",
      "hash": "979ef249cdc1f76f4020d948ffc352f7c667afb0d89f221770156eebd7717c7a",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "_get_context"
      }
     },
     "_get_py_interface": {
      "__helper_func__": true,
      "pickled": "gASVLQAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjBFfZ2V0X3B5X2ludGVyZmFjZZSTlC4=",
      "name": "_get_py_interface",
      "hash": "d45b0506fb8815e8d9c3a9217b0ca101dac4fb9f51c8546285cf68a95ab027e7",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "_get_py_interface"
      }
     },
     "lazy": {
      "__imported_callable__": true,
      "pickled": "gASVIAAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjARsYXp5lJOULg==",
      "name": "lazy",
      "hash": "6e25446d8765ac65a5518c01582ddf52784eb90c51d57e224c94823d5b7c55cd",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "lazy"
      }
     },
     "debug_on_error": {
      "__imported_callable__": true,
      "pickled": "gASVKgAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjA5kZWJ1Z19vbl9lcnJvcpSTlC4=",
      "name": "debug_on_error",
      "hash": "06d89d594519c41c1dae666437441d4fd4aeeea959f1c905694940a50ae4ddfe",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "debug_on_error"
      }
     },
     "log_errors": {
      "__imported_callable__": true,
      "pickled": "gASVJgAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjApsb2dfZXJyb3JzlJOULg==",
      "name": "log_errors",
      "hash": "f9446c0ae11aa5bb7726b83da744e8dc707a91edc91085abbca1cefd1897d829",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "log_errors"
      }
     },
     "toolify": {
      "__imported_callable__": true,
      "pickled": "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b3BlX3dpdGggaXMgc3BlY2lmaWVkKS4gQ29kZSBpcyBpbmRlbnRlZCBhdXRvbWF0aWNhbGx5CiAgICAgICAgICAgIHRvIG1hdGNoIHRvIHNjb3BlLgoKICAgICAgICBjb3Njb3BlX3dpdGggOiBzdHIsIG9wdGlvbmFsCiAgICAgICAgICAgIElmIHNwZWNpZmllZCwgY29kZSBpcyBpbnNlcnRlZCBpbiB0aGUgc2FtZSBzY29wZSBhcyB0aGUgc3BlY2lmaWVkIGNvZGUsCiAgICAgICAgICAgIGFuZCBpbW1lZGlhdGVseSBhZnRlciBpdC4gVXNlcyB0aGUgc2FtZSBzeW50YXggYXMgdGFyZ2V0X3Njb3BlIHdpdGgKICAgICAgICAgICAgb3B0aW9uYWwgZXhwcmVzc2lvbiBhdCB0aGUgZW5kIGluIHF1b3Rlcy4KCgogICAgICAgICAgICAgICAgU2NvcGU6CiAgICAgICAgICAgICAgICAgICAgLSBhCiAgICAgICAgICAgICAgICAgICAgLSBiCgogICAgICAgICAgICAgICAgLSBweXRob24gZWRpdCBjYWxsZWQgd2l0aCBjb3Njb3BlX3dpdGggPSAiYSIsIGNvZGUgPSAiLSBjIiAtCgogICAgICAgICAgICAgICAgU2NvcGU6CiAgICAgICAgICAgICAgICAgICAgLSBhCiAgICAgICAgICAgICAgICAgICAgLSBjCiAgICAgICAgICAgICAgICAgICAgLSBiCgogICAgICAgICAgICAtICJfX0ZJTEVfU1RBUlRfXyIgKHNwZWNpYWwgdG9rZW4gZm9yIGZpbGUgYmVnaW5uaW5nKQogICAgICAgICAgICAtICJNeUNsYXNzOjptZXRob2QiIChpbnNlcnQgYWZ0ZXIgdGhpcyBtZXRob2Qgd2l0aGluIHRoZSB0YXJnZXQgc2NvcGUpCiAgICAgICAgICAgIC0gJyJleHByZXNzaW9uIicgKGluc2VydCBhZnRlciBhIGxpbmUgbWF0Y2hpbmcgdGhpcyBleHByZXNzaW9uKQogICAgICAgIGRlbGV0ZV9hX2xvdCA6IGJvb2wsIG9wdGlvbmFsCiAgICAtICJfX0ZJTEVfRU5EX18iIChzcGVjaWFsIHRva2VuIGZvciBmaWxlIGVuZCkKICAgICAgICAgICAgU2FmZXR5IHBhcmFtZXRlci4gTXVzdCBiZSBUcnVlIHRvIGFsbG93IG9wZXJhdGlvbnMgdGhhdCBkZWxldGUgbW9yZSB0aGFuIDEwMCBsaW5lcy4KICAgICAgICAgICAgSGVscHMgcHJldmVudCBhY2NpZGVudGFsIGZpbGUgb3ZlcndyaXRlcy4gRGVmYXVsdCBGYWxzZS4KCiAgICAgICAgUmV0dXJuczoKICAgICAgICAtLS0tLS0tLQogICAgICAgIHN0cgogICAgICAgICAgICBEZXNjcmlwdGlvbiBvZiB3aGF0IHdhcyBtb2RpZmllZCBvciBlcnJvciBtZXNzYWdlCiAgICCUjAI6OpSMAy5weZSMHUZpbGUgcGF0aCBtdXN0IGVuZCB3aXRoIC5weToglIwJX19GSVJTVF9flIwcSW52YWxpZCBpZGVudGlmaWVyIGluIHBhdGg6IJSME0Vycm9yIHJlYWRpbmcgZmlsZSCUaLpOaL+ME0Vycm9yIHBhcnNpbmcgZmlsZSCUSwCMO0Nhbm5vdCB1c2UgZW1wdHkgY29kZSB3aXRoIGluc2VydF9hZnRlciAtIG5vdGhpbmcgdG8gaW5zZXJ0lIwPQ29kZSBhZGRlZCB0byAnlIwCJy6UjAEjlGo6AQAAhZSMGEVycm9yIHBhcnNpbmcgbmV3IGNvZGU6IJSMG0Vycm9yIHByb2Nlc3NpbmcgbmV3IGNvZGU6IJRLAYw1X19GSVJTVF9fIGNhbm5vdCBiZSBjb21iaW5lZCB3aXRoIG90aGVyIHBhdGggZWxlbWVudHOUjA5fX0ZJTEVfU1RBUlRfX5SMDF9fRklMRV9FTkRfX5SGlIwLQ2Fubm90IHVzZSCUjBUgd2l0aCBzY29wZWQgdGFyZ2V0ICeUjG8nLiBGaWxlLWxldmVsIHRva2VucyAoX19GSUxFX1NUQVJUX18sIF9fRklMRV9FTkRfXykgY2FuIG9ubHkgYmUgdXNlZCB3aXRoIGZpbGUtbGV2ZWwgdGFyZ2V0cyAoZS5nLiwgJ2ZpbGUucHknKS6UaowBAABoMmqNAQAAS2SMKlNhZmV0eSBjaGVjazogdGhpcyBvcGVyYXRpb24gd291bGQgZGVsZXRlIJSMCCBsaW5lcy4glIx9SWYgaW50ZW50aW9uYWwsIHNldCBkZWxldGVfYV9sb3Q9VHJ1ZS4gQ29uc2lkZXIgdXNpbmcgJ2luc2VydF9hZnRlcicgcGFyYW1ldGVyIHRvIGFkZCBjb2RlIHdpdGhvdXQgZGVsZXRpbmcgZXhpc3RpbmcgY29udGVudC6UjCBDb2RlIHJlcGxhY2VkIGF0IGZpbGUgbGV2ZWwgaW4gJ5SMGEluc2VydCBwb2ludCBub3QgZm91bmQ6IJSMGFRhcmdldCBzY29wZSBub3QgZm91bmQ6IJSMFUNvZGUgaW5zZXJ0ZWQgYWZ0ZXIgJ5SMBicgaW4gJ5SMEkNvZGUgcmVwbGFjZWQgYXQgJ5R0lCiMBXNwbGl0lGj4aAxowowMaXNpZGVudGlmaWVylGiyaNxqDQEAAGgbaBloqIwMcGFyc2VfbW9kdWxllGh5jAZkZWRlbnSUjBBfaGFuZGxlX2RlbGV0aW9ulGjyjApzdGFydHN3aXRolIweX2NyZWF0ZV9zdGF0ZW1lbnRfd2l0aF9jb21tZW50lGpWAQAAag4BAACMGF9oYW5kbGVfZmlyc3RfZGVmaW5pdGlvbpRqJwEAAIwcX2hhbmRsZV9maWxlX3N0YXJ0X2luc2VydGlvbpSMGl9oYW5kbGVfZmlsZV9lbmRfaW5zZXJ0aW9ulIwcX2hhbmRsZV9maWxlX2xldmVsX2luc2VydGlvbpRqCAEAAGprAQAAajYBAACMCG1vZGlmaWVklIwEY29kZZR0lCiMDHRhcmdldF9zY29wZZRqqAEAAIwMY29zY29wZV93aXRolIwMZGVsZXRlX2FfbG90lGjLakIBAACMB2VsZW1lbnSUaMxqEgEAAIwUd2FzX29yaWdpbmFsbHlfZW1wdHmUaCJqQAEAAGh5jAxjbGVhbmVkX2NvZGWUakEBAACMDGNvbW1lbnRfc3RtdJSMEWR1cGxpY2F0ZV93YXJuaW5nlGghjA9saW5lc190b19kZWxldGWUjAhyZXBsYWNlcpSMDW1vZGlmaWVkX3RyZWWUdJRoJ2pvAQAAam8BAABLT0LCBAAAgADwZAFaAQUh2CQw1yQ20SQ2sHTTJDzQCCGICZBN2A8Y1w8h0Q8hoCXUDyjcEyGkKtAvTMhZyEvQLVjTIlnTE1rQDFrbFySIR9gTGtcTJ9ETJ9UTKahnuBvTLkTcFyWkatAzT9BQV8h5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dXRzIHRvIHByb3BlciB0eXBlcyB1c2luZyB0eXBlIGhpbnRzCiAgICAtIEVuc3VyZXMgc3RyaW5nIG91dHB1dCAoSlNPTiBmb3IgY29tcGxleCB0eXBlcykKICAgIC0gV3JhcHMgaW4gZXJyb3IgaGFuZGxpbmcgKHJldHVybnMgZXJyb3Igc3RyaW5ncywgbmV2ZXIgcmFpc2VzKQogICAgLSBFbmhhbmNlcyBkb2NzdHJpbmcgaWYgZGVzY3JpcHRpb24gcHJvdmlkZWQKCiAgICBBcmdzOgogICAgICAgIGRlc2NyaXB0aW9uIChzdHIsIG9wdGlvbmFsKTogT3ZlcnJpZGUgdGhlIGZ1bmN0aW9uJ3MgZG9jc3RyaW5nCgogICAgRXhhbXBsZToKICAgICAgICBAdG9vbGlmeSgpCiAgICAgICAgZGVmIGFkZF9udW1iZXJzKHg6IGludCwgeTogaW50ID0gMCkgLT4gaW50OgogICAgICAgICAgICByZXR1cm4geCArIHkKCiAgICAgICAgQHRvb2xpZnkoIkNhbGN1bGF0ZSB0aGUgYXJlYSBvZiBhIGNpcmNsZSIpCiAgICAgICAgZGVmIGFyZWEocmFkaXVzOiBmbG9hdCkgLT4gZmxvYXQ6CiAgICAgICAgICAgIHJldHVybiAzLjE0MTU5ICogcmFkaXVzICogcmFkaXVzCiAgICAiIiIKCiAgICBkZWYgZGVjb3JhdG9yKGZ1bmMpOgogICAgICAgIEBmdW5jdG9vbHMud3JhcHMoZnVuYykKICAgICAgICBkZWYgd3JhcHBlcigqYXJncywgKiprd2FyZ3MpOgogICAgICAgICAgICB0cnk6CiAgICAgICAgICAgICAgICAjIENvbnZlcnQgc3RyaW5nIGlucHV0cyB0byBwcm9wZXIgdHlwZXMgdXNpbmcgdHlwZSBoaW50cwogICAgICAgICAgICAgICAgY29udmVydGVkX2FyZ3MsIGNvbnZlcnRlZF9rd2FyZ3MgPSBfY29udmVydF90b29sX2lucHV0cyhmdW5jLCBhcmdzLCBrd2FyZ3MpCgogICAgICAgICAgICAgICAgIyBDYWxsIG9yaWdpbmFsIGZ1bmN0aW9uCiAgICAgICAgICAgICAgICByZXN1bHQgPSBmdW5jKCpjb252ZXJ0ZWRfYXJncywgKipjb252ZXJ0ZWRfa3dhcmdzKQoKICAgICAgICAgICAgICAgICMgQ29udmVydCByZXN1bHQgdG8gc3RyaW5nCiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnZlcnRfdG9vbF9vdXRwdXQocmVzdWx0KQoKICAgICAgICAgICAgZXhjZXB0IEtleWJvYXJkSW50ZXJydXB0IGFzIGU6CiAgICAgICAgICAgICAgICAjIENvbnZlcnQgS2V5Ym9hcmRJbnRlcnJ1cHQgdG8gVG9vbEV4ZWN1dGlvbkVycm9yIHRvIHByZXZlbnQgaXQgZnJvbQogICAgICAgICAgICAgICAgIyBidWJibGluZyB1cCB0byBDTEkgYW5kIGJlaW5nIHRyZWF0ZWQgYXMgdXNlciBDdHJsK0MKICAgICAgICAgICAgICAgIGZyb20gYm90cy51dGlscy5oZWxwZXJzIGltcG9ydCBfcHJvY2Vzc19lcnJvcgoKICAgICAgICAgICAgICAgIHRvb2xfZXJyb3IgPSBUb29sRXhlY3V0aW9uRXJyb3IoZiJUb29sIGV4ZWN1dGlvbiBpbnRlcnJ1cHRlZDoge3N0cihlKX0iKQogICAgICAgICAgICAgICAgcmV0dXJuIF9wcm9jZXNzX2Vycm9yKHRvb2xfZXJyb3IpCgogICAgICAgICAgICBleGNlcHQgVHlwZUVycm9yIGFzIGU6CiAgICAgICAgICAgICAgICAjIENoZWNrIGlmIHRoaXMgaXMgYSBtaXNzaW5nIHJlcXVpcmVkIGFyZ3VtZW50IGVycm9yCiAgICAgICAgICAgICAgICBlcnJvcl9tc2cgPSBzdHIoZSkKICAgICAgICAgICAgICAgIGlmICJtaXNzaW5nIiBpbiBlcnJvcl9tc2cgYW5kICJyZXF1aXJlZCIgaW4gZXJyb3JfbXNnIGFuZCAiYXJndW1lbnQiIGluIGVycm9yX21zZzoKICAgICAgICAgICAgICAgICAgICAjIEFkZCBzcGVjaWFsIG1lc3NhZ2UgZm9yIG91dHB1dCB0b2tlbiBsaW1pdGF0aW9uCiAgICAgICAgICAgICAgICAgICAgZW5oYW5jZWRfZXJyb3IgPSBUeXBlRXJyb3IoCiAgICAgICAgICAgICAgICAgICAgICAgIGYie2Vycm9yX21zZ31cblxuIgogICAgICAgICAgICAgICAgICAgICAgICBmIuKaoO+4jyAgVGhpcyBlcnJvciBpcyBjb21tb25seSBjYXVzZWQgYnkgaGl0dGluZyB0aGUgbWF4X3Rva2VucyBsaW1pdCBiZWZvcmUgY29tcGxldGluZyB0aGUgdG9vbCBjYWxsLlxuIgogICAgICAgICAgICAgICAgICAgICAgICBmIlRoZSByZXNwb25zZSB3YXMgdHJ1bmNhdGVkIG1pZC1wYXJhbWV0ZXIsIG1ha2luZyBpdCBhcHBlYXIgdGhhdCByZXF1aXJlZCBwYXJhbWV0ZXJzIGFyZSBtaXNzaW5nLlxuIgogICAgICAgICAgICAgICAgICAgICAgICBmIlRvIGZpeCB0aGlzOiBXb3JrIGluIFNNQUxMRVIgQ0hVTktTLiBFZGl0IGZld2VyIGxpbmVzIGF0IGEgdGltZSwgIgogICAgICAgICAgICAgICAgICAgICAgICBmIm9yIGJyZWFrIHlvdXIgdGFzayBpbnRvIG11bHRpcGxlIHN0ZXBzLiIKICAgICAgICAgICAgICAgICAgICApCiAgICAgICAgICAgICAgICAgICAgZnJvbSBib3RzLnV0aWxzLmhlbHBlcnMgaW1wb3J0IF9wcm9jZXNzX2Vycm9yCgogICAgICAgICAgICAgICAgICAgIHJldHVybiBfcHJvY2Vzc19lcnJvcihlbmhhbmNlZF9lcnJvcikKICAgICAgICAgICAgICAgIGVsc2U6CiAgICAgICAgICAgICAgICAgICAgZnJvbSBib3RzLnV0aWxzLmhlbHBlcnMgaW1wb3J0IF9wcm9jZXNzX2Vycm9yCgogICAgICAgICAgICAgICAgICAgIHJldHVybiBfcHJvY2Vzc19lcnJvcihlKQogICAgICAgICAgICBleGNlcHQgRXhjZXB0aW9uIGFzIGU6CiAgICAgICAgICAgICAgICBmcm9tIGJvdHMudXRpbHMuaGVscGVycyBpbXBvcnQgX3Byb2Nlc3NfZXJyb3IKCiAgICAgICAgICAgICAgICByZXR1cm4gX3Byb2Nlc3NfZXJyb3IoZSkKCiAgICAgICAgIyBVcGRhdGUgZG9jc3RyaW5nIGlmIGRlc2NyaXB0aW9uIHByb3ZpZGVkCiAgICAgICAgaWYgZGVzY3JpcHRpb246CiAgICAgICAgICAgIHdyYXBwZXIuX19kb2NfXyA9IGRlc2NyaXB0aW9uCiAgICAgICAgZWxpZiBub3Qgd3JhcHBlci5fX2RvY19fOgogICAgICAgICAgICAjIEdlbmVyYXRlIG1pbmltYWwgZG9jc3RyaW5nIGZyb20gZnVuY3Rpb24gbmFtZQogICAgICAgICAgICB3cmFwcGVyLl9fZG9jX18gPSBmIkV4ZWN1dGUge2Z1bmMuX19uYW1lX18ucmVwbGFjZSgnXycsICcgJyl9IgoKICAgICAgICByZXR1cm4gd3JhcHBlcgoKICAgIHJldHVybiBkZWNvcmF0b3IKCkB0b29saWZ5KCkKZGVmIHB5dGhvbl9lZGl0KHRhcmdldF9zY29wZTogc3RyLCBjb2RlOiBzdHIsICosIGNvc2NvcGVfd2l0aDogc3RyPU5vbmUsIGRlbGV0ZV9hX2xvdDogYm9vbD1GYWxzZSkgLT4gc3RyOgogICAgIiIiCiAgICAgICAgRWRpdCBQeXRob24gY29kZSB1c2luZyBweXRlc3Qtc3R5bGUgc2NvcGUgc3ludGF4IGFuZCBvcHRpb25hbCBleHByZXNzaW9uIG1hdGNoaW5nLgoKICAgICAgICBQYXJhbWV0ZXJzOgogICAgICAgIC0tLS0tLS0tLS0tCiAgICAgICAgdGFyZ2V0X3Njb3BlIDogc3RyCiAgICAgICAgICAgIExvY2F0aW9uIHRvIGVkaXQgaW4gcHl0ZXN0LXN0eWxlIHNjb3BlIHN5bnRheDoKICAgICAgICAgICAgLSAiZmlsZS5weSIgKHdob2xlIGZpbGUpCiAgICAgICAgICAgIC0gImZpbGUucHk6Ok15Q2xhc3MiIChjbGFzcykKICAgICAgICAgICAgLSAiZmlsZS5weTo6bXlfZnVuY3Rpb24iIChmdW5jdGlvbikKICAgICAgICAgICAgLSAiZmlsZS5weTo6TXlDbGFzczo6bWV0aG9kIiAobWV0aG9kKQogICAgICAgICAgICAtICJmaWxlLnB5OjpfX0ZJUlNUX18iIChmaXJzdCB0b3AtbGV2ZWwgZGVmaW5pdGlvbikKCiAgICAgICAgY29kZSA6IHN0cgogICAgICAgICAgICBQeXRob24gY29kZS4gVGhpcyBjb2RlIHdpbGwgcmVwbGFjZSB0aGUgZW50aXJlIHRhcmdldCBzY29wZSBieSBkZWZhdWx0LAogICAgICAgICAgICBvciBpbnNlcnQgYWZ0ZXIgKGlmIGNvc2NvcGVfd2l0aCBpcyBzcGVjaWZpZWQpLiBDb2RlIGlzIGluZGVudGVkIGF1dG9tYXRpY2FsbHkKICAgICAgICAgICAgdG8gbWF0Y2ggdG8gc2NvcGUuCgogICAgICAgIGNvc2NvcGVfd2l0aCA6IHN0ciwgb3B0aW9uYWwKICAgICAgICAgICAgSWYgc3BlY2lmaWVkLCBjb2RlIGlzIGluc2VydGVkIGluIHRoZSBzYW1lIHNjb3BlIGFzIHRoZSBzcGVjaWZpZWQgY29kZSwKICAgICAgICAgICAgYW5kIGltbWVkaWF0ZWx5IGFmdGVyIGl0LiBVc2VzIHRoZSBzYW1lIHN5bnRheCBhcyB0YXJnZXRfc2NvcGUgd2l0aAogICAgICAgICAgICBvcHRpb25hbCBleHByZXNzaW9uIGF0IHRoZSBlbmQgaW4gcXVvdGVzLgoKCiAgICAgICAgICAgICAgICBTY29wZToKICAgICAgICAgICAgICAgICAgICAtIGEKICAgICAgICAgICAgICAgICAgICAtIGIKCiAgICAgICAgICAgICAgICAtIHB5dGhvbiBlZGl0IGNhbGxlZCB3aXRoIGNvc2NvcGVfd2l0aCA9ICJhIiwgY29kZSA9ICItIGMiIC0KCiAgICAgICAgICAgICAgICBTY29wZToKICAgICAgICAgICAgICAgICAgICAtIGEKICAgICAgICAgICAgICAgICAgICAtIGMKICAgICAgICAgICAgICAgICAgICAtIGIKCiAgICAgICAgICAgIC0gIl9fRklMRV9TVEFSVF9fIiAoc3BlY2lhbCB0b2tlbiBmb3IgZmlsZSBiZWdpbm5pbmcpCiAgICAgICAgICAgIC0gIk15Q2xhc3M6Om1ldGhvZCIgKGluc2VydCBhZnRlciB0aGlzIG1ldGhvZCB3aXRoaW4gdGhlIHRhcmdldCBzY29wZSkKICAgICAgICAgICAgLSAnImV4cHJlc3Npb24iJyAoaW5zZXJ0IGFmdGVyIGEgbGluZSBtYXRjaGluZyB0aGlzIGV4cHJlc3Npb24pCiAgICAgICAgZGVsZXRlX2FfbG90IDogYm9vbCwgb3B0aW9uYWwKICAgIC0gIl9fRklMRV9FTkRfXyIgKHNwZWNpYWwgdG9rZW4gZm9yIGZpbGUgZW5kKQogICAgICAgICAgICBTYWZldHkgcGFyYW1ldGVyLiBNdXN0IGJlIFRydWUgdG8gYWxsb3cgb3BlcmF0aW9ucyB0aGF0IGRlbGV0ZSBtb3JlIHRoYW4gMTAwIGxpbmVzLgogICAgICAgICAgICBIZWxwcyBwcmV2ZW50IGFjY2lkZW50YWwgZmlsZSBvdmVyd3JpdGVzLiBEZWZhdWx0IEZhbHNlLgoKICAgICAgICBSZXR1cm5zOgogICAgICAgIC0tLS0tLS0tCiAgICAgICAgc3RyCiAgICAgICAgICAgIERlc2NyaXB0aW9uIG9mIHdoYXQgd2FzIG1vZGlmaWVkIG9yIGVycm9yIG1lc3NhZ2UKICAgICIiIgogICAgdHJ5OgogICAgICAgIGZpbGVfcGF0aCwgKnBhdGhfZWxlbWVudHMgPSB0YXJnZXRfc2NvcGUuc3BsaXQoJzo6JykKICAgICAgICBpZiBub3QgZmlsZV9wYXRoLmVuZHN3aXRoKCcucHknKToKICAgICAgICAgICAgcmV0dXJuIF9wcm9jZXNzX2Vycm9yKFZhbHVlRXJyb3IoZidGaWxlIHBhdGggbXVzdCBlbmQgd2l0aCAucHk6IHtmaWxlX3BhdGh9JykpCiAgICAgICAgZm9yIGVsZW1lbnQgaW4gcGF0aF9lbGVtZW50czoKICAgICAgICAgICAgaWYgbm90IGVsZW1lbnQuaXNpZGVudGlmaWVyKCkgYW5kIGVsZW1lbnQgIT0gJ19fRklSU1RfXyc6CiAgICAgICAgICAgICAgICByZXR1cm4gX3Byb2Nlc3NfZXJyb3IoVmFsdWVFcnJvcihmJ0ludmFsaWQgaWRlbnRpZmllciBpbiBwYXRoOiB7ZWxlbWVudH0nKSkKICAgICAgICBhYnNfcGF0aCA9IF9tYWtlX2ZpbGUoZmlsZV9wYXRoKQogICAgICAgIHRyeToKICAgICAgICAgICAgb3JpZ2luYWxfY29udGVudCA9IF9yZWFkX2ZpbGVfYm9tX3NhZmUoYWJzX3BhdGgpCiAgICAgICAgICAgIHdhc19vcmlnaW5hbGx5X2VtcHR5ID0gbm90IG9yaWdpbmFsX2NvbnRlbnQuc3RyaXAoKQogICAgICAgIGV4Y2VwdCBFeGNlcHRpb24gYXMgZToKICAgICAgICAgICAgcmV0dXJuIF9wcm9jZXNzX2Vycm9yKFZhbHVlRXJyb3IoZidFcnJvciByZWFkaW5nIGZpbGUge2Fic19wYXRofToge3N0cihlKX0nKSkKICAgICAgICB0cnk6CiAgICAgICAgICAgIGlmIG9yaWdpbmFsX2NvbnRlbnQuc3RyaXAoKToKICAgICAgICAgICAgICAgIHRyZWUgPSBjc3QucGFyc2VfbW9kdWxlKG9yaWdpbmFsX2NvbnRlbnQpCiAgICAgICAgICAgIGVsc2U6CiAgICAgICAgICAgICAgICB0cmVlID0gY3N0LnBhcnNlX21vZHVsZSgnJykKICAgICAgICBleGNlcHQgRXhjZXB0aW9uIGFzIGU6CiAgICAgICAgICAgIHJldHVybiBfcHJvY2Vzc19lcnJvcihWYWx1ZUVycm9yKGYnRXJyb3IgcGFyc2luZyBmaWxlIHthYnNfcGF0aH06IHtzdHIoZSl9JykpCiAgICAgICAgdHJ5OgogICAgICAgICAgICBpbXBvcnQgdGV4dHdyYXAKICAgICAgICAgICAgY2xlYW5lZF9jb2RlID0gdGV4dHdyYXAuZGVkZW50KGNvZGUpLnN0cmlwKCkKICAgICAgICAgICAgaWYgbm90IGNsZWFuZWRfY29kZToKICAgICAgICAgICAgICAgIGlmIGNvc2NvcGVfd2l0aDoKICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3Byb2Nlc3NfZXJyb3IoVmFsdWVFcnJvcignQ2Fubm90IHVzZSBlbXB0eSBjb2RlIHdpdGggaW5zZXJ0X2FmdGVyIC0gbm90aGluZyB0byBpbnNlcnQnKSkKICAgICAgICAgICAgICAgIHJldHVybiBfaGFuZGxlX2RlbGV0aW9uKGFic19wYXRoLCB0YXJnZXRfc2NvcGUsIHBhdGhfZWxlbWVudHMsIG9yaWdpbmFsX2NvbnRlbnQsIHRyZWUsIGRlbGV0ZV9hX2xvdCkKICAgICAgICAgICAgZWxpZiB3YXNfb3JpZ2luYWxseV9lbXB0eSBhbmQgKG5vdCBwYXRoX2VsZW1lbnRzKToKICAgICAgICAgICAgICAgIF93cml0ZV9maWxlX2JvbV9zYWZlKGFic19wYXRoLCBjbGVhbmVkX2NvZGUpCiAgICAgICAgICAgICAgICByZXR1cm4gZiJDb2RlIGFkZGVkIHRvICd7YWJzX3BhdGh9Jy4iCiAgICAgICAgICAgIG5ld19tb2R1bGUgPSBOb25lCiAgICAgICAgICAgIGlmIGNsZWFuZWRfY29kZToKICAgICAgICAgICAgICAgIHRyeToKICAgICAgICAgICAgICAgICAgICBuZXdfbW9kdWxlID0gY3N0LnBhcnNlX21vZHVsZShjbGVhbmVkX2NvZGUpCiAgICAgICAgICAgICAgICBleGNlcHQgRXhjZXB0aW9uIGFzIGU6CiAgICAgICAgICAgICAgICAgICAgaWYgY2xlYW5lZF9jb2RlLnN0cmlwKCkuc3RhcnRzd2l0aCgnIycpOgogICAgICAgICAgICAgICAgICAgICAgICBjb21tZW50X3N0bXQgPSBfY3JlYXRlX3N0YXRlbWVudF93aXRoX2NvbW1lbnQoY2xlYW5lZF9jb2RlLnN0cmlwKCkpCiAgICAgICAgICAgICAgICAgICAgICAgIG5ld19tb2R1bGUgPSBjc3QuTW9kdWxlKGJvZHk9W2NvbW1lbnRfc3RtdF0pCiAgICAgICAgICAgICAgICAgICAgZWxzZToKICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9wcm9jZXNzX2Vycm9yKFZhbHVlRXJyb3IoZidFcnJvciBwYXJzaW5nIG5ldyBjb2RlOiB7c3RyKGUpfScpKQogICAgICAgIGV4Y2VwdCBFeGNlcHRpb24gYXMgZToKICAgICAgICAgICAgcmV0dXJuIF9wcm9jZXNzX2Vycm9yKFZhbHVlRXJyb3IoZidFcnJvciBwcm9jZXNzaW5nIG5ldyBjb2RlOiB7c3RyKGUpfScpKQogICAgICAgIGlmIHBhdGhfZWxlbWVudHMgYW5kIHBhdGhfZWxlbWVudHNbMF0gPT0gJ19fRklSU1RfXyc6CiAgICAgICAgICAgIGlmIGxlbihwYXRoX2VsZW1lbnRzKSA+IDE6CiAgICAgICAgICAgICAgICByZXR1cm4gX3Byb2Nlc3NfZXJyb3IoVmFsdWVFcnJvcignX19GSVJTVF9fIGNhbm5vdCBiZSBjb21iaW5lZCB3aXRoIG90aGVyIHBhdGggZWxlbWVudHMnKSkKICAgICAgICAgICAgcmV0dXJuIF9oYW5kbGVfZmlyc3RfZGVmaW5pdGlvbihhYnNfcGF0aCwgdHJlZSwgbmV3X21vZHVsZSwgY29zY29wZV93aXRoKQogICAgICAgIGR1cGxpY2F0ZV93YXJuaW5nID0gTm9uZQogICAgICAgIGlmIGNvc2NvcGVfd2l0aCBhbmQgbmV3X21vZHVsZToKICAgICAgICAgICAgZHVwbGljYXRlX3dhcm5pbmcgPSBfY2hlY2tfZm9yX2R1cGxpY2F0ZXModHJlZSwgbmV3X21vZHVsZSwgcGF0aF9lbGVtZW50cykKICAgICAgICBpZiBjb3Njb3BlX3dpdGggaW4gKCdfX0ZJTEVfU1RBUlRfXycsICdfX0ZJTEVfRU5EX18nKSBhbmQgcGF0aF9lbGVtZW50czoKICAgICAgICAgICAgcmV0dXJuIF9wcm9jZXNzX2Vycm9yKFZhbHVlRXJyb3IoZiJDYW5ub3QgdXNlIHtjb3Njb3BlX3dpdGh9IHdpdGggc2NvcGVkIHRhcmdldCAne3RhcmdldF9zY29wZX0nLiBGaWxlLWxldmVsIHRva2VucyAoX19GSUxFX1NUQVJUX18sIF9fRklMRV9FTkRfXykgY2FuIG9ubHkgYmUgdXNlZCB3aXRoIGZpbGUtbGV2ZWwgdGFyZ2V0cyAoZS5nLiwgJ2ZpbGUucHknKS4iKSkKICAgICAgICBpZiBjb3Njb3BlX3dpdGggPT0gJ19fRklMRV9TVEFSVF9fJzoKICAgICAgICAgICAgcmVzdWx0ID0gX2hhbmRsZV9maWxlX3N0YXJ0X2luc2VydGlvbihhYnNfcGF0aCwgdHJlZSwgbmV3X21vZHVsZSkKICAgICAgICAgICAgaWYgZHVwbGljYXRlX3dhcm5pbmc6CiAgICAgICAgICAgICAgICByZXN1bHQgPSBkdXBsaWNhdGVfd2FybmluZyArICcgJyArIHJlc3VsdAogICAgICAgICAgICByZXR1cm4gcmVzdWx0CiAgICAgICAgZWxpZiBjb3Njb3BlX3dpdGggPT0gJ19fRklMRV9FTkRfXyc6CiAgICAgICAgICAgIHJlc3VsdCA9IF9oYW5kbGVfZmlsZV9lbmRfaW5zZXJ0aW9uKGFic19wYXRoLCB0cmVlLCBuZXdfbW9kdWxlKQogICAgICAgICAgICBpZiBkdXBsaWNhdGVfd2FybmluZzoKICAgICAgICAgICAgICAgIHJlc3VsdCA9IGR1cGxpY2F0ZV93YXJuaW5nICsgJyAnICsgcmVzdWx0CiAgICAgICAgICAgIHJldHVybiByZXN1bHQKICAgICAgICBlbGlmIG5vdCBwYXRoX2VsZW1lbnRzOgogICAgICAgICAgICBpZiBjb3Njb3BlX3dpdGg6CiAgICAgICAgICAgICAgICByZXN1bHQgPSBfaGFuZGxlX2ZpbGVfbGV2ZWxfaW5zZXJ0aW9uKGFic19wYXRoLCB0cmVlLCBuZXdfbW9kdWxlLCBjb3Njb3BlX3dpdGgpCiAgICAgICAgICAgICAgICBpZiBkdXBsaWNhdGVfd2FybmluZzoKICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBkdXBsaWNhdGVfd2FybmluZyArICcgJyArIHJlc3VsdAogICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdAogICAgICAgICAgICBlbHNlOgogICAgICAgICAgICAgICAgbGluZXNfdG9fZGVsZXRlID0gX2NvdW50X2xpbmVzX3RvX2JlX2RlbGV0ZWQob3JpZ2luYWxfY29udGVudCwgY2xlYW5lZF9jb2RlKQogICAgICAgICAgICAgICAgaWYgbGluZXNfdG9fZGVsZXRlID4gMTAwIGFuZCAobm90IGRlbGV0ZV9hX2xvdCk6CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9wcm9jZXNzX2Vycm9yKFZhbHVlRXJyb3IoZidTYWZldHkgY2hlY2s6IHRoaXMgb3BlcmF0aW9uIHdvdWxkIGRlbGV0ZSB7bGluZXNfdG9fZGVsZXRlfSBsaW5lcy4gJyArICJJZiBpbnRlbnRpb25hbCwgc2V0IGRlbGV0ZV9hX2xvdD1UcnVlLiBDb25zaWRlciB1c2luZyAnaW5zZXJ0X2FmdGVyJyBwYXJhbWV0ZXIgdG8gYWRkIGNvZGUgd2l0aG91dCBkZWxldGluZyBleGlzdGluZyBjb250ZW50LiIpKQogICAgICAgICAgICAgICAgX3dyaXRlX2ZpbGVfYm9tX3NhZmUoYWJzX3BhdGgsIGNsZWFuZWRfY29kZSkKICAgICAgICAgICAgICAgIHJldHVybiBmIkNvZGUgcmVwbGFjZWQgYXQgZmlsZSBsZXZlbCBpbiAne2Fic19wYXRofScuIgogICAgICAgIGVsc2U6CiAgICAgICAgICAgIHJlcGxhY2VyID0gU2NvcGVSZXBsYWNlcihwYXRoX2VsZW1lbnRzLCBuZXdfbW9kdWxlLCBjb3Njb3BlX3dpdGgsIHRyZWUpCiAgICAgICAgICAgIG1vZGlmaWVkX3RyZWUgPSB0cmVlLnZpc2l0KHJlcGxhY2VyKQogICAgICAgICAgICBpZiBub3QgcmVwbGFjZXIubW9kaWZpZWQ6CiAgICAgICAgICAgICAgICBpZiBjb3Njb3BlX3dpdGg6CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9wcm9jZXNzX2Vycm9yKFZhbHVlRXJyb3IoZidJbnNlcnQgcG9pbnQgbm90IGZvdW5kOiB7Y29zY29wZV93aXRofScpKQogICAgICAgICAgICAgICAgZWxzZToKICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3Byb2Nlc3NfZXJyb3IoVmFsdWVFcnJvcihmJ1RhcmdldCBzY29wZSBub3QgZm91bmQ6IHt0YXJnZXRfc2NvcGV9JykpCiAgICAgICAgICAgIF93cml0ZV9maWxlX2JvbV9zYWZlKGFic19wYXRoLCBtb2RpZmllZF90cmVlLmNvZGUpCiAgICAgICAgICAgIGlmIGNvc2NvcGVfd2l0aDoKICAgICAgICAgICAgICAgIHJlc3VsdCA9IGYiQ29kZSBpbnNlcnRlZCBhZnRlciAne2Nvc2NvcGVfd2l0aH0nIGluICd7YWJzX3BhdGh9Jy4iCiAgICAgICAgICAgICAgICBpZiBkdXBsaWNhdGVfd2FybmluZzoKICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBkdXBsaWNhdGVfd2FybmluZyArICcgJyArIHJlc3VsdAogICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdAogICAgICAgICAgICBlbHNlOgogICAgICAgICAgICAgICAgcmV0dXJuIGYiQ29kZSByZXBsYWNlZCBhdCAne3RhcmdldF9zY29wZX0nLiIKICAgIGV4Y2VwdCBFeGNlcHRpb24gYXMgZToKICAgICAgICByZXR1cm4gX3Byb2Nlc3NfZXJyb3IoZSkKCmRlZiBfaGFuZGxlX2ZpbGVfc3RhcnRfaW5zZXJ0aW9uKGFic19wYXRoOiBzdHIsIHRyZWU6IGNzdC5Nb2R1bGUsIG5ld19tb2R1bGU6IGNzdC5Nb2R1bGUpIC0+IHN0cjoKICAgICIiIkhhbmRsZSBpbnNlcnRpb24gYXQgdGhlIGJlZ2lubmluZyBvZiBhIGZpbGUsIGF2b2lkaW5nIGR1cGxpY2F0ZSBpbXBvcnRzLiIiIgogICAgZXhpc3RpbmdfaW1wb3J0cyA9IHNldCgpCiAgICBmb3Igc3RtdCBpbiB0cmVlLmJvZHk6CiAgICAgICAgaWYgaXNpbnN0YW5jZShzdG10LCAoY3N0LlNpbXBsZVN0YXRlbWVudExpbmUsKSk6CiAgICAgICAgICAgIGZvciBzIGluIHN0bXQuYm9keToKICAgICAgICAgICAgICAgIGlmIGlzaW5zdGFuY2UocywgY3N0LkltcG9ydCk6CiAgICAgICAgICAgICAgICAgICAgZm9yIG5hbWUgaW4gcy5uYW1lczoKICAgICAgICAgICAgICAgICAgICAgICAgaWYgaXNpbnN0YW5jZShuYW1lLCBjc3QuSW1wb3J0QWxpYXMpOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1wb3J0X25hbWUgPSBfZ2V0X21vZHVsZV9uYW1lKG5hbWUubmFtZSkKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nX2ltcG9ydHMuYWRkKCgnaW1wb3J0JywgaW1wb3J0X25hbWUpKQogICAgICAgICAgICAgICAgZWxpZiBpc2luc3RhbmNlKHMsIGNzdC5JbXBvcnRGcm9tKToKICAgICAgICAgICAgICAgICAgICBpZiBzLm1vZHVsZToKICAgICAgICAgICAgICAgICAgICAgICAgbW9kdWxlX25hbWUgPSBfZ2V0X21vZHVsZV9uYW1lKHMubW9kdWxlKQogICAgICAgICAgICAgICAgICAgICAgICBmb3IgbmFtZSBpbiBzLm5hbWVzOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgaXNpbnN0YW5jZShuYW1lLCBjc3QuSW1wb3J0QWxpYXMpOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltcG9ydGVkX25hbWUgPSBfZ2V0X21vZHVsZV9uYW1lKG5hbWUubmFtZSkKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZ19pbXBvcnRzLmFkZCgoJ2Zyb20nLCBtb2R1bGVfbmFtZSwgaW1wb3J0ZWRfbmFtZSkpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGlmIGlzaW5zdGFuY2UobmFtZSwgY3N0LkltcG9ydFN0YXIpOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nX2ltcG9ydHMuYWRkKCgnZnJvbScsIG1vZHVsZV9uYW1lLCAnKicpKQogICAgbmV3X2JvZHkgPSBbXQogICAgZm9yIHN0bXQgaW4gbmV3X21vZHVsZS5ib2R5OgogICAgICAgIGlmIGlzaW5zdGFuY2Uoc3RtdCwgKGNzdC5TaW1wbGVTdGF0ZW1lbnRMaW5lLCkpOgogICAgICAgICAgICBmaWx0ZXJlZF9pbXBvcnRzID0gW10KICAgICAgICAgICAgbm9uX2ltcG9ydF9zdG10cyA9IFtdCiAgICAgICAgICAgIGZvciBzIGluIHN0bXQuYm9keToKICAgICAgICAgICAgICAgIGlmIGlzaW5zdGFuY2UocywgY3N0LkltcG9ydCk6CiAgICAgICAgICAgICAgICAgICAgbmV3X25hbWVzID0gW10KICAgICAgICAgICAgICAgICAgICBmb3IgbmFtZSBpbiBzLm5hbWVzOgogICAgICAgICAgICAgICAgICAgICAgICBpZiBpc2luc3RhbmNlKG5hbWUsIGNzdC5JbXBvcnRBbGlhcyk6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbXBvcnRfbmFtZSA9IF9nZXRfbW9kdWxlX25hbWUobmFtZS5uYW1lKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCdpbXBvcnQnLCBpbXBvcnRfbmFtZSkgbm90IGluIGV4aXN0aW5nX2ltcG9ydHM6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3X25hbWVzLmFwcGVuZChuYW1lKQogICAgICAgICAgICAgICAgICAgIGlmIG5ld19uYW1lczoKICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyZWRfaW1wb3J0cy5hcHBlbmQocy53aXRoX2NoYW5nZXMobmFtZXM9bmV3X25hbWVzKSkKICAgICAgICAgICAgICAgIGVsaWYgaXNpbnN0YW5jZShzLCBjc3QuSW1wb3J0RnJvbSk6CiAgICAgICAgICAgICAgICAgICAgaWYgcy5tb2R1bGU6CiAgICAgICAgICAgICAgICAgICAgICAgIG1vZHVsZV9uYW1lID0gX2dldF9tb2R1bGVfbmFtZShzLm1vZHVsZSkKICAgICAgICAgICAgICAgICAgICAgICAgbmV3X25hbWVzID0gW10KICAgICAgICAgICAgICAgICAgICAgICAgZm9yIG5hbWUgaW4gcy5uYW1lczoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIGlzaW5zdGFuY2UobmFtZSwgY3N0LkltcG9ydEFsaWFzKToKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbXBvcnRlZF9uYW1lID0gX2dldF9tb2R1bGVfbmFtZShuYW1lLm5hbWUpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCdmcm9tJywgbW9kdWxlX25hbWUsIGltcG9ydGVkX25hbWUpIG5vdCBpbiBleGlzdGluZ19pbXBvcnRzOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdfbmFtZXMuYXBwZW5kKG5hbWUpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGlmIGlzaW5zdGFuY2UobmFtZSwgY3N0LkltcG9ydFN0YXIpOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgnZnJvbScsIG1vZHVsZV9uYW1lLCAnKicpIG5vdCBpbiBleGlzdGluZ19pbXBvcnRzOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdfbmFtZXMuYXBwZW5kKG5hbWUpCiAgICAgICAgICAgICAgICAgICAgICAgIGlmIG5ld19uYW1lczoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlcmVkX2ltcG9ydHMuYXBwZW5kKHMud2l0aF9jaGFuZ2VzKG5hbWVzPW5ld19uYW1lcykpCiAgICAgICAgICAgICAgICBlbHNlOgogICAgICAgICAgICAgICAgICAgIG5vbl9pbXBvcnRfc3RtdHMuYXBwZW5kKHMpCiAgICAgICAgICAgIGlmIGZpbHRlcmVkX2ltcG9ydHMgb3Igbm9uX2ltcG9ydF9zdG10czoKICAgICAgICAgICAgICAgIG5ld19ib2R5LmFwcGVuZChzdG10LndpdGhfY2hhbmdlcyhib2R5PWZpbHRlcmVkX2ltcG9ydHMgKyBub25faW1wb3J0X3N0bXRzKSkKICAgICAgICBlbHNlOgogICAgICAgICAgICBuZXdfYm9keS5hcHBlbmQoc3RtdCkKICAgIGNvbWJpbmVkX2JvZHkgPSBuZXdfYm9keSArIGxpc3QodHJlZS5ib2R5KQogICAgbW9kaWZpZWRfdHJlZSA9IHRyZWUud2l0aF9jaGFuZ2VzKGJvZHk9Y29tYmluZWRfYm9keSkKICAgIF93cml0ZV9maWxlX2JvbV9zYWZlKGFic19wYXRoLCBtb2RpZmllZF90cmVlLmNvZGUpCiAgICByZXR1cm4gZiJDb2RlIGluc2VydGVkIGF0IHN0YXJ0IG9mICd7YWJzX3BhdGh9JyAoZHVwbGljYXRlIGltcG9ydHMgZmlsdGVyZWQpLiIKCmRlZiBfcmVhZF9maWxlX2JvbV9zYWZlKGZpbGVfcGF0aDogc3RyKSAtPiBzdHI6CiAgICAiIiJSZWFkIGEgZmlsZSB3aXRoIEJPTSBwcm90ZWN0aW9uLiIiIgogICAgd2l0aCBvcGVuKGZpbGVfcGF0aCwgJ3InLCBlbmNvZGluZz0ndXRmLTgnKSBhcyBmaWxlOgogICAgICAgIGNvbnRlbnQgPSBmaWxlLnJlYWQoKQogICAgcmV0dXJuIGNsZWFuX3VuaWNvZGVfc3RyaW5nKGNvbnRlbnQpCgpkZWYgX2hhbmRsZV9maWxlX2VuZF9pbnNlcnRpb24oYWJzX3BhdGg6IHN0ciwgdHJlZTogY3N0Lk1vZHVsZSwgbmV3X21vZHVsZTogY3N0Lk1vZHVsZSkgLT4gc3RyOgogICAgIiIiSGFuZGxlIGluc2VydGlvbiBhdCB0aGUgZW5kIG9mIGEgZmlsZS4iIiIKICAgIGlmIGxlbihuZXdfbW9kdWxlLmJvZHkpID09IDAgYW5kIG5ld19tb2R1bGUuY29kZS5zdHJpcCgpOgogICAgICAgIGNvbW1lbnRfc3RtdCA9IF9jcmVhdGVfc3RhdGVtZW50X3dpdGhfY29tbWVudChuZXdfbW9kdWxlLmNvZGUuc3RyaXAoKSkKICAgICAgICBuZXdfYm9keSA9IGxpc3QodHJlZS5ib2R5KSArIFtjb21tZW50X3N0bXRdCiAgICBlbHNlOgogICAgICAgIG5ld19ib2R5ID0gbGlzdCh0cmVlLmJvZHkpICsgbGlzdChuZXdfbW9kdWxlLmJvZHkpCiAgICBtb2RpZmllZF90cmVlID0gdHJlZS53aXRoX2NoYW5nZXMoYm9keT1uZXdfYm9keSkKICAgIGZpbmFsX2NvZGUgPSBtb2RpZmllZF90cmVlLmNvZGUKICAgIGlmIGZpbmFsX2NvZGUgYW5kIChub3QgZmluYWxfY29kZS5lbmRzd2l0aCgnXG4nKSk6CiAgICAgICAgZmluYWxfY29kZSArPSAnXG4nCiAgICBfd3JpdGVfZmlsZV9ib21fc2FmZShhYnNfcGF0aCwgZmluYWxfY29kZSkKICAgIHJldHVybiBmIkNvZGUgaW5zZXJ0ZWQgYXQgZW5kIG9mICd7YWJzX3BhdGh9Jy4iCgpkZWYgX2NoZWNrX2Zvcl9kdXBsaWNhdGVzKHRyZWU6IGNzdC5Nb2R1bGUsIG5ld19tb2R1bGU6IGNzdC5Nb2R1bGUsIHBhdGhfZWxlbWVudHM6IExpc3Rbc3RyXSkgLT4gT3B0aW9uYWxbc3RyXToKICAgICIiIgogICAgQ2hlY2sgaWYgbmV3IGNvZGUgd291bGQgY3JlYXRlIGR1cGxpY2F0ZSBkZWZpbml0aW9ucy4KCiAgICBSZXR1cm5zOgogICAgICAgIE9wdGlvbmFsW3N0cl06IFdhcm5pbmcgbWVzc2FnZSBpZiBkdXBsaWNhdGVzIGZvdW5kLCBOb25lIG90aGVyd2lzZQogICAgIiIiCiAgICBuZXdfbmFtZXMgPSBfZXh0cmFjdF9kZWZpbml0aW9uX25hbWVzKG5ld19tb2R1bGUpCiAgICBpZiBub3QgbmV3X25hbWVzOgogICAgICAgIHJldHVybiBOb25lCiAgICBpZiBub3QgcGF0aF9lbGVtZW50czoKICAgICAgICBleGlzdGluZ19uYW1lcyA9IF9leHRyYWN0X2RlZmluaXRpb25fbmFtZXModHJlZSkKICAgICAgICBkdXBsaWNhdGVzID0gc2V0KG5ld19uYW1lcykgJiBzZXQoZXhpc3RpbmdfbmFtZXMpCiAgICAgICAgaWYgZHVwbGljYXRlczoKICAgICAgICAgICAgZHVwX2xpc3QgPSAnLCAnLmpvaW4oc29ydGVkKGR1cGxpY2F0ZXMpKQogICAgICAgICAgICByZXR1cm4gZidXYXJuaW5nOiBBZGRpbmcgZHVwbGljYXRlIGRlZmluaXRpb24ocyk6IHtkdXBfbGlzdH0uIFRoaXMgd2lsbCBjcmVhdGUgbXVsdGlwbGUgZGVmaW5pdGlvbnMgd2l0aCB0aGUgc2FtZSBuYW1lLicKICAgIGVsc2U6CiAgICAgICAgZmluZGVyID0gU2NvcGVGaW5kZXIocGF0aF9lbGVtZW50cykKICAgICAgICB0cmVlLnZpc2l0KGZpbmRlcikKICAgICAgICBpZiBmaW5kZXIudGFyZ2V0X25vZGUgYW5kIGlzaW5zdGFuY2UoZmluZGVyLnRhcmdldF9ub2RlLCBjc3QuQ2xhc3NEZWYpOgogICAgICAgICAgICBleGlzdGluZ19tZXRob2RzID0gW10KICAgICAgICAgICAgZm9yIGl0ZW0gaW4gZmluZGVyLnRhcmdldF9ub2RlLmJvZHkuYm9keToKICAgICAgICAgICAgICAgIGlmIGlzaW5zdGFuY2UoaXRlbSwgY3N0LkZ1bmN0aW9uRGVmKToKICAgICAgICAgICAgICAgICAgICBleGlzdGluZ19tZXRob2RzLmFwcGVuZChpdGVtLm5hbWUudmFsdWUpCiAgICAgICAgICAgIGR1cGxpY2F0ZXMgPSBzZXQobmV3X25hbWVzKSAmIHNldChleGlzdGluZ19tZXRob2RzKQogICAgICAgICAgICBpZiBkdXBsaWNhdGVzOgogICAgICAgICAgICAgICAgZHVwX2xpc3QgPSAnLCAnLmpvaW4oc29ydGVkKGR1cGxpY2F0ZXMpKQogICAgICAgICAgICAgICAgY2xhc3NfbmFtZSA9IGZpbmRlci50YXJnZXRfbm9kZS5uYW1lLnZhbHVlCiAgICAgICAgICAgICAgICByZXR1cm4gZiJXYXJuaW5nOiBBZGRpbmcgZHVwbGljYXRlIG1ldGhvZChzKSB0byBjbGFzcyAne2NsYXNzX25hbWV9Jzoge2R1cF9saXN0fS4gVGhpcyB3aWxsIGNyZWF0ZSBtdWx0aXBsZSBtZXRob2RzIHdpdGggdGhlIHNhbWUgbmFtZS4iCiAgICByZXR1cm4gTm9uZQoKZGVmIF9jb3VudF9saW5lc190b19iZV9kZWxldGVkKG9yaWdpbmFsX2NvbnRlbnQ6IHN0ciwgbmV3X2NvbnRlbnQ6IHN0cikgLT4gaW50OgogICAgIiIiCiAgICBDb3VudCBob3cgbWFueSBsaW5lcyB3b3VsZCBiZSBkZWxldGVkIGJ5IGNvbXBhcmluZyBvcmlnaW5hbCB2cyBuZXcgY29udGVudC4KCiAgICBQYXJhbWV0ZXJzOgogICAgLS0tLS0tLS0tLS0KICAgIG9yaWdpbmFsX2NvbnRlbnQgOiBzdHIKICAgICAgICBUaGUgb3JpZ2luYWwgZmlsZSBjb250ZW50CiAgICBuZXdfY29udGVudCA6IHN0cgogICAgICAgIFRoZSBuZXcgY29udGVudCB0aGF0IHdvdWxkIHJlcGxhY2UgaXQKCiAgICBSZXR1cm5zOgogICAgLS0tLS0tLS0KICAgIGludAogICAgICAgIE51bWJlciBvZiBsaW5lcyB0aGF0IHdvdWxkIGJlIGRlbGV0ZWQKICAgICIiIgogICAgb3JpZ2luYWxfbGluZXMgPSBsZW4ob3JpZ2luYWxfY29udGVudC5zcGxpdGxpbmVzKCkpIGlmIG9yaWdpbmFsX2NvbnRlbnQuc3RyaXAoKSBlbHNlIDAKICAgIG5ld19saW5lcyA9IGxlbihuZXdfY29udGVudC5zcGxpdGxpbmVzKCkpIGlmIG5ld19jb250ZW50LnN0cmlwKCkgZWxzZSAwCiAgICByZXR1cm4gbWF4KDAsIG9yaWdpbmFsX2xpbmVzIC0gbmV3X2xpbmVzKQoKZGVmIF9oYW5kbGVfZmlsZV9sZXZlbF9pbnNlcnRpb24oYWJzX3BhdGg6IHN0ciwgdHJlZTogY3N0Lk1vZHVsZSwgbmV3X21vZHVsZTogY3N0Lk1vZHVsZSwgaW5zZXJ0X2FmdGVyOiBzdHIpIC0+IHN0cjoKICAgICIiIkhhbmRsZSBpbnNlcnRpb24gYXQgZmlsZSBsZXZlbCBhZnRlciBhIHNwZWNpZmljIHBhdHRlcm4uIiIiCiAgICBwYXR0ZXJuID0gaW5zZXJ0X2FmdGVyLnN0cmlwKCkKICAgIGlmIHBhdHRlcm4uc3RhcnRzd2l0aCgnIicpIGFuZCBwYXR0ZXJuLmVuZHN3aXRoKCciJykgb3IgKHBhdHRlcm4uc3RhcnRzd2l0aCgiJyIpIGFuZCBwYXR0ZXJuLmVuZHN3aXRoKCInIikpOgogICAgICAgIHBhdHRlcm4gPSBwYXR0ZXJuWzE6LTFdCgogICAgY2xhc3MgRmlsZU9ubHlJbnNlcnRlcihjc3QuQ1NUVHJhbnNmb3JtZXIpOgoKICAgICAgICBkZWYgX19pbml0X18oc2VsZiwgcGF0dGVybjogc3RyLCBuZXdfbm9kZXM6IExpc3RbY3N0LkNTVE5vZGVdKToKICAgICAgICAgICAgc2VsZi5wYXR0ZXJuID0gcGF0dGVybi5zdHJpcCgpCiAgICAgICAgICAgIHNlbGYubmV3X25vZGVzID0gbmV3X25vZGVzCiAgICAgICAgICAgIHNlbGYubW9kaWZpZWQgPSBGYWxzZQoKICAgICAgICBkZWYgbGVhdmVfTW9kdWxlKHNlbGYsIG9yaWdpbmFsX25vZGU6IGNzdC5Nb2R1bGUsIHVwZGF0ZWRfbm9kZTogY3N0Lk1vZHVsZSkgLT4gY3N0Lk1vZHVsZToKICAgICAgICAgICAgbmV3X2JvZHkgPSBbXQogICAgICAgICAgICBmb3Igc3RtdCBpbiB1cGRhdGVkX25vZGUuYm9keToKICAgICAgICAgICAgICAgIG5ld19ib2R5LmFwcGVuZChzdG10KQogICAgICAgICAgICAgICAgbWF0Y2hfZm91bmQgPSBGYWxzZQogICAgICAgICAgICAgICAgaWYgaXNpbnN0YW5jZShzdG10LCAoY3N0LkZ1bmN0aW9uRGVmLCBjc3QuQ2xhc3NEZWYpKSBhbmQgc3RtdC5uYW1lLnZhbHVlID09IHNlbGYucGF0dGVybjoKICAgICAgICAgICAgICAgICAgICBtYXRjaF9mb3VuZCA9IFRydWUKICAgICAgICAgICAgICAgIGVsc2U6CiAgICAgICAgICAgICAgICAgICAgdHJ5OgogICAgICAgICAgICAgICAgICAgICAgICBzdG10X2NvZGUgPSB1cGRhdGVkX25vZGUuY29kZV9mb3Jfbm9kZShzdG10KS5zdHJpcCgpCiAgICAgICAgICAgICAgICAgICAgICAgIGlmIHNlbGYucGF0dGVybiBpbiBzdG10X2NvZGU6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaF9mb3VuZCA9IFRydWUKICAgICAgICAgICAgICAgICAgICBleGNlcHQgRXhjZXB0aW9uOgogICAgICAgICAgICAgICAgICAgICAgICBwYXNzCiAgICAgICAgICAgICAgICBpZiBtYXRjaF9mb3VuZDoKICAgICAgICAgICAgICAgICAgICBuZXdfYm9keS5leHRlbmQoc2VsZi5uZXdfbm9kZXMpCiAgICAgICAgICAgICAgICAgICAgc2VsZi5tb2RpZmllZCA9IFRydWUKICAgICAgICAgICAgaWYgc2VsZi5tb2RpZmllZDoKICAgICAgICAgICAgICAgIHJldHVybiB1cGRhdGVkX25vZGUud2l0aF9jaGFuZ2VzKGJvZHk9bmV3X2JvZHkpCiAgICAgICAgICAgIHJldHVybiB1cGRhdGVkX25vZGUKICAgIGluc2VydGVyID0gRmlsZU9ubHlJbnNlcnRlcihwYXR0ZXJuLCBuZXdfbW9kdWxlLmJvZHkpCiAgICBtb2RpZmllZF90cmVlID0gdHJlZS52aXNpdChpbnNlcnRlcikKICAgIGlmIG5vdCBpbnNlcnRlci5tb2RpZmllZDoKICAgICAgICByZXR1cm4gX3Byb2Nlc3NfZXJyb3IoVmFsdWVFcnJvcihmJ0luc2VydCBwb2ludCBub3QgZm91bmQgYXQgZmlsZSBsZXZlbDoge2luc2VydF9hZnRlcn0nKSkKICAgIF93cml0ZV9maWxlX2JvbV9zYWZlKGFic19wYXRoLCBtb2RpZmllZF90cmVlLmNvZGUpCiAgICByZXR1cm4gZiJDb2RlIGluc2VydGVkIGFmdGVyICd7aW5zZXJ0X2FmdGVyfScgaW4gJ3thYnNfcGF0aH0nLiIKCmRlZiBfaGFuZGxlX2RlbGV0aW9uKGFic19wYXRoOiBzdHIsIHRhcmdldF9zY29wZTogc3RyLCBwYXRoX2VsZW1lbnRzOiBsaXN0LCBvcmlnaW5hbF9jb250ZW50OiBzdHIsIHRyZWU6IGNzdC5Nb2R1bGUsIGRlbGV0ZV9hX2xvdDogYm9vbD1GYWxzZSkgLT4gc3RyOgogICAgIiIiSGFuZGxlIGRlbGV0aW9uIG9mIGEgdGFyZ2V0IHNlY3Rpb24gd2hlbiBlbXB0eSBjb2RlIGlzIHByb3ZpZGVkLiIiIgogICAgdHJ5OgogICAgICAgIGxpbmVzX3RvX2RlbGV0ZSA9IF9jb3VudF9saW5lc190b19iZV9kZWxldGVkKG9yaWdpbmFsX2NvbnRlbnQsICcnKQogICAgICAgIGlmIGxpbmVzX3RvX2RlbGV0ZSA+IDEwMCBhbmQgKG5vdCBkZWxldGVfYV9sb3QpOgogICAgICAgICAgICByZXR1cm4gX3Byb2Nlc3NfZXJyb3IoVmFsdWVFcnJvcihmJ1NhZmV0eSBjaGVjazogdGhpcyBvcGVyYXRpb24gd291bGQgZGVsZXRlIHtsaW5lc190b19kZWxldGV9IGxpbmVzLiAnICsgIklmIGludGVudGlvbmFsLCBzZXQgZGVsZXRlX2FfbG90PVRydWUuIENvbnNpZGVyIHVzaW5nICdpbnNlcnRfYWZ0ZXInIHBhcmFtZXRlciB0byBhZGQgY29kZSB3aXRob3V0IGRlbGV0aW5nIGV4aXN0aW5nIGNvbnRlbnQuIikpCiAgICAgICAgaWYgbm90IHBhdGhfZWxlbWVudHM6CiAgICAgICAgICAgIF93cml0ZV9maWxlX2JvbV9zYWZlKGFic19wYXRoLCAnJykKICAgICAgICAgICAgcmV0dXJuIGYiRmlsZSAne2Fic19wYXRofScgY2xlYXJlZCAoZGVsZXRlZCBhbGwgY29udGVudCkuIgogICAgICAgIGVsc2U6CiAgICAgICAgICAgIGRlbGV0ZXIgPSBTY29wZURlbGV0ZXIocGF0aF9lbGVtZW50cykKICAgICAgICAgICAgbW9kaWZpZWRfdHJlZSA9IHRyZWUudmlzaXQoZGVsZXRlcikKICAgICAgICAgICAgaWYgbm90IGRlbGV0ZXIubW9kaWZpZWQ6CiAgICAgICAgICAgICAgICByZXR1cm4gX3Byb2Nlc3NfZXJyb3IoVmFsdWVFcnJvcihmJ1RhcmdldCBzY29wZSBub3QgZm91bmQgZm9yIGRlbGV0aW9uOiB7dGFyZ2V0X3Njb3BlfScpKQogICAgICAgICAgICBfd3JpdGVfZmlsZV9ib21fc2FmZShhYnNfcGF0aCwgbW9kaWZpZWRfdHJlZS5jb2RlKQogICAgICAgICAgICByZXR1cm4gZiJEZWxldGVkIHNjb3BlICd7dGFyZ2V0X3Njb3BlfScgZnJvbSAne2Fic19wYXRofScuIgogICAgZXhjZXB0IEV4Y2VwdGlvbiBhcyBlOgogICAgICAgIHJldHVybiBfcHJvY2Vzc19lcnJvcihlKQoKZGVmIF93cml0ZV9maWxlX2JvbV9zYWZlKGZpbGVfcGF0aDogc3RyLCBjb250ZW50OiBzdHIpIC0+IE5vbmU6CiAgICAiIiJXcml0ZSBhIGZpbGUgd2l0aCBCT00gcHJvdGVjdGlvbi4iIiIKICAgIGVuZHNfd2l0aF9uZXdsaW5lID0gY29udGVudC5lbmRzd2l0aCgnXG4nKQogICAgY2xlYW5fY29udGVudCA9IGNsZWFuX3VuaWNvZGVfc3RyaW5nKGNvbnRlbnQpCiAgICBpZiBlbmRzX3dpdGhfbmV3bGluZSBhbmQgKG5vdCBjbGVhbl9jb250ZW50LmVuZHN3aXRoKCdcbicpKToKICAgICAgICBjbGVhbl9jb250ZW50ICs9ICdcbicKICAgIHdpdGggb3BlbihmaWxlX3BhdGgsICd3JywgZW5jb2Rpbmc9J3V0Zi04JykgYXMgZmlsZToKICAgICAgICBmaWxlLndyaXRlKGNsZWFuX2NvbnRlbnQpCgpkZWYgX21ha2VfZmlsZShmaWxlX3BhdGg6IHN0cikgLT4gc3RyOgogICAgIiIiCiAgICBDcmVhdGUgYSBmaWxlIGFuZCBpdHMgcGFyZW50IGRpcmVjdG9yaWVzIGlmIHRoZXkgZG9uJ3QgZXhpc3QuCgogICAgUGFyYW1ldGVyczoKICAgIC0tLS0tLS0tLS0tCiAgICBmaWxlX3BhdGggOiBzdHIKICAgICAgICBQYXRoIHRvIHRoZSBmaWxlIHRvIGNyZWF0ZQoKICAgIFJldHVybnM6CiAgICAtLS0tLS0tLQogICAgc3RyCiAgICAgICAgQWJzb2x1dGUgcGF0aCB0byB0aGUgY3JlYXRlZC9leGlzdGluZyBmaWxlCgogICAgUmFpc2VzOgogICAgLS0tLS0tLQogICAgVmFsdWVFcnJvcgogICAgICAgIElmIHRoZXJlJ3MgYW4gZXJyb3IgY3JlYXRpbmcgdGhlIGZpbGUgb3IgZGlyZWN0b3JpZXMKICAgICIiIgogICAgaWYgbm90IGZpbGVfcGF0aDoKICAgICAgICByYWlzZSBWYWx1ZUVycm9yKCdGaWxlIHBhdGggY2Fubm90IGJlIGVtcHR5JykKICAgIGFic19wYXRoID0gb3MucGF0aC5hYnNwYXRoKGZpbGVfcGF0aCkKICAgIGRpcl9wYXRoID0gb3MucGF0aC5kaXJuYW1lKGFic19wYXRoKQogICAgaWYgZGlyX3BhdGg6CiAgICAgICAgdHJ5OgogICAgICAgICAgICBvcy5tYWtlZGlycyhkaXJfcGF0aCwgZXhpc3Rfb2s9VHJ1ZSkKICAgICAgICBleGNlcHQgRXhjZXB0aW9uIGFzIGU6CiAgICAgICAgICAgIHJhaXNlIFZhbHVlRXJyb3IoZidFcnJvciBjcmVhdGluZyBkaXJlY3RvcmllcyB7ZGlyX3BhdGh9OiB7c3RyKGUpfScpCiAgICBpZiBub3Qgb3MucGF0aC5leGlzdHMoYWJzX3BhdGgpOgogICAgICAgIHRyeToKICAgICAgICAgICAgd2l0aCBvcGVuKGFic19wYXRoLCAndycsIGVuY29kaW5nPSd1dGYtOCcpIGFzIGY6CiAgICAgICAgICAgICAgICBmLndyaXRlKCcnKQogICAgICAgIGV4Y2VwdCBFeGNlcHRpb24gYXMgZToKICAgICAgICAgICAgcmFpc2UgVmFsdWVFcnJvcihmJ0Vycm9yIGNyZWF0aW5nIGZpbGUge2Fic19wYXRofToge3N0cihlKX0nKQogICAgcmV0dXJuIGFic19wYXRoCgpkZWYgX2NyZWF0ZV9zdGF0ZW1lbnRfd2l0aF9jb21tZW50KGNvbW1lbnRfdGV4dDogc3RyLCBpbmRlbnRfbGV2ZWw6IGludD0wKSAtPiBjc3QuU2ltcGxlU3RhdGVtZW50TGluZToKICAgICIiIgogICAgQ3JlYXRlIGEgc3RhdGVtZW50IHRoYXQgY29udGFpbnMganVzdCBhIGNvbW1lbnQuCiAgICBTaW5jZSBMaWJDU1QgcmVxdWlyZXMgc3RhdGVtZW50cyB0byBoYXZlIGFjdHVhbCBjb2RlLCB3ZSBjcmVhdGUgYSBwYXNzIHN0YXRlbWVudAogICAgd2l0aCBhIHRyYWlsaW5nIGNvbW1lbnQuCiAgICAiIiIKICAgIGxpbmVzID0gY29tbWVudF90ZXh0LnN0cmlwKCkuc3BsaXQoJ1xuJykKICAgIGlmIGxlbihsaW5lcykgPiAxOgogICAgICAgIGNvbW1lbnRfdGV4dCA9IGxpbmVzWzBdCiAgICBjb21tZW50X3RleHQgPSBjb21tZW50X3RleHQuc3RyaXAoKQogICAgaWYgY29tbWVudF90ZXh0LnN0YXJ0c3dpdGgoJyMnKToKICAgICAgICBjb21tZW50X3RleHQgPSBjb21tZW50X3RleHRbMTpdLnN0cmlwKCkKICAgIGNvbW1lbnQgPSBjc3QuQ29tbWVudChmJyMge2NvbW1lbnRfdGV4dH0nKQogICAgcmV0dXJuIGNzdC5TaW1wbGVTdGF0ZW1lbnRMaW5lKGJvZHk9W2NzdC5QYXNzKCldLCB0cmFpbGluZ193aGl0ZXNwYWNlPWNzdC5UcmFpbGluZ1doaXRlc3BhY2Uod2hpdGVzcGFjZT1jc3QuU2ltcGxlV2hpdGVzcGFjZSgnICAnKSwgY29tbWVudD1jb21tZW50KSkKCmRlZiBfaGFuZGxlX2ZpcnN0X2RlZmluaXRpb24oYWJzX3BhdGg6IHN0ciwgdHJlZTogY3N0Lk1vZHVsZSwgbmV3X21vZHVsZTogY3N0Lk1vZHVsZSwgY29zY29wZV93aXRoOiBzdHI9Tm9uZSkgLT4gc3RyOgogICAgIiIiSGFuZGxlIGVkaXRpbmcgdGhlIGZpcnN0IHRvcC1sZXZlbCBkZWZpbml0aW9uIGluIGEgZmlsZS4iIiIKICAgIGlmIG5vdCB0cmVlLmJvZHk6CiAgICAgICAgcmV0dXJuIF9wcm9jZXNzX2Vycm9yKFZhbHVlRXJyb3IoJ0ZpbGUgaGFzIG5vIHRvcC1sZXZlbCBkZWZpbml0aW9ucyB0byBlZGl0JykpCiAgICBmaXJzdF9kZWZfaW5kZXggPSBOb25lCiAgICBmb3IgaSwgc3RtdCBpbiBlbnVtZXJhdGUodHJlZS5ib2R5KToKICAgICAgICBpZiBpc2luc3RhbmNlKHN0bXQsIChjc3QuRnVuY3Rpb25EZWYsIGNzdC5DbGFzc0RlZikpOgogICAgICAgICAgICBmaXJzdF9kZWZfaW5kZXggPSBpCiAgICAgICAgICAgIGJyZWFrCiAgICBpZiBmaXJzdF9kZWZfaW5kZXggaXMgTm9uZToKICAgICAgICByZXR1cm4gX3Byb2Nlc3NfZXJyb3IoVmFsdWVFcnJvcignTm8gZnVuY3Rpb24gb3IgY2xhc3MgZGVmaW5pdGlvbiBmb3VuZCBpbiBmaWxlJykpCiAgICBpZiBjb3Njb3BlX3dpdGg6CiAgICAgICAgbmV3X2JvZHkgPSBsaXN0KHRyZWUuYm9keVs6Zmlyc3RfZGVmX2luZGV4ICsgMV0pICsgbGlzdChuZXdfbW9kdWxlLmJvZHkpICsgbGlzdCh0cmVlLmJvZHlbZmlyc3RfZGVmX2luZGV4ICsgMTpdKQogICAgICAgIG1vZGlmaWVkX3RyZWUgPSB0cmVlLndpdGhfY2hhbmdlcyhib2R5PW5ld19ib2R5KQogICAgICAgIF93cml0ZV9maWxlX2JvbV9zYWZlKGFic19wYXRoLCBtb2RpZmllZF90cmVlLmNvZGUpCiAgICAgICAgcmV0dXJuIGYiQ29kZSBpbnNlcnRlZCBhZnRlciBmaXJzdCBkZWZpbml0aW9uIGluICd7YWJz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AGoqAgAAaisCAABqpAEAAGpMAgAAaqYBAABqjAIAAGqgAQAAaqUCAABqmgIAAGqsAgAAjAxfX2J1aWx0aW5zX1+UY2J1aWx0aW5zCl9fZGljdF9fCnUwaooCAAAoaDdoTGg2TmhZTmhaTmhbTmhcaF1oFGhfaBVoYGgYaGFoYmhmaGdoaWg0aGtobGhuaG9ocWhyaHRodWh4aHloe2h8aH5oNWh/aIBogmiDaIRohWiGaIdoiGiJaIpoi2iPaJBokWiSaJNolGiVaJZol2iYaJlommibaJxonWieaJ9oRmhPaKBooWiiaKNopGilaKZop2ioaKtoDGisaK1ormivaLFosmjWaNxo7WjyagMBAABqCAEAAGocAQAAaiQBAABqJgEAAGonAQAAalEBAABqZAEAAGplAQAAamYBAABqZwEAAGpoAQAAamkBAABqNQEAAGpqAQAAamsBAABqbAEAAGptAQAAam4BAABqbwEAAGp3AQAAaqUBAABq4wEAAGqjAQAAavsBAABqogEAAGobAgAAaiICAABqIwIAAGokAgAAaiUCAABqJgIAAGonAgAAaigCAABqKQIAAGoqAgAAaisCAABqpAEAAGpMAgAAaqYBAABqjAIAAGqgAQAAaqUCAABqmgIAAGqsAgAAarECAABjYnVpbHRpbnMKX19kaWN0X18KdTBqSgIAAChoN2hMaDZOaFlOaFpOaFtOaFxoXWgUaF9oFWhgaBhoYWhiaGZoZ2hpaDRoa2hsaG5ob2hxaHJodGh1aHhoeWh7aHxofmg1aH9ogGiCaINohGiFaIZoh2iIaIloimiLaI9okGiRaJJok2iUaJVolmiXaJhomWiaaJtonGidaJ5on2hGaE9ooGihaKJoo2ikaKVopminaKhoq2gMaKxorWiuaK9osWiyaNZo3GjtaPJqAwEAAGoIAQAAahwBAABqJAEAAGomAQAAaicBAABqUQEAAGpkAQAAamUBAABqZgEAAGpnAQAAamgBAABqaQEAAGo1AQAAamoBAABqawEAAGpsAQAAam0BAABqbgEAAGpvAQAAancBAABqpQEAAGrjAQAAaqMBAABq+wEAAGqiAQAAahsCAABqIgIAAGojAgAAaiQCAABqJQIAAGomAgAAaicCAABqKAIAAGopAgAAaioCAABqKwIAAGqkAQAAakwCAABqpgEAAGqMAgAAaqABAABqpQIAAGqaAgAAaqwCAABqsQIAAGNidWlsdGlucwpfX2RpY3RfXwp1MGoYAgAAKGg3aExoNk5oWU5oWk5oW05oXGhdaBRoX2gVaGBoGGhhaGJoZmhnaGloNGhraGxobmhvaHFocmh0aHVoeGh5aHtofGh+aDVof2iAaIJog2iEaIVohmiHaIhoiWiKaItoj2iQaJFokmiTaJRolWiWaJdomGiZaJpom2icaJ1onmifaEZoT2igaKFoomijaKRopWimaKdoqGiraAxorGitaK5or2ixaLJo1mjcaO1o8moDAQAAaggBAABqHAEAAGokAQAAaiYBAABqJwEAAGpRAQAAamQBAABqZQEAAGpmAQAAamcBAABqaAEAAGppAQAAajUBAABqagEAAGprAQAAamwBAABqbQEAAGpuAQAAam8BAABqdwEAAGqlAQAAauMBAABqowEAAGr7AQAAaqIBAABqGwIAAGoiAgAAaiMCAABqJAIAAGolAgAAaiYCAABqJwIAAGooAgAAaikCAABqKgIAAGorAgAAaqQBAABqTAIAAGqmAQAAaowCAABqoAEAAGqlAgAAapoCAABqrAIAAGqxAgAAY2J1aWx0aW5zCl9fZGljdF9fCnUwavkBAAAoaDdoTGg2TmhZTmhaTmhbTmhcaF1oFGhfaBVoYGgYaGFoYmhmaGdoaWg0aGtobGhuaG9ocWhyaHRodWh4aHloe2h8aH5oNWh/aIBogmiDaIRohWiGaIdoiGiJaIpoi2iPaJBokWiSaJNolGiVaJZol2iYaJlommibaJxonWieaJ9oRmhPaKBooWiiaKNopGilaKZop2ioaKtoDGisaK1ormivaLFosmjWaNxo7WjyagMBAABqCAEAAGocAQAAaiQBAABqJgEAAGonAQAAalEBAABqZAEAAGplAQAAamYBAABqZwEAAGpoAQAAamkBAABqNQEAAGpqAQAAamsBAABqbAEAAGptAQAAam4BAABqbwEAAGp3AQAAaqUBAABq4wEAAGqjAQAAavsBAABqogEAAGobAgAAaiICAABqIwIAAGokAgAAaiUCAABqJgIAAGonAgAAaigCAABqKQIAAGoqAgAAaisCAABqpAEAAGpMAgAAaqYBAABqjAIAAGqgAQAAaqUCAABqmgIAAGqsAgAAarECAABjYnVpbHRpbnMKX19kaWN0X18KdTBq4QEAAChoN2hMaDZOaFlOaFpOaFtOaFxoXWgUaF9oFWhgaBhoYWhiaGZoZ2hpaDRoa2hsaG5ob2hxaHJodGh1aHhoeWh7aHxofmg1aH9ogGiCaINohGiFaIZoh2iIaIloimiLaI9okGiRaJJok2iUaJVolmiXaJhomWiaaJtonGidaJ5on2hGaE9ooGihaKJoo2ikaKVopminaKhoq2gMaKxorWiuaK9osWiyaNZo3GjtaPJqAwEAAGoIAQAAahwBAABqJAEAAGomAQAAaicBAABqUQEAAGpkAQAAamUBAABqZgEAAGpnAQAAamgBAABqaQEAAGo1AQAAamoBAABqawEAAGpsAQAAam0BAABqbgEAAGpvAQAAancBAABqpQEAAGrjAQAAaqMBAABq+wEAAGqiAQAAahsCAABqIgIAAGojAgAAaiQCAABqJQIAAGomAgAAaicCAABqKAIAAGopAgAAaioCAABqKwIAAGqkAQAAakwCAABqpgEAAGqMAgAAaqABAABqpQIAAGqaAgAAaqwCAABqsQIAAGNidWlsdGlucwpfX2RpY3RfXwp1MGq6AQAAKGg3aExoNk5oWU5oWk5oW05oXGhdaBRoX2gVaGBoGGhhaGJoZmhnaGloNGhraGxobmhvaHFocmh0aHVoeGh5aHtofGh+aDVof2iAaIJog2iEaIVohmiHaIhoiWiKaItoj2iQaJFokmiTaJRolWiWaJdomGiZaJpom2icaJ1onmifaEZoT2igaKFoomijaKRopWimaKdoqGiraAxorGitaK5or2ixaLJo1mjcaO1o8moDAQAAaggBAABqHAEAAGokAQAAaiYBAABqJwEAAGpRAQAAamQBAABqZQEAAGpmAQAAamcBAABqaAEAAGppAQAAajUBAABqagEAAGprAQAAamwBAABqbQEAAGpuAQAAam8BAABqdwEAAGqlAQAAauMBAABqowEAAGr7AQAAaqIBAABqGwIAAGoiAgAAaiMCAABqJAIAAGolAgAAaiYCAABqJwIAAGooAgAAaikCAABqKgIAAGorAgAAaqQBAABqTAIAAGqmAQAAaowCAABqoAEAAGqlAgAAapoCAABqrAIAAGqxAgAAY2J1aWx0aW5zCl9fZGljdF9fCnUwjAhidWlsdGluc5SMB2dldGF0dHKUk5SMBGRpbGyUjAVfZGlsbJSTlIwIX3NldGF0dHKUarICAACMB3NldGF0dHKUk5SHlFKUanQBAACMDWNlbGxfY29udGVudHOUarwBAACHlFIwanABAAAoaDdoTGg2TmhZTmhaTmhbTmhcaF1oFGhfaBVoYGgYaGFoYmhmaGdoaWg0aGtobGhuaG9ocWhyaHRodWh4aHloe2h8aH5oNWh/aIBogmiDaIRohWiGaIdoiGiJaIpoi2iPaJBokWiSaJNolGiVaJZol2iYaJlommibaJxonWieaJ9oRmhPaKBooWiiaKNopGilaKZop2ioaKtoDGisaK1ormivaLFosmjWaNxo7WjyagMBAABqCAEAAGocAQAAaiQBAABqJgEAAGonAQAAalEBAABqZAEAAGplAQAAamYBAABqZwEAAGpoAQAAamkBAABqNQEAAGpqAQAAamsBAABqbAEAAGptAQAAam4BAABqbwEAAGp3AQAAaqUBAABq4wEAAGqjAQAAavsBAABqogEAAGobAgAAaiICAABqIwIAAGokAgAAaiUCAABqJgIAAGonAgAAaigCAABqKQIAAGoqAgAAaisCAABqpAEAAGpMAgAAaqYBAABqjAIAAGqgAQAAaqUCAABqmgIAAGqsAgAAarECAABjYnVpbHRpbnMKX19kaWN0X18KdTBqpQEAAGrjAQAAaqMBAABq+wEAAGqiAQAAahsCAABqIgIAAGojAgAAaiQCAABqJQIAAGomAgAAaicCAABqKAIAAGopAgAAaioCAABqKwIAAGqkAQAAakwCAABqpgEAAGqMAgAAaqABAABqpQIAAGqaAgAAaqwCAABqsQIAAGNidWlsdGlucwpfX2RpY3RfXwp1MGpkAQAAamUBAABqZgEAAGpnAQAAamgBAABqaQEAAGo1AQAAamoBAABqawEAAGpsAQAAam0BAABqbgEAAGpvAQAAancBAABqpQEAAGrjAQAAaqMBAABq+wEAAGqiAQAAahsCAABqIgIAAGojAgAAaiQCAABqJQIAAGomAgAAaicCAABqKAIAAGopAgAAaioCAABqKwIAAGqkAQAAakwCAABqpgEAAGqMAgAAaqABAABqpQIAAGqaAgAAaqwCAABqsQIAAGNidWlsdGlucwpfX2RpY3RfXwp1MGokAQAAaiYBAABqJwEAAGpRAQAAamQBAABqZQEAAGpmAQAAamcBAABqaAEAAGppAQAAajUBAABqagEAAGprAQAAamwBAABqbQEAAGpuAQAAam8BAABqdwEAAGqlAQAAauMBAABqowEAAGr7AQAAaqIBAABqGwIAAGoiAgAAaiMCAABqJAIAAGolAgAAaiYCAABqJwIAAGooAgAAaikCAABqKgIAAGorAgAAaqQBAABqTAIAAGqmAQAAaowCAABqoAEAAGqlAgAAapoCAABqrAIAAGqxAgAAY2J1aWx0aW5zCl9fZGljdF9fCnUwaggBAABqHAEAAGokAQAAaiYBAABqJwEAAGpRAQAAamQBAABqZQEAAGpmAQAAamcBAABqaAEAAGppAQAAajUBAABqagEAAGprAQAAamwBAABqbQEAAGpuAQAAam8BAABqdwEAAGqlAQAAauMBAABqowEAAGr7AQAAaqIBAABqGwIAAGoiAgAAaiMCAABqJAIAAGolAgAAaiYCAABqJwIAAGooAgAAaikCAABqKgIAAGorAgAAaqQBAABqTAIAAGqmAQAAaowCAABqoAEAAGqlAgAAapoCAABqrAIAAGqxAgAAY2J1aWx0aW5zCl9fZGljdF9fCnUwaPJqAwEAAGoIAQAAahwBAABqJAEAAGomAQAAaicBAABqUQEAAGpkAQAAamUBAABqZgEAAGpnAQAAamgBAABqaQEAAGo1AQAAamoBAABqawEAAGpsAQAAam0BAABqbgEAAGpvAQAAancBAABqpQEAAGrjAQAAaqMBAABq+wEAAGqiAQAAahsCAABqIgIAAGojAgAAaiQCAABqJQIAAGomAgAAaicCAABqKAIAAGopAgAAaioCAABqKwIAAGqkAQAAakwCAABqpgEAAGqMAgAAaqABAABqpQIAAGqaAgAAaqwCAABqsQIAAGNidWlsdGlucwpfX2RpY3RfXwp1MGjcaO1o8moDAQAAaggBAABqHAEAAGokAQAAaiYBAABqJwEAAGpRAQAAamQBAABqZQEAAGpmAQAAamcBAABqaAEAAGppAQAAajUBAABqagEAAGprAQAAamwBAABqbQEAAGpuAQAAam8BAABqdwEAAGqlAQAAauMBAABqowEAAGr7AQAAaqIBAABqGwIAAGoiAgAAaiMCAABqJAIAAGolAgAAaiYCAABqJwIAAGooAgAAaikCAABqKgIAAGorAgAAaqQBAABqTAIAAGqmAQAAaowCAABqoAEAAGqlAgAAapoCAABqrAIAAGqxAgAAY2J1aWx0aW5zCl9fZGljdF9fCnUwLg==",
      "name": "toolify",
      "hash": "b9a8cb4ea569b32f69d24cc91da6f94051e5fe1bdacbc2a62f5f921b817376ff",
      "provenance": {
       "module": "dynamic_module_250906616726654990",
       "qualname": "toolify"
      }
     },
     "_convert_string_to_type": {
      "__helper_func__": true,
      "pickled": "gASVMwAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjBdfY29udmVydF9zdHJpbmdfdG9fdHlwZZSTlC4=",
      "name": "_convert_string_to_type",
      "hash": "024e40c56cb46e6fe9f52fe7e6e64a3effc17736268ef31195596c6a6be4c311",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "_convert_string_to_type"
      }
     },
     "_log_error_to_file": {
      "__helper_func__": true,
      "pickled": "gASVLgAAAAAAAACME2JvdHMuZGV2LmRlY29yYXRvcnOUjBJfbG9nX2Vycm9yX3RvX2ZpbGWUk5Qu",
      "name": "_log_error_to_file",
      "hash": "c02546b672eb25afd5dc51ea7e1967cbb6fd264ca18ffd15c3cbeccebe4046ba",
      "provenance": {
       "module": "bots.dev.decorators",
       "qualname": "_log_error_to_file"
      }
     },
     "List": {
      "__imported_callable__": true,
      "pickled": "gASVEwAAAAAAAACMBnR5cGluZ5SMBExpc3SUk5Qu",
      "name": "List",
      "hash": "4177cb372f5ac2e670cf003d399db45b34278d8cf8801c6f8c592fc37176022f",
      "provenance": {
       "module": "typing",
       "qualname": "List"
      }
     },
     "Union": {
      "__imported_callable__": true,
      "pickled": "gASVFAAAAAAAAACMBnR5cGluZ5SMBVVuaW9ulJOULg==",
      "name": "Union",
      "hash": "ccd01a358f6c99cc4b7ab96256fb9d3cbc7009bdba98038d635fefdafc9a35de",
      "provenance": {
       "module": "typing",
       "qualname": "Union"
      }
     },
     "cst": {
      "__module_type__": true,
      "name": "libcst",
      "spec": "libcst"
     },
     "_process_error": {
      "__helper_func__": true,
      "pickled": "gASVKQAAAAAAAACMEmJvdHMudXRpbHMuaGVscGVyc5SMDl9wcm9jZXNzX2Vycm9ylJOULg==",
      "name": "_process_error",
      "hash": "10b62012f4c2cf25d619b19f083513ff485e28e6f2f1ab3dc952bc85a0fd31e1",
      "provenance": {
       "module": "bots.utils.helpers",
       "qualname": "_process_error"
      }
     },
     "_py_ast_to_source": {
      "__helper_func__": true,
      "pickled": "gASVLAAAAAAAAACMEmJvdHMudXRpbHMuaGVscGVyc5SMEV9weV9hc3RfdG9fc291cmNllJOULg==",
      "name": "_py_ast_to_source",
      "hash": "b4f03eb89ec6290dae99f96b4cbde39a5df78f3a58db9ae249d5cfe9d8d740c2",
      "provenance": {
       "module": "bots.utils.helpers",
       "qualname": "_py_ast_to_source"
      }
     },
     "clean_unicode_string": {
      "__imported_callable__": true,
      "pickled": "gASVNQAAAAAAAACMGGJvdHMudXRpbHMudW5pY29kZV91dGlsc5SMFGNsZWFuX3VuaWNvZGVfc3RyaW5nlJOULg==",
      "name": "clean_unicode_string",
      "hash": "2316910285c0cef615cfa77d71869e6841488cbe386a2ae90e4f7ebf187fec5e",
      "provenance": {
       "module": "bots.utils.unicode_utils",
       "qualname": "clean_unicode_string"
      }
     },
     "_extract_definition_names": {
      "__helper_func__": true,
      "pickled": "gASVOAAAAAAAAACMFmJvdHMudG9vbHMucHl0aG9uX2VkaXSUjBlfZXh0cmFjdF9kZWZpbml0aW9uX25hbWVzlJOULg==",
      "name": "_extract_definition_names",
      "hash": "3e6928e16414aa2b20618845a01305f68940077be884b9fe697272f44b8e78d3",
      "provenance": {
       "module": "bots.tools.python_edit",
       "qualname": "_extract_definition_names"
      }
     },
     "ScopeViewer": {
      "__imported_callable__": true,
      "pickled": "gASVKgAAAAAAAACMFmJvdHMudG9vbHMucHl0aG9uX2VkaXSUjAtTY29wZVZpZXdlcpSTlC4=",
      "name": "ScopeViewer",
      "hash": "f52828d119c9f54d5da9219e39db4ad455b2c64d0f33c7377bae10512ff1130b",
      "provenance": {
       "module": "bots.tools.python_edit",
       "qualname": "ScopeViewer"
      }
     },
     "ScopeTransformer": {
      "__imported_callable__": true,
      "pickled": "gASVLwAAAAAAAACMFmJvdHMudG9vbHMucHl0aG9uX2VkaXSUjBBTY29wZVRyYW5zZm9ybWVylJOULg==",
      "name": "ScopeTransformer",
      "hash": "602d38226569839bd40707cf7bf99b94c3eab4f4f627db8a40e0d812f223a2a7",
      "provenance": {
       "module": "bots.tools.python_edit",
       "qualname": "ScopeTransformer"
      }
     },
     "GenericPatternInserter": {
      "__imported_callable__": true,
      "pickled": "gASVNQAAAAAAAACMFmJvdHMudG9vbHMucHl0aG9uX2VkaXSUjBZHZW5lcmljUGF0dGVybkluc2VydGVylJOULg==",
      "name": "GenericPatternInserter",
      "hash": "4356addd47489a79b14898f6da1bcbd4e95ab399e78db6874bff0aaa5aeabf42",
      "provenance": {
       "module": "bots.tools.python_edit",
       "qualname": "GenericPatternInserter"
      }
     },
     "ScopeFinder": {
      "__imported_callable__": true,
      "pickled": "gASVKgAAAAAAAACMFmJvdHMudG9vbHMucHl0aG9uX2VkaXSUjAtTY29wZUZpbmRlcpSTlC4=",
      "name": "ScopeFinder",
      "hash": "73232579c4cfb7ca73e4f0d56ef147b8e42210e93bff62d027f0daf399b217b0",
      "provenance": {
       "module": "bots.tools.python_edit",
       "qualname": "ScopeFinder"
      }
     },
     "ScopeReplacer": {
      "__imported_callable__": true,
      "pickled": "gASVLAAAAAAAAACMFmJvdHMudG9vbHMucHl0aG9uX2VkaXSUjA1TY29wZVJlcGxhY2VylJOULg==",
      "name": "ScopeReplacer",
      "hash": "52e7c4bec232dbfd0d363dc50069e73b709990041b0b09e5881a30f75083e012",
      "provenance": {
       "module": "bots.tools.python_edit",
       "qualname": "ScopeReplacer"
      }
     },
     "python_view": {
      "__imported_callable__": true,
      "pickled": "gASVKgAAAAAAAACMFmJvdHMudG9vbHMucHl0aG9uX2VkaXSUjAtweXRob25fdmlld5STlC4=",
      "name": "python_view",
      "hash": "733647ed8ad43d3bb73ccf55cca991c57333ba6895330aa30c7610006706b196",
      "provenance": {
       "module": "bots.tools.python_edit",
       "qualname": "python_view"
      }
     },
     "python_edit": {
      "__imported_callable__": true,
      "pickled": "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ZCIgKG1ldGhvZCkKICAgICAgICAgICAgLSAiZmlsZS5weTo6X19GSVJTVF9fIiAoZmlyc3QgdG9wLWxldmVsIGRlZmluaXRpb24pCgogICAgICAgIGNvZGUgOiBzdHIKICAgICAgICAgICAgUHl0aG9uIGNvZGUuIFRoaXMgY29kZSB3aWxsIHJlcGxhY2UgdGhlIGVudGlyZSB0YXJnZXQgc2NvcGUgYnkgZGVmYXVsdCwKICAgICAgICAgICAgb3IgaW5zZXJ0IGFmdGVyIChpZiBjb3Njb3BlX3dpdGggaXMgc3BlY2lmaWVkKS4gQ29kZSBpcyBpbmRlbnRlZCBhdXRvbWF0aWNhbGx5CiAgICAgICAgICAgIHRvIG1hdGNoIHRvIHNjb3BlLgoKICAgICAgICBjb3Njb3BlX3dpdGggOiBzdHIsIG9wdGlvbmFsCiAgICAgICAgICAgIElmIHNwZWNpZmllZCwgY29kZSBpcyBpbnNlcnRlZCBpbiB0aGUgc2FtZSBzY29wZSBhcyB0aGUgc3BlY2lmaWVkIGNvZGUsCiAgICAgICAgICAgIGFuZCBpbW1lZGlhdGVseSBhZnRlciBpdC4gVXNlcyB0aGUgc2FtZSBzeW50YXggYXMgdGFyZ2V0X3Njb3BlIHdpdGgKICAgICAgICAgICAgb3B0aW9uYWwgZXhwcmVzc2lvbiBhdCB0aGUgZW5kIGluIHF1b3Rlcy4KCgogICAgICAgICAgICAgICAgU2NvcGU6CiAgICAgICAgICAgICAgICAgICAgLSBhCiAgICAgICAgICAgICAgICAgICAgLSBiCgogICAgICAgICAgICAgICAgLSBweXRob24gZWRpdCBjYWxsZWQgd2l0aCBjb3Njb3BlX3dpdGggPSAiYSIsIGNvZGUgPSAiLSBjIiAtCgogICAgICAgICAgICAgICAgU2NvcGU6CiAgICAgICAgICAgICAgICAgICAgLSBhCiAgICAgICAgICAgICAgICAgICAgLSBjCiAgICAgICAgICAgICAgICAgICAgLSBiCgogICAgICAgICAgICAtICJfX0ZJTEVfU1RBUlRfXyIgKHNwZWNpYWwgdG9rZW4gZm9yIGZpbGUgYmVnaW5uaW5nKQogICAgICAgICAgICAtICJNeUNsYXNzOjptZXRob2QiIChpbnNlcnQgYWZ0ZXIgdGhpcyBtZXRob2Qgd2l0aGluIHRoZSB0YXJnZXQgc2NvcGUpCiAgICAgICAgICAgIC0gJyJleHByZXNzaW9uIicgKGluc2VydCBhZnRlciBhIGxpbmUgbWF0Y2hpbmcgdGhpcyBleHByZXNzaW9uKQogICAgICAgIGRlbGV0ZV9hX2xvdCA6IGJvb2wsIG9wdGlvbmFsCiAgICAtICJfX0ZJTEVfRU5EX18iIChzcGVjaWFsIHRva2VuIGZvciBmaWxlIGVuZCkKICAgICAgICAgICAgU2FmZXR5IHBhcmFtZXRlci4gTXVzdCBiZSBUcnVlIHRvIGFsbG93IG9wZXJhdGlvbnMgdGhhdCBkZWxldGUgbW9yZSB0aGFuIDEwMCBsaW5lcy4KICAgICAgICAgICAgSGVscHMgcHJldmVudCBhY2NpZGVudGFsIGZpbGUgb3ZlcndyaXRlcy4gRGVmYXVsdCBGYWxzZS4KCiAgICAgICAgUmV0dXJuczoKICAgICAgICAtLS0tLS0tLQogICAgICAgIHN0cgogICAgICAgICAgICBEZXNjcmlwdGlvbiBvZiB3aGF0IHdhcyBtb2RpZmllZCBvciBlcnJvciBtZXNzYWdlCiAgICCUjAI6OpSMAy5weZSMHUZpbGUgcGF0aCBtdXN0IGVuZCB3aXRoIC5weToglIwJX19GSVJTVF9flIwcSW52YWxpZCBpZGVudGlmaWVyIGluIHBhdGg6IJSME0Vycm9yIHJlYWRpbmcgZmlsZSCUjAI6IJROjACUjBNFcnJvciBwYXJzaW5nIGZpbGUglEsAjDtDYW5ub3QgdXNlIGVtcHR5IGNvZGUgd2l0aCBpbnNlcnRfYWZ0ZXIgLSBub3RoaW5nIHRvIGluc2VydJSMD0NvZGUgYWRkZWQgdG8gJ5SMAiculIwBI5SMBGJvZHmUhZSMGEVycm9yIHBhcnNpbmcgbmV3IGNvZGU6IJSMG0Vycm9yIHByb2Nlc3NpbmcgbmV3IGNvZGU6IJRLAYw1X19GSVJTVF9fIGNhbm5vdCBiZSBjb21iaW5lZCB3aXRoIG90aGVyIHBhdGggZWxlbWVudHOUjA5fX0ZJTEVfU1RBUlRfX5SMDF9fRklMRV9FTkRfX5SGlIwLQ2Fubm90IHVzZSCUjBUgd2l0aCBzY29wZWQgdGFyZ2V0ICeUjG8nLiBGaWxlLWxldmVsIHRva2VucyAoX19GSUxFX1NUQVJUX18sIF9fRklMRV9FTkRfXykgY2FuIG9ubHkgYmUgdXNlZCB3aXRoIGZpbGUtbGV2ZWwgdGFyZ2V0cyAoZS5nLiwgJ2ZpbGUucHknKS6UaE2MASCUaE5LZIwqU2FmZXR5IGNoZWNrOiB0aGlzIG9wZXJhdGlvbiB3b3VsZCBkZWxldGUglIwIIGxpbmVzLiCUjH1JZiBpbnRlbnRpb25hbCwgc2V0IGRlbGV0ZV9hX2xvdD1UcnVlLiBDb25zaWRlciB1c2luZyAnaW5zZXJ0X2FmdGVyJyBwYXJhbWV0ZXIgdG8gYWRkIGNvZGUgd2l0aG91dCBkZWxldGluZyBleGlzdGluZyBjb250ZW50LpSMIENvZGUgcmVwbGFjZWQgYXQgZmlsZSBsZXZlbCBpbiAnlIwYSW5zZXJ0IHBvaW50IG5vdCBmb3VuZDoglIwYVGFyZ2V0IHNjb3BlIG5vdCBmb3VuZDoglIwVQ29kZSBpbnNlcnRlZCBhZnRlciAnlIwGJyBpbiAnlIwSQ29kZSByZXBsYWNlZCBhdCAnlHSUKIwFc3BsaXSUjAhlbmRzd2l0aJRoB4wKVmFsdWVFcnJvcpSMDGlzaWRlbnRpZmllcpSMCl9tYWtlX2ZpbGWUjBNfcmVhZF9maWxlX2JvbV9zYWZllIwFc3RyaXCUaBZoFIwDY3N0lIwMcGFyc2VfbW9kdWxllIwIdGV4dHdyYXCUjAZkZWRlbnSUjBBfaGFuZGxlX2RlbGV0aW9ulIwUX3dyaXRlX2ZpbGVfYm9tX3NhZmWUjApzdGFydHN3aXRolIweX2NyZWF0ZV9zdGF0ZW1lbnRfd2l0aF9jb21tZW50lIwGTW9kdWxllIwDbGVulIwYX2hhbmRsZV9maXJzdF9kZWZpbml0aW9ulIwVX2NoZWNrX2Zvcl9kdXBsaWNhdGVzlIwcX2hhbmRsZV9maWxlX3N0YXJ0X2luc2VydGlvbpSMGl9oYW5kbGVfZmlsZV9lbmRfaW5zZXJ0aW9ulIwcX2hhbmRsZV9maWxlX2xldmVsX2luc2VydGlvbpSMGl9jb3VudF9saW5lc190b19iZV9kZWxldGVklIwNU2NvcGVSZXBs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FQPQDwFQGgPQEARQHQDQFQVQGgPQGgNQHQDQHQlQOwPQJgpQNgPQMAFQOwPQNgVQOwOUKSl0lFKUfZRoLGgtc2guTk50lFKUfZR9lCiMB19fZG9jX1+UaDqMDl9fa3dkZWZhdWx0c19flH2UKGh7Tmh8iXWMD19fYW5ub3RhdGlvbnNfX5R9lChoemgAjApfbG9hZF90eXBllJOUaBSFlFKUaHhonWh7aJ1ofGibjARib29slIWUUpSMBnJldHVybpRonXV1hpRijBJfX21vZHVsZV9jb250ZXh0X1+UjBRib3RzLmZvdW5kYXRpb24uYmFzZZSMDU1vZHVsZUNvbnRleHSUk5QpgZR9lCiMBG5hbWWUaC2MBnNvdXJjZZRYtFkAAGRlZiB0b29saWZ5KGRlc2NyaXB0aW9uOiBzdHIgPSBOb25lKToKICAgICIiIgogICAgQ29udmVydCBhbnkgZnVuY3Rpb24gaW50byBhIGJvdCB0b29sIHdpdGggc3RyaW5nLWluLCBzdHJpbmctb3V0IGludGVyZmFjZS4KCiAgICAtIENvbnZlcnRzIHN0cmluZyBpbnB1dHMgdG8gcHJvcGVyIHR5cGVzIHVzaW5nIHR5cGUgaGludHMKICAgIC0gRW5zdXJlcyBzdHJpbmcgb3V0cHV0IChKU09OIGZvciBjb21wbGV4IHR5cGVzKQogICAgLSBXcmFwcyBpbiBlcnJvciBoYW5kbGluZyAocmV0dXJucyBlcnJvciBzdHJpbmdzLCBuZXZlciByYWlzZXMpCiAgICAtIEVuaGFuY2VzIGRvY3N0cmluZyBpZiBkZXNjcmlwdGlvbiBwcm92aWRlZAoKICAgIEFyZ3M6CiAgICAgICAgZGVzY3JpcHRpb24gKHN0ciwgb3B0aW9uYWwpOiBPdmVycmlkZSB0aGUgZnVuY3Rpb24ncyBkb2NzdHJpbmcKCiAgICBFeGFtcGxlOgogICAgICAgIEB0b29saWZ5KCkKICAgICAgICBkZWYgYWRkX251bWJlcnMoeDogaW50LCB5OiBpbnQgPSAwKSAtPiBpbnQ6CiAgICAgICAgICAgIHJldHVybiB4ICsgeQoKICAgICAgICBAdG9vbGlmeSgiQ2FsY3VsYXRlIHRoZSBhcmVhIG9mIGEgY2lyY2xlIikKICAgICAgICBkZWYgYXJlYShyYWRpdXM6IGZsb2F0KSAtPiBmbG9hdDoKICAgICAgICAgICAgcmV0dXJuIDMuMTQxNTkgKiByYWRpdXMgKiByYWRpdXMKICAgICIiIgoKICAgIGRlZiBkZWNvcmF0b3IoZnVuYyk6CiAgICAgICAgQGZ1bmN0b29scy53cmFwcyhmdW5jKQogICAgICAgIGRlZiB3cmFwcGVyKCphcmdzLCAqKmt3YXJncyk6CiAgICAgICAgICAgIHRyeToKICAgICAgICAgICAgICAgICMgQ29udmVydCBzdHJpbmcgaW5wdXRzIHRvIHByb3BlciB0eXBlcyB1c2luZyB0eXBlIGhpbnRzCiAgICAgICAgICAgICAgICBjb252ZXJ0ZWRfYXJncywgY29udmVydGVkX2t3YXJncyA9IF9jb252ZXJ0X3Rvb2xfaW5wdXRzKGZ1bmMsIGFyZ3MsIGt3YXJncykKCiAgICAgICAgICAgICAgICAjIENhbGwgb3JpZ2luYWwgZnVuY3Rpb24KICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmMoKmNvbnZlcnRlZF9hcmdzLCAqKmNvbnZlcnRlZF9rd2FyZ3MpCgogICAgICAgICAgICAgICAgIyBDb252ZXJ0IHJlc3VsdCB0byBzdHJpbmcKICAgICAgICAgICAgICAgIHJldHVybiBfY29udmVydF90b29sX291dHB1dChyZXN1bHQpCgogICAgICAgICAgICBleGNlcHQgS2V5Ym9hcmRJbnRlcnJ1cHQgYXMgZToKICAgICAgICAgICAgICAgICMgQ29udmVydCBLZXlib2FyZEludGVycnVwdCB0byBUb29sRXhlY3V0aW9uRXJyb3IgdG8gcHJldmVudCBpdCBmcm9tCiAgICAgICAgICAgICAgICAjIGJ1YmJsaW5nIHVwIHRvIENMSSBhbmQgYmVpbmcgdHJlYXRlZCBhcyB1c2VyIEN0cmwrQwogICAgICAgICAgICAgICAgZnJvbSBib3RzLnV0aWxzLmhlbHBlcnMgaW1wb3J0IF9wcm9jZXNzX2Vycm9yCgogICAgICAgICAgICAgICAgdG9vbF9lcnJvciA9IFRvb2xFeGVjdXRpb25FcnJvcihmIlRvb2wgZXhlY3V0aW9uIGludGVycnVwdGVkOiB7c3RyKGUpfSIpCiAgICAgICAgICAgICAgICByZXR1cm4gX3Byb2Nlc3NfZXJyb3IodG9vbF9lcnJvcikKCiAgICAgICAgICAgIGV4Y2VwdCBUeXBlRXJyb3IgYXMgZToKICAgICAgICAgICAgICAgICMgQ2hlY2sgaWYgdGhpcyBpcyBhIG1pc3NpbmcgcmVxdWlyZWQgYXJndW1lbnQgZXJyb3IKICAgICAgICAgICAgICAgIGVycm9yX21zZyA9IHN0cihlKQogICAgICAgICAgICAgICAgaWYgIm1pc3NpbmciIGluIGVycm9yX21zZyBhbmQgInJlcXVpcmVkIiBpbiBlcnJvcl9tc2cgYW5kICJhcmd1bWVudCIgaW4gZXJyb3JfbXNnOgogICAgICAgICAgICAgICAgICAgICMgQWRkIHNwZWNpYWwgbWVzc2FnZSBmb3Igb3V0cHV0IHRva2VuIGxpbWl0YXRpb24KICAgICAgICAgICAgICAgICAgICBlbmhhbmNlZF9lcnJvciA9IFR5cGVFcnJvcigKICAgICAgICAgICAgICAgICAgICAgICAgZiJ7ZXJyb3JfbXNnfVxuXG4iCiAgICAgICAgICAgICAgICAgICAgICAgIGYi4pqg77iPICBUaGlzIGVycm9yIGlzIGNvbW1vbmx5IGNhdXNlZCBieSBoaXR0aW5nIHRoZSBtYXhfdG9rZW5zIGxpbWl0IGJlZm9yZSBjb21wbGV0aW5nIHRoZSB0b29sIGNhbGwuXG4iCiAgICAgICAgICAgICAgICAgICAgICAgIGYiVGhlIHJlc3BvbnNlIHdhcyB0cnVuY2F0ZWQgbWlkLXBhcmFtZXRlciwgbWFraW5nIGl0IGFwcGVhciB0aGF0IHJlcXVpcmVkIHBhcmFtZXRlcnMgYXJlIG1pc3NpbmcuXG4iCiAgICAgICAgICAgICAgICAgICAgICAgIGYiVG8gZml4IHRoaXM6IFdvcmsgaW4gU01BTExFUiBDSFVOS1MuIEVkaXQgZmV3ZXIgbGluZXMgYXQgYSB0aW1lLCAiCiAgICAgICAgICAgICAgICAgICAgICAgIGYib3IgYnJlYWsgeW91ciB0YXNrIGludG8gbXVsdGlwbGUgc3RlcHMuIgogICAgICAgICAgICAgICAgICAgICkKICAgICAgICAgICAgICAgICAgICBmcm9tIGJvdHMudXRpbHMuaGVscGVycyBpbXBvcnQgX3Byb2Nlc3NfZXJyb3IKCiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9wcm9jZXNzX2Vycm9yKGVuaGFuY2VkX2Vycm9yKQogICAgICAgICAgICAgICAgZWxzZToKICAgICAgICAgICAgICAgICAgICBmcm9tIGJvdHMudXRpbHMuaGVscGVycyBpbXBvcnQgX3Byb2Nlc3NfZXJyb3IKCiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9wcm9jZXNzX2Vycm9yKGUpCiAgICAgICAgICAgIGV4Y2VwdCBFeGNlcHRpb24gYXMgZToKICAgICAgICAgICAgICAgIGZyb20gYm90cy51dGlscy5oZWxwZXJzIGltcG9ydCBfcHJvY2Vzc19lcnJvcgoKICAgICAgICAgICAgICAgIHJldHVybiBfcHJvY2Vzc19lcnJvcihlKQoKICAgICAgICAjIFVwZGF0ZSBkb2NzdHJpbmcgaWYgZGVzY3JpcHRpb24gcHJvdmlkZWQKICAgICAgICBpZiBkZXNjcmlwdGlvbjoKICAgICAgICAgICAgd3JhcHBlci5fX2RvY19fID0gZGVzY3JpcHRpb24KICAgICAgICBlbGlmIG5vdCB3cmFwcGVyLl9fZG9jX186CiAgICAgICAgICAgICMgR2VuZXJhdGUgbWluaW1hbCBkb2NzdHJpbmcgZnJvbSBmdW5jdGlvbiBuYW1lCiAgICAgICAgICAgIHdyYXBwZXIuX19kb2NfXyA9IGYiRXhlY3V0ZSB7ZnVuYy5fX25hbWVfXy5yZXBsYWNlKCdfJywgJyAnKX0iCgogICAgICAgIHJldHVybiB3cmFwcGVyCgogICAgcmV0dXJuIGRlY29yYXRvcgoKQHRvb2xpZnkoKQpkZWYgcHl0aG9uX2VkaXQodGFyZ2V0X3Njb3BlOiBzdHIsIGNvZGU6IHN0ciwgKiwgY29zY29wZV93aXRoOiBzdHI9Tm9uZSwgZGVsZXRlX2FfbG90OiBib29sPUZhbHNlKSAtPiBzdHI6CiAgICAiIiIKICAgICAgICBFZGl0IFB5dGhvbiBjb2RlIHVzaW5nIHB5dGVzdC1zdHlsZSBzY29wZSBzeW50YXggYW5kIG9wdGlvbmFsIGV4cHJlc3Npb24gbWF0Y2hpbmcuCgogICAgICAgIFBhcmFtZXRlcnM6CiAgICAgICAgLS0tLS0tLS0tLS0KICAgICAgICB0YXJnZXRfc2NvcGUgOiBzdHIKICAgICAgICAgICAgTG9jYXRpb24gdG8gZWRpdCBpbiBweXRlc3Qtc3R5bGUgc2NvcGUgc3ludGF4OgogICAgICAgICAgICAtICJmaWxlLnB5IiAod2hvbGUgZmlsZSkKICAgICAgICAgICAgLSAiZmlsZS5weTo6TXlDbGFzcyIgKGNsYXNzKQogICAgICAgICAgICAtICJmaWxlLnB5OjpteV9mdW5jdGlvbiIgKGZ1bmN0aW9uKQogICAgICAgICAgICAtICJmaWxlLnB5OjpNeUNsYXNzOjptZXRob2QiIChtZXRob2QpCiAgICAgICAgICAgIC0gImZpbGUucHk6Ol9fRklSU1RfXyIgKGZpcnN0IHRvcC1sZXZlbCBkZWZpbml0aW9uKQoKICAgICAgICBjb2RlIDogc3RyCiAgICAgICAgICAgIFB5dGhvbiBjb2RlLiBUaGlzIGNvZGUgd2lsbCByZXBsYWNlIHRoZSBlbnRpcmUgdGFyZ2V0IHNjb3BlIGJ5IGRlZmF1bHQsCiAgICAgICAgICAgIG9yIGluc2VydCBhZnRlciAoaWYgY29zY29wZV93aXRoIGlzIHNwZWNpZmllZCkuIENvZGUgaXMgaW5kZW50ZWQgYXV0b21hdGljYWxseQogICAgICAgICAgICB0byBtYXRjaCB0byBzY29wZS4KCiAgICAgICAgY29zY29wZV93aXRoIDogc3RyLCBvcHRpb25hbAogICAgICAgICAgICBJZiBzcGVjaWZpZWQsIGNvZGUgaXMgaW5zZXJ0ZWQgaW4gdGhlIHNhbWUgc2NvcGUgYXMgdGhlIHNwZWNpZmllZCBjb2RlLAogICAgICAgICAgICBhbmQgaW1tZWRpYXRlbHkgYWZ0ZXIgaXQuIFVzZXMgdGhlIHNhbWUgc3ludGF4IGFzIHRhcmdldF9zY29wZSB3aXRoCiAgICAgICAgICAgIG9wdGlvbmFsIGV4cHJlc3Npb24gYXQgdGhlIGVuZCBpbiBxdW90ZXMuCgoKICAgICAgICAgICAgICAgIFNjb3BlOgogICAgICAgICAgICAgICAgICAgIC0gYQogICAgICAgICAgICAgICAgICAgIC0gYgoKICAgICAgICAgICAgICAgIC0gcHl0aG9uIGVkaXQgY2FsbGVkIHdpdGggY29zY29wZV93aXRoID0gImEiLCBjb2RlID0gIi0gYyIgLQoKICAgICAgICAgICAgICAgIFNjb3BlOgogICAgICAgICAgICAgICAgICAgIC0gYQogICAgICAgICAgICAgICAgICAgIC0gYwogICAgICAgICAgICAgICAgICAgIC0gYgoKICAgICAgICAgICAgLSAiX19GSUxFX1NUQVJUX18iIChzcGVjaWFsIHRva2VuIGZvciBmaWxlIGJlZ2lubmluZykKICAgICAgICAgICAgLSAiTXlDbGFzczo6bWV0aG9kIiAoaW5zZXJ0IGFmdGVyIHRoaXMgbWV0aG9kIHdpdGhpbiB0aGUgdGFyZ2V0IHNjb3BlKQogICAgICAgICAgICAtICciZXhwcmVzc2lvbiInIChpbnNlcnQgYWZ0ZXIgYSBsaW5lIG1hdGNoaW5nIHRoaXMgZXhwcmVzc2lvbikKICAgICAgICBkZWxldGVfYV9sb3QgOiBib29sLCBvcHRpb25hbAogICAgLSAiX19GSUxFX0VORF9fIiAoc3BlY2lhbCB0b2tlbiBmb3IgZmlsZSBlbmQpCiAgICAgICAgICAgIFNhZmV0eSBwYXJhbWV0ZXIuIE11c3QgYmUgVHJ1ZSB0byBhbGxvdyBvcGVyYXRpb25zIHRoYXQgZGVsZXRlIG1vcmUgdGhhbiAxMDAgbGluZXMuCiAgICAgICAgICAgIEhlbHBzIHByZXZlbnQgYWNjaWRlbnRhbCBmaWxlIG92ZXJ3cml0ZXMuIERlZmF1bHQgRmFsc2UuCgogICAgICAgIFJldHVybnM6CiAgICAgICAgLS0tLS0tLS0KICAgICAgICBzdHIKICAgICAgICAgICAgRGVzY3JpcHRpb24gb2Ygd2hhdCB3YXMgbW9kaWZpZWQgb3IgZXJyb3IgbWVzc2FnZQogICAgIiIiCiAgICB0cnk6CiAgICAgICAgZmlsZV9wYXRoLCAqcGF0aF9lbGVtZW50cyA9IHRhcmdldF9zY29wZS5zcGxpdCgnOjonKQogICAgICAgIGlmIG5vdCBmaWxlX3BhdGguZW5kc3dpdGgoJy5weScpOgogICAgICAgICAgICByZXR1cm4gX3Byb2Nlc3NfZXJyb3IoVmFsdWVFcnJvcihmJ0ZpbGUgcGF0aCBtdXN0IGVuZCB3aXRoIC5weToge2ZpbGVfcGF0aH0nKSkKICAgICAgICBmb3IgZWxlbWVudCBpbiBwYXRoX2VsZW1lbnRzOgogICAgICAgICAgICBpZiBub3QgZWxlbWVudC5pc2lkZW50aWZpZXIoKSBhbmQgZWxlbWVudCAhPSAnX19GSVJTVF9fJzoKICAgICAgICAgICAgICAgIHJldHVybiBfcHJvY2Vzc19lcnJvcihWYWx1ZUVycm9yKGYnSW52YWxpZCBpZGVudGlmaWVyIGluIHBhdGg6IHtlbGVtZW50fScpKQogICAgICAgIGFic19wYXRoID0gX21ha2VfZmlsZShmaWxlX3BhdGgpCiAgICAgICAgdHJ5OgogICAgICAgICAgICBvcmlnaW5hbF9jb250ZW50ID0gX3JlYWRfZmlsZV9ib21fc2FmZShhYnNfcGF0aCkKICAgICAgICAgICAgd2FzX29yaWdpbmFsbHlfZW1wdHkgPSBub3Qgb3JpZ2luYWxfY29udGVudC5zdHJpcCgpCiAgICAgICAgZXhjZXB0IEV4Y2VwdGlvbiBhcyBlOgogICAgICAgICAgICByZXR1cm4gX3Byb2Nlc3NfZXJyb3IoVmFsdWVFcnJvcihmJ0Vycm9yIHJlYWRpbmcgZmlsZSB7YWJzX3BhdGh9OiB7c3RyKGUpfScpKQogICAgICAgIHRyeToKICAgICAgICAgICAgaWYgb3JpZ2luYWxfY29udGVudC5zdHJpcCgpOgogICAgICAgICAgICAgICAgdHJlZSA9IGNzdC5wYXJzZV9tb2R1bGUob3JpZ2luYWxfY29udGVudCkKICAgICAgICAgICAgZWxzZToKICAgICAgICAgICAgICAgIHRyZWUgPSBjc3QucGFyc2VfbW9kdWxlKCcnKQogICAgICAgIGV4Y2VwdCBFeGNlcHRpb24gYXMgZToKICAgICAgICAgICAgcmV0dXJuIF9wcm9jZXNzX2Vycm9yKFZhbHVlRXJyb3IoZidFcnJvciBwYXJzaW5nIGZpbGUge2Fic19wYXRofToge3N0cihlKX0nKSkKICAgICAgICB0cnk6CiAgICAgICAgICAgIGltcG9ydCB0ZXh0d3JhcAogICAgICAgICAgICBjbGVhbmVkX2NvZGUgPSB0ZXh0d3JhcC5kZWRlbnQoY29kZSkuc3RyaXAoKQogICAgICAgICAgICBpZiBub3QgY2xlYW5lZF9jb2RlOgogICAgICAgICAgICAgICAgaWYgY29zY29wZV93aXRoOgogICAgICAgICAgICAgICAgICAgIHJldHVybiBfcHJvY2Vzc19lcnJvcihWYWx1ZUVycm9yKCdDYW5ub3QgdXNlIGVtcHR5IGNvZGUgd2l0aCBpbnNlcnRfYWZ0ZXIgLSBub3RoaW5nIHRvIGluc2VydCcpKQogICAgICAgICAgICAgICAgcmV0dXJuIF9oYW5kbGVfZGVsZXRpb24oYWJzX3BhdGgsIHRhcmdldF9zY29wZSwgcGF0aF9lbGVtZW50cywgb3JpZ2luYWxfY29udGVudCwgdHJlZSwgZGVsZXRlX2FfbG90KQogICAgICAgICAgICBlbGlmIHdhc19vcmlnaW5hbGx5X2VtcHR5IGFuZCAobm90IHBhdGhfZWxlbWVudHMpOgogICAgICAgICAgICAgICAgX3dyaXRlX2ZpbGVfYm9tX3NhZmUoYWJzX3BhdGgsIGNsZWFuZWRfY29kZSkKICAgICAgICAgICAgICAgIHJldHVybiBmIkNvZGUgYWRkZWQgdG8gJ3thYnNfcGF0aH0nLiIKICAgICAgICAgICAgbmV3X21vZHVsZSA9IE5vbmUKICAgICAgICAgICAgaWYgY2xlYW5lZF9jb2RlOgogICAgICAgICAgICAgICAgdHJ5OgogICAgICAgICAgICAgICAgICAgIG5ld19tb2R1bGUgPSBjc3QucGFyc2VfbW9kdWxlKGNsZWFuZWRfY29kZSkKICAgICAgICAgICAgICAgIGV4Y2VwdCBFeGNlcHRpb24gYXMgZToKICAgICAgICAgICAgICAgICAgICBpZiBjbGVhbmVkX2NvZGUuc3RyaXAoKS5zdGFydHN3aXRoKCcjJyk6CiAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1lbnRfc3RtdCA9IF9jcmVhdGVfc3RhdGVtZW50X3dpdGhfY29tbWVudChjbGVhbmVkX2NvZGUuc3RyaXAoKSkKICAgICAgICAgICAgICAgICAgICAgICAgbmV3X21vZHVsZSA9IGNzdC5Nb2R1bGUoYm9keT1bY29tbWVudF9zdG10XSkKICAgICAgICAgICAgICAgICAgICBlbHNlOgogICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3Byb2Nlc3NfZXJyb3IoVmFsdWVFcnJvcihmJ0Vycm9yIHBhcnNpbmcgbmV3IGNvZGU6IHtzdHIoZSl9JykpCiAgICAgICAgZXhjZXB0IEV4Y2VwdGlvbiBhcyBlOgogICAgICAgICAgICByZXR1cm4gX3Byb2Nlc3NfZXJyb3IoVmFsdWVFcnJvcihmJ0Vycm9yIHByb2Nlc3NpbmcgbmV3IGNvZGU6IHtzdHIoZSl9JykpCiAgICAgICAgaWYgcGF0aF9lbGVtZW50cyBhbmQgcGF0aF9lbGVtZW50c1swXSA9PSAnX19GSVJTVF9fJzoKICAgICAgICAgICAgaWYgbGVuKHBhdGhfZWxlbWVudHMpID4gMToKICAgICAgICAgICAgICAgIHJldHVybiBfcHJvY2Vzc19lcnJvcihWYWx1ZUVycm9yKCdfX0ZJUlNUX18gY2Fubm90IGJlIGNvbWJpbmVkIHdpdGggb3RoZXIgcGF0aCBlbGVtZW50cycpKQogICAgICAgICAgICByZXR1cm4gX2hhbmRsZV9maXJzdF9kZWZpbml0aW9uKGFic19wYXRoLCB0cmVlLCBuZXdfbW9kdWxlLCBjb3Njb3BlX3dpdGgpCiAgICAgICAgZHVwbGljYXRlX3dhcm5pbmcgPSBOb25lCiAgICAgICAgaWYgY29zY29wZV93aXRoIGFuZCBuZXdfbW9kdWxlOgogICAgICAgICAgICBkdXBsaWNhdGVfd2FybmluZyA9IF9jaGVja19mb3JfZHVwbGljYXRlcyh0cmVlLCBuZXdfbW9kdWxlLCBwYXRoX2VsZW1lbnRzKQogICAgICAgIGlmIGNvc2NvcGVfd2l0aCBpbiAoJ19fRklMRV9TVEFSVF9fJywgJ19fRklMRV9FTkRfXycpIGFuZCBwYXRoX2VsZW1lbnRzOgogICAgICAgICAgICByZXR1cm4gX3Byb2Nlc3NfZXJyb3IoVmFsdWVFcnJvcihmIkNhbm5vdCB1c2Uge2Nvc2NvcGVfd2l0aH0gd2l0aCBzY29wZWQgdGFyZ2V0ICd7dGFyZ2V0X3Njb3BlfScuIEZpbGUtbGV2ZWwgdG9rZW5zIChfX0ZJTEVfU1RBUlRfXywgX19GSUxFX0VORF9fKSBjYW4gb25seSBiZSB1c2VkIHdpdGggZmlsZS1sZXZlbCB0YXJnZXRzIChlLmcuLCAnZmlsZS5weScpLiIpKQogICAgICAgIGlmIGNvc2NvcGVfd2l0aCA9PSAnX19GSUxFX1NUQVJUX18nOgogICAgICAgICAgICByZXN1bHQgPSBfaGFuZGxlX2ZpbGVfc3RhcnRfaW5zZXJ0aW9uKGFic19wYXRoLCB0cmVlLCBuZXdfbW9kdWxlKQogICAgICAgICAgICBpZiBkdXBsaWNhdGVfd2FybmluZzoKICAgICAgICAgICAgICAgIHJlc3VsdCA9IGR1cGxpY2F0ZV93YXJuaW5nICsgJyAnICsgcmVzdWx0CiAgICAgICAgICAgIHJldHVybiByZXN1bHQKICAgICAgICBlbGlmIGNvc2NvcGVfd2l0aCA9PSAnX19GSUxFX0VORF9fJzoKICAgICAgICAgICAgcmVzdWx0ID0gX2hhbmRsZV9maWxlX2VuZF9pbnNlcnRpb24oYWJzX3BhdGgsIHRyZWUsIG5ld19tb2R1bGUpCiAgICAgICAgICAgIGlmIGR1cGxpY2F0ZV93YXJuaW5nOgogICAgICAgICAgICAgICAgcmVzdWx0ID0gZHVwbGljYXRlX3dhcm5pbmcgKyAnICcgKyByZXN1bHQKICAgICAgICAgICAgcmV0dXJuIHJlc3VsdAogICAgICAgIGVsaWYgbm90IHBhdGhfZWxlbWVudHM6CiAgICAgICAgICAgIGlmIGNvc2NvcGVfd2l0aDoKICAgICAgICAgICAgICAgIHJlc3VsdCA9IF9oYW5kbGVfZmlsZV9sZXZlbF9pbnNlcnRpb24oYWJzX3BhdGgsIHRyZWUsIG5ld19tb2R1bGUsIGNvc2NvcGVfd2l0aCkKICAgICAgICAgICAgICAgIGlmIGR1cGxpY2F0ZV93YXJuaW5nOgogICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGR1cGxpY2F0ZV93YXJuaW5nICsgJyAnICsgcmVzdWx0CiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0CiAgICAgICAgICAgIGVsc2U6CiAgICAgICAgICAgICAgICBsaW5lc190b19kZWxldGUgPSBfY291bnRfbGluZXNfdG9fYmVfZGVsZXRlZChvcmlnaW5hbF9jb250ZW50LCBjbGVhbmVkX2NvZGUpCiAgICAgICAgICAgICAgICBpZiBsaW5lc190b19kZWxldGUgPiAxMDAgYW5kIChub3QgZGVsZXRlX2FfbG90KToKICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3Byb2Nlc3NfZXJyb3IoVmFsdWVFcnJvcihmJ1NhZmV0eSBjaGVjazogdGhpcyBvcGVyYXRpb24gd291bGQgZGVsZXRlIHtsaW5lc190b19kZWxldGV9IGxpbmVzLiAnICsgIklmIGludGVudGlvbmFsLCBzZXQgZGVsZXRlX2FfbG90PVRydWUuIENvbnNpZGVyIHVzaW5nICdpbnNlcnRfYWZ0ZXInIHBhcmFtZXRlciB0byBhZGQgY29kZSB3aXRob3V0IGRlbGV0aW5nIGV4aXN0aW5nIGNvbnRlbnQuIikpCiAgICAgICAgICAgICAgICBfd3JpdGVfZmlsZV9ib21fc2FmZShhYnNfcGF0aCwgY2xlYW5lZF9jb2RlKQogICAgICAgICAgICAgICAgcmV0dXJuIGYiQ29kZSByZXBsYWNlZCBhdCBmaWxlIGxldmVsIGluICd7YWJzX3BhdGh9Jy4iCiAgICAgICAgZWxzZToKICAgICAgICAgICAgcmVwbGFjZXIgPSBTY29wZVJlcGxhY2VyKHBhdGhfZWxlbWVudHMsIG5ld19tb2R1bGUsIGNvc2NvcGVfd2l0aCwgdHJlZSkKICAgICAgICAgICAgbW9kaWZpZWRfdHJlZSA9IHRyZWUudmlzaXQocmVwbGFjZXIpCiAgICAgICAgICAgIGlmIG5vdCByZXBsYWNlci5tb2RpZmllZDoKICAgICAgICAgICAgICAgIGlmIGNvc2NvcGVfd2l0aDoKICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3Byb2Nlc3NfZXJyb3IoVmFsdWVFcnJvcihmJ0luc2VydCBwb2ludCBub3QgZm91bmQ6IHtjb3Njb3BlX3dpdGh9JykpCiAgICAgICAgICAgICAgICBlbHNlOgogICAgICAgICAgICAgICAgICAgIHJldHVybiBfcHJvY2Vzc19lcnJvcihWYWx1ZUVycm9yKGYnVGFyZ2V0IHNjb3BlIG5vdCBmb3VuZDoge3RhcmdldF9zY29wZX0nKSkKICAgICAgICAgICAgX3dyaXRlX2ZpbGVfYm9tX3NhZmUoYWJzX3BhdGgsIG1vZGlmaWVkX3RyZWUuY29kZSkKICAgICAgICAgICAgaWYgY29zY29wZV93aXRoOgogICAgICAgICAgICAgICAgcmVzdWx0ID0gZiJDb2RlIGluc2VydGVkIGFmdGVyICd7Y29zY29wZV93aXRofScgaW4gJ3thYnNfcGF0aH0nLiIKICAgICAgICAgICAgICAgIGlmIGR1cGxpY2F0ZV93YXJuaW5nOgogICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGR1cGxpY2F0ZV93YXJuaW5nICsgJyAnICsgcmVzdWx0CiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0CiAgICAgICAgICAgIGVsc2U6CiAgICAgICAgICAgICAgICByZXR1cm4gZiJDb2RlIHJlcGxhY2VkIGF0ICd7dGFyZ2V0X3Njb3BlfScuIgogICAgZXhjZXB0IEV4Y2VwdGlvbiBhcyBlOgogICAgICAgIHJldHVybiBfcHJvY2Vzc19lcnJvcihlKQoKZGVmIF9oYW5kbGVfZmlsZV9zdGFydF9pbnNlcnRpb24oYWJzX3BhdGg6IHN0ciwgdHJlZTogY3N0Lk1vZHVsZSwgbmV3X21vZHVsZTogY3N0Lk1vZHVsZSkgLT4gc3RyOgogICAgIiIiSGFuZGxlIGluc2VydGlvbiBhdCB0aGUgYmVnaW5uaW5nIG9mIGEgZmlsZSwgYXZvaWRpbmcgZHVwbGljYXRlIGltcG9ydHMuIiIiCiAgICBleGlzdGluZ19pbXBvcnRzID0gc2V0KCkKICAgIGZvciBzdG10IGluIHRyZWUuYm9keToKICAgICAgICBpZiBpc2luc3RhbmNlKHN0bXQsIChjc3QuU2ltcGxlU3RhdGVtZW50TGluZSwpKToKICAgICAgICAgICAgZm9yIHMgaW4gc3RtdC5ib2R5OgogICAgICAgICAgICAgICAgaWYgaXNpbnN0YW5jZShzLCBjc3QuSW1wb3J0KToKICAgICAgICAgICAgICAgICAgICBmb3IgbmFtZSBpbiBzLm5hbWVzOgogICAgICAgICAgICAgICAgICAgICAgICBpZiBpc2luc3RhbmNlKG5hbWUsIGNzdC5JbXBvcnRBbGlhcyk6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbXBvcnRfbmFtZSA9IF9nZXRfbW9kdWxlX25hbWUobmFtZS5uYW1lKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmdfaW1wb3J0cy5hZGQoKCdpbXBvcnQnLCBpbXBvcnRfbmFtZSkpCiAgICAgICAgICAgICAgICBlbGlmIGlzaW5zdGFuY2UocywgY3N0LkltcG9ydEZyb20pOgogICAgICAgICAgICAgICAgICAgIGlmIHMubW9kdWxlOgogICAgICAgICAgICAgICAgICAgICAgICBtb2R1bGVfbmFtZSA9IF9nZXRfbW9kdWxlX25hbWUocy5tb2R1bGUpCiAgICAgICAgICAgICAgICAgICAgICAgIGZvciBuYW1lIGluIHMubmFtZXM6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiBpc2luc3RhbmNlKG5hbWUsIGNzdC5JbXBvcnRBbGlhcyk6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1wb3J0ZWRfbmFtZSA9IF9nZXRfbW9kdWxlX25hbWUobmFtZS5uYW1lKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nX2ltcG9ydHMuYWRkKCgnZnJvbScsIG1vZHVsZV9uYW1lLCBpbXBvcnRlZF9uYW1lKSkKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsaWYgaXNpbnN0YW5jZShuYW1lLCBjc3QuSW1wb3J0U3Rhcik6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmdfaW1wb3J0cy5hZGQoKCdmcm9tJywgbW9kdWxlX25hbWUsICcqJykpCiAgICBuZXdfYm9keSA9IFtdCiAgICBmb3Igc3RtdCBpbiBuZXdfbW9kdWxlLmJvZHk6CiAgICAgICAgaWYgaXNpbnN0YW5jZShzdG10LCAoY3N0LlNpbXBsZVN0YXRlbWVudExpbmUsKSk6CiAgICAgICAgICAgIGZpbHRlcmVkX2ltcG9ydHMgPSBbXQogICAgICAgICAgICBub25faW1wb3J0X3N0bXRzID0gW10KICAgICAgICAgICAgZm9yIHMgaW4gc3RtdC5ib2R5OgogICAgICAgICAgICAgICAgaWYgaXNpbnN0YW5jZShzLCBjc3QuSW1wb3J0KToKICAgICAgICAgICAgICAgICAgICBuZXdfbmFtZXMgPSBbXQogICAgICAgICAgICAgICAgICAgIGZvciBuYW1lIGluIHMubmFtZXM6CiAgICAgICAgICAgICAgICAgICAgICAgIGlmIGlzaW5zdGFuY2UobmFtZSwgY3N0LkltcG9ydEFsaWFzKToKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltcG9ydF9uYW1lID0gX2dldF9tb2R1bGVfbmFtZShuYW1lLm5hbWUpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoJ2ltcG9ydCcsIGltcG9ydF9uYW1lKSBub3QgaW4gZXhpc3RpbmdfaW1wb3J0czoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdfbmFtZXMuYXBwZW5kKG5hbWUpCiAgICAgICAgICAgICAgICAgICAgaWYgbmV3X25hbWVzOgogICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXJlZF9pbXBvcnRzLmFwcGVuZChzLndpdGhfY2hhbmdlcyhuYW1lcz1uZXdfbmFtZXMpKQogICAgICAgICAgICAgICAgZWxpZiBpc2luc3RhbmNlKHMsIGNzdC5JbXBvcnRGcm9tKToKICAgICAgICAgICAgICAgICAgICBpZiBzLm1vZHVsZToKICAgICAgICAgICAgICAgICAgICAgICAgbW9kdWxlX25hbWUgPSBfZ2V0X21vZHVsZV9uYW1lKHMubW9kdWxlKQogICAgICAgICAgICAgICAgICAgICAgICBuZXdfbmFtZXMgPSBbXQogICAgICAgICAgICAgICAgICAgICAgICBmb3IgbmFtZSBpbiBzLm5hbWVzOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgaXNpbnN0YW5jZShuYW1lLCBjc3QuSW1wb3J0QWxpYXMpOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltcG9ydGVkX25hbWUgPSBfZ2V0X21vZHVsZV9uYW1lKG5hbWUubmFtZSkKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoJ2Zyb20nLCBtb2R1bGVfbmFtZSwgaW1wb3J0ZWRfbmFtZSkgbm90IGluIGV4aXN0aW5nX2ltcG9ydHM6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld19uYW1lcy5hcHBlbmQobmFtZSkKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsaWYgaXNpbnN0YW5jZShuYW1lLCBjc3QuSW1wb3J0U3Rhcik6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCdmcm9tJywgbW9kdWxlX25hbWUsICcqJykgbm90IGluIGV4aXN0aW5nX2ltcG9ydHM6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld19uYW1lcy5hcHBlbmQobmFtZSkKICAgICAgICAgICAgICAgICAgICAgICAgaWYgbmV3X25hbWVzOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyZWRfaW1wb3J0cy5hcHBlbmQocy53aXRoX2NoYW5nZXMobmFtZXM9bmV3X25hbWVzKSkKICAgICAgICAgICAgICAgIGVsc2U6CiAgICAgICAgICAgICAgICAgICAgbm9uX2ltcG9ydF9zdG10cy5hcHBlbmQocykKICAgICAgICAgICAgaWYgZmlsdGVyZWRfaW1wb3J0cyBvciBub25faW1wb3J0X3N0bXRzOgogICAgICAgICAgICAgICAgbmV3X2JvZHkuYXBwZW5kKHN0bXQud2l0aF9jaGFuZ2VzKGJvZHk9ZmlsdGVyZWRfaW1wb3J0cyArIG5vbl9pbXBvcnRfc3RtdHMpKQogICAgICAgIGVsc2U6CiAgICAgICAgICAgIG5ld19ib2R5LmFwcGVuZChzdG10KQogICAgY29tYmluZWRfYm9keSA9IG5ld19ib2R5ICsgbGlzdCh0cmVlLmJvZHkpCiAgICBtb2RpZmllZF90cmVlID0gdHJlZS53aXRoX2NoYW5nZXMoYm9keT1jb21iaW5lZF9ib2R5KQogICAgX3dyaXRlX2ZpbGVfYm9tX3NhZmUoYWJzX3BhdGgsIG1vZGlmaWVkX3RyZWUuY29kZSkKICAgIHJldHVybiBmIkNvZGUgaW5zZXJ0ZWQgYXQgc3RhcnQgb2YgJ3thYnNfcGF0aH0nIChkdXBsaWNhdGUgaW1wb3J0cyBmaWx0ZXJlZCkuIgoKZGVmIF9yZWFkX2ZpbGVfYm9tX3NhZmUoZmlsZV9wYXRoOiBzdHIpIC0+IHN0cjoKICAgICIiIlJlYWQgYSBmaWxlIHdpdGggQk9NIHByb3RlY3Rpb24uIiIiCiAgICB3aXRoIG9wZW4oZmlsZV9wYXRoLCAncicsIGVuY29kaW5nPSd1dGYtOCcpIGFzIGZpbGU6CiAgICAgICAgY29udGVudCA9IGZpbGUucmVhZCgpCiAgICByZXR1cm4gY2xlYW5fdW5pY29kZV9zdHJpbmcoY29udGVudCkKCmRlZiBfaGFuZGxlX2ZpbGVfZW5kX2luc2VydGlvbihhYnNfcGF0aDogc3RyLCB0cmVlOiBjc3QuTW9kdWxlLCBuZXdfbW9kdWxlOiBjc3QuTW9kdWxlKSAtPiBzdHI6CiAgICAiIiJIYW5kbGUgaW5zZXJ0aW9uIGF0IHRoZSBlbmQgb2YgYSBmaWxlLiIiIgogICAgaWYgbGVuKG5ld19tb2R1bGUuYm9keSkgPT0gMCBhbmQgbmV3X21vZHVsZS5jb2RlLnN0cmlwKCk6CiAgICAgICAgY29tbWVudF9zdG10ID0gX2NyZWF0ZV9zdGF0ZW1lbnRfd2l0aF9jb21tZW50KG5ld19tb2R1bGUuY29kZS5zdHJpcCgpKQogICAgICAgIG5ld19ib2R5ID0gbGlzdCh0cmVlLmJvZHkpICsgW2NvbW1lbnRfc3RtdF0KICAgIGVsc2U6CiAgICAgICAgbmV3X2JvZHkgPSBsaXN0KHRyZWUuYm9keSkgKyBsaXN0KG5ld19tb2R1bGUuYm9keSkKICAgIG1vZGlmaWVkX3RyZWUgPSB0cmVlLndpdGhfY2hhbmdlcyhib2R5PW5ld19ib2R5KQogICAgZmluYWxfY29kZSA9IG1vZGlmaWVkX3RyZWUuY29kZQogICAgaWYgZmluYWxfY29kZSBhbmQgKG5vdCBmaW5hbF9jb2RlLmVuZHN3aXRoKCdcbicpKToKICAgICAgICBmaW5hbF9jb2RlICs9ICdcbicKICAgIF93cml0ZV9maWxlX2JvbV9zYWZlKGFic19wYXRoLCBmaW5hbF9jb2RlKQogICAgcmV0dXJuIGYiQ29kZSBpbnNlcnRlZCBhdCBlbmQgb2YgJ3thYnNfcGF0aH0nLiIKCmRlZiBfY2hlY2tfZm9yX2R1cGxpY2F0ZXModHJlZTogY3N0Lk1vZHVsZSwgbmV3X21vZHVsZTogY3N0Lk1vZHVsZSwgcGF0aF9lbGVtZW50czogTGlzdFtzdHJdKSAtPiBPcHRpb25hbFtzdHJdOgogICAgIiIiCiAgICBDaGVjayBpZiBuZXcgY29kZSB3b3VsZCBjcmVhdGUgZHVwbGljYXRlIGRlZmluaXRpb25zLgoKICAgIFJldHVybnM6CiAgICAgICAgT3B0aW9uYWxbc3RyXTogV2FybmluZyBtZXNzYWdlIGlmIGR1cGxpY2F0ZXMgZm91bmQsIE5vbmUgb3RoZXJ3aXNlCiAgICAiIiIKICAgIG5ld19uYW1lcyA9IF9leHRyYWN0X2RlZmluaXRpb25fbmFtZXMobmV3X21vZHVsZSkKICAgIGlmIG5vdCBuZXdfbmFtZXM6CiAgICAgICAgcmV0dXJuIE5vbmUKICAgIGlmIG5vdCBwYXRoX2VsZW1lbnRzOgogICAgICAgIGV4aXN0aW5nX25hbWVzID0gX2V4dHJhY3RfZGVmaW5pdGlvbl9uYW1lcyh0cmVlKQogICAgICAgIGR1cGxpY2F0ZXMgPSBzZXQobmV3X25hbWVzKSAmIHNldChleGlzdGluZ19uYW1lcykKICAgICAgICBpZiBkdXBsaWNhdGVzOgogICAgICAgICAgICBkdXBfbGlzdCA9ICcsICcuam9pbihzb3J0ZWQoZHVwbGljYXRlcykpCiAgICAgICAgICAgIHJldHVybiBmJ1dhcm5pbmc6IEFkZGluZyBkdXBsaWNhdGUgZGVmaW5pdGlvbihzKToge2R1cF9saXN0fS4gVGhpcyB3aWxsIGNyZWF0ZSBtdWx0aXBsZSBkZWZpbml0aW9ucyB3aXRoIHRoZSBzYW1lIG5hbWUuJwogICAgZWxzZToKICAgICAgICBmaW5kZXIgPSBTY29wZUZpbmRlcihwYXRoX2VsZW1lbnRzKQogICAgICAgIHRyZWUudmlzaXQoZmluZGVyKQogICAgICAgIGlmIGZpbmRlci50YXJnZXRfbm9kZSBhbmQgaXNpbnN0YW5jZShmaW5kZXIudGFyZ2V0X25vZGUsIGNzdC5DbGFzc0RlZik6CiAgICAgICAgICAgIGV4aXN0aW5nX21ldGhvZHMgPSBbXQogICAgICAgICAgICBmb3IgaXRlbSBpbiBmaW5kZXIudGFyZ2V0X25vZGUuYm9keS5ib2R5OgogICAgICAgICAgICAgICAgaWYgaXNpbnN0YW5jZShpdGVtLCBjc3QuRnVuY3Rpb25EZWYpOgogICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nX21ldGhvZHMuYXBwZW5kKGl0ZW0ubmFtZS52YWx1ZSkKICAgICAgICAgICAgZHVwbGljYXRlcyA9IHNldChuZXdfbmFtZXMpICYgc2V0KGV4aXN0aW5nX21ldGhvZHMpCiAgICAgICAgICAgIGlmIGR1cGxpY2F0ZXM6CiAgICAgICAgICAgICAgICBkdXBfbGlzdCA9ICcsICcuam9pbihzb3J0ZWQoZHVwbGljYXRlcykpCiAgICAgICAgICAgICAgICBjbGFzc19uYW1lID0gZmluZGVyLnRhcmdldF9ub2RlLm5hbWUudmFsdWUKICAgICAgICAgICAgICAgIHJldHVybiBmIldhcm5pbmc6IEFkZGluZyBkdXBsaWNhdGUgbWV0aG9kKHMpIHRvIGNsYXNzICd7Y2xhc3NfbmFtZX0nOiB7ZHVwX2xpc3R9LiBUaGlzIHdpbGwgY3JlYXRlIG11bHRpcGxlIG1ldGhvZHMgd2l0aCB0aGUgc2FtZSBuYW1lLiIKICAgIHJldHVybiBOb25lCgpkZWYgX2NvdW50X2xpbmVzX3RvX2JlX2RlbGV0ZWQob3JpZ2luYWxfY29udGVudDogc3RyLCBuZXdfY29udGVudDogc3RyKSAtPiBpbnQ6CiAgICAiIiIKICAgIENvdW50IGhvdyBtYW55IGxpbmVzIHdvdWxkIGJlIGRlbGV0ZWQgYnkgY29tcGFyaW5nIG9yaWdpbmFsIHZzIG5ldyBjb250ZW50LgoKICAgIFBhcmFtZXRlcnM6CiAgICAtLS0tLS0tLS0tLQogICAgb3JpZ2luYWxfY29udGVudCA6IHN0cgogICAgICAgIFRoZSBvcmlnaW5hbCBmaWxlIGNvbnRlbnQKICAgIG5ld19jb250ZW50IDogc3RyCiAgICAgICAgVGhlIG5ldyBjb250ZW50IHRoYXQgd291bGQgcmVwbGFjZSBpdAoKICAgIFJldHVybnM6CiAgICAtLS0tLS0tLQogICAgaW50CiAgICAgICAgTnVtYmVyIG9mIGxpbmVzIHRoYXQgd291bGQgYmUgZGVsZXRlZAogICAgIiIiCiAgICBvcmlnaW5hbF9saW5lcyA9IGxlbihvcmlnaW5hbF9jb250ZW50LnNwbGl0bGluZXMoKSkgaWYgb3JpZ2luYWxfY29udGVudC5zdHJpcCgpIGVsc2UgMAogICAgbmV3X2xpbmVzID0gbGVuKG5ld19jb250ZW50LnNwbGl0bGluZXMoKSkgaWYgbmV3X2NvbnRlbnQuc3RyaXAoKSBlbHNlIDAKICAgIHJldHVybiBtYXgoMCwgb3JpZ2luYWxfbGluZXMgLSBuZXdfbGluZXMpCgpkZWYgX2hhbmRsZV9maWxlX2xldmVsX2luc2VydGlvbihhYnNfcGF0aDogc3RyLCB0cmVlOiBjc3QuTW9kdWxlLCBuZXdfbW9kdWxlOiBjc3QuTW9kdWxlLCBpbnNlcnRfYWZ0ZXI6IHN0cikgLT4gc3RyOgogICAgIiIiSGFuZGxlIGluc2VydGlvbiBhdCBmaWxlIGxldmVsIGFmdGVyIGEgc3BlY2lmaWMgcGF0dGVybi4iIiIKICAgIHBhdHRlcm4gPSBpbnNlcnRfYWZ0ZXIuc3RyaXAoKQogICAgaWYgcGF0dGVybi5zdGFydHN3aXRoKCciJykgYW5kIHBhdHRlcm4uZW5kc3dpdGgoJyInKSBvciAocGF0dGVybi5zdGFydHN3aXRoKCInIikgYW5kIHBhdHRlcm4uZW5kc3dpdGgoIiciKSk6CiAgICAgICAgcGF0dGVybiA9IHBhdHRlcm5bMTotMV0KCiAgICBjbGFzcyBGaWxlT25seUluc2VydGVyKGNzdC5DU1RUcmFuc2Zvcm1lcik6CgogICAgICAgIGRlZiBfX2luaXRfXyhzZWxmLCBwYXR0ZXJuOiBzdHIsIG5ld19ub2RlczogTGlzdFtjc3QuQ1NUTm9kZV0pOgogICAgICAgICAgICBzZWxmLnBhdHRlcm4gPSBwYXR0ZXJuLnN0cmlwKCkKICAgICAgICAgICAgc2VsZi5uZXdfbm9kZXMgPSBuZXdfbm9kZXMKICAgICAgICAgICAgc2VsZi5tb2RpZmllZCA9IEZhbHNlCgogICAgICAgIGRlZiBsZWF2ZV9Nb2R1bGUoc2VsZiwgb3JpZ2luYWxfbm9kZTogY3N0Lk1vZHVsZSwgdXBkYXRlZF9ub2RlOiBjc3QuTW9kdWxlKSAtPiBjc3QuTW9kdWxlOgogICAgICAgICAgICBuZXdfYm9keSA9IFtdCiAgICAgICAgICAgIGZvciBzdG10IGluIHVwZGF0ZWRfbm9kZS5ib2R5OgogICAgICAgICAgICAgICAgbmV3X2JvZHkuYXBwZW5kKHN0bXQpCiAgICAgICAgICAgICAgICBtYXRjaF9mb3VuZCA9IEZhbHNlCiAgICAgICAgICAgICAgICBpZiBpc2luc3RhbmNlKHN0bXQsIChjc3QuRnVuY3Rpb25EZWYsIGNzdC5DbGFzc0RlZikpIGFuZCBzdG10Lm5hbWUudmFsdWUgPT0gc2VsZi5wYXR0ZXJuOgogICAgICAgICAgICAgICAgICAgIG1hdGNoX2ZvdW5kID0gVHJ1ZQogICAgICAgICAgICAgICAgZWxzZToKICAgICAgICAgICAgICAgICAgICB0cnk6CiAgICAgICAgICAgICAgICAgICAgICAgIHN0bXRfY29kZSA9IHVwZGF0ZWRfbm9kZS5jb2RlX2Zvcl9ub2RlKHN0bXQpLnN0cmlwKCkKICAgICAgICAgICAgICAgICAgICAgICAgaWYgc2VsZi5wYXR0ZXJuIGluIHN0bXRfY29kZToKICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoX2ZvdW5kID0gVHJ1ZQogICAgICAgICAgICAgICAgICAgIGV4Y2VwdCBFeGNlcHRpb246CiAgICAgICAgICAgICAgICAgICAgICAgIHBhc3MKICAgICAgICAgICAgICAgIGlmIG1hdGNoX2ZvdW5kOgogICAgICAgICAgICAgICAgICAgIG5ld19ib2R5LmV4dGVuZChzZWxmLm5ld19ub2RlcykKICAgICAgICAgICAgICAgICAgICBzZWxmLm1vZGlmaWVkID0gVHJ1ZQogICAgICAgICAgICBpZiBzZWxmLm1vZGlmaWVkOgogICAgICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZWRfbm9kZS53aXRoX2NoYW5nZXMoYm9keT1uZXdfYm9keSkKICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZWRfbm9kZQogICAgaW5zZXJ0ZXIgPSBGaWxlT25seUluc2VydGVyKHBhdHRlcm4sIG5ld19tb2R1bGUuYm9keSkKICAgIG1vZGlmaWVkX3RyZWUgPSB0cmVlLnZpc2l0KGluc2VydGVyKQogICAgaWYgbm90IGluc2VydGVyLm1vZGlmaWVkOgogICAgICAgIHJldHVybiBfcHJvY2Vzc19lcnJvcihWYWx1ZUVycm9yKGYnSW5zZXJ0IHBvaW50IG5vdCBmb3VuZCBhdCBmaWxlIGxldmVsOiB7aW5zZXJ0X2FmdGVyfScpKQogICAgX3dyaXRlX2ZpbGVfYm9tX3NhZmUoYWJzX3BhdGgsIG1vZGlmaWVkX3RyZWUuY29kZSkKICAgIHJldHVybiBmIkNvZGUgaW5zZXJ0ZWQgYWZ0ZXIgJ3tpbnNlcnRfYWZ0ZXJ9JyBpbiAne2Fic19wYXRofScuIgoKZGVmIF9oYW5kbGVfZGVsZXRpb24oYWJzX3BhdGg6IHN0ciwgdGFyZ2V0X3Njb3BlOiBzdHIsIHBhdGhfZWxlbWVudHM6IGxpc3QsIG9yaWdpbmFsX2NvbnRlbnQ6IHN0ciwgdHJlZTogY3N0Lk1vZHVsZSwgZGVsZXRlX2FfbG90OiBib29sPUZhbHNlKSAtPiBzdHI6CiAgICAiIiJIYW5kbGUgZGVsZXRpb24gb2YgYSB0YXJnZXQgc2VjdGlvbiB3aGVuIGVtcHR5IGNvZGUgaXMgcHJvdmlkZWQuIiIiCiAgICB0cnk6CiAgICAgICAgbGluZXNfdG9fZGVsZXRlID0gX2NvdW50X2xpbmVzX3RvX2JlX2RlbGV0ZWQob3JpZ2luYWxfY29udGVudCwgJycpCiAgICAgICAgaWYgbGluZXNfdG9fZGVsZXRlID4gMTAwIGFuZCAobm90IGRlbGV0ZV9hX2xvdCk6CiAgICAgICAgICAgIHJldHVybiBfcHJvY2Vzc19lcnJvcihWYWx1ZUVycm9yKGYnU2FmZXR5IGNoZWNrOiB0aGlzIG9wZXJhdGlvbiB3b3VsZCBkZWxldGUge2xpbmVzX3RvX2RlbGV0ZX0gbGluZXMuICcgKyAiSWYgaW50ZW50aW9uYWwsIHNldCBkZWxldGVfYV9sb3Q9VHJ1ZS4gQ29uc2lkZXIgdXNpbmcgJ2luc2VydF9hZnRlcicgcGFyYW1ldGVyIHRvIGFkZCBjb2RlIHdpdGhvdXQgZGVsZXRpbmcgZXhpc3RpbmcgY29udGVudC4iKSkKICAgICAgICBpZiBub3QgcGF0aF9lbGVtZW50czoKICAgICAgICAgICAgX3dyaXRlX2ZpbGVfYm9tX3NhZmUoYWJzX3BhdGgsICcnKQogICAgICAgICAgICByZXR1cm4gZiJGaWxlICd7YWJzX3BhdGh9JyBjbGVhcmVkIChkZWxldGVkIGFsbCBjb250ZW50KS4iCiAgICAgICAgZWxzZToKICAgICAgICAgICAgZGVsZXRlciA9IFNjb3BlRGVsZXRlcihwYXRoX2VsZW1lbnRzKQogICAgICAgICAgICBtb2RpZmllZF90cmVlID0gdHJlZS52aXNpdChkZWxldGVyKQogICAgICAgICAgICBpZiBub3QgZGVsZXRlci5tb2RpZmllZDoKICAgICAgICAgICAgICAgIHJldHVybiBfcHJvY2Vzc19lcnJvcihWYWx1ZUVycm9yKGYnVGFyZ2V0IHNjb3BlIG5vdCBmb3VuZCBmb3IgZGVsZXRpb246IHt0YXJnZXRfc2NvcGV9JykpCiAgICAgICAgICAgIF93cml0ZV9maWxlX2JvbV9zYWZlKGFic19wYXRoLCBtb2RpZmllZF90cmVlLmNvZGUpCiAgICAgICAgICAgIHJldHVybiBmIkRlbGV0ZWQgc2NvcGUgJ3t0YXJnZXRfc2NvcGV9JyBmcm9tICd7YWJzX3BhdGh9Jy4iCiAgICBleGNlcHQgRXhjZXB0aW9uIGFzIGU6CiAgICAgICAgcmV0dXJuIF9wcm9jZXNzX2Vycm9yKGUpCgpkZWYgX3dyaXRlX2ZpbGVfYm9tX3NhZmUoZmlsZV9wYXRoOiBzdHIsIGNvbnRlbnQ6IHN0cikgLT4gTm9uZToKICAgICIiIldyaXRlIGEgZmlsZSB3aXRoIEJPTSBwcm90ZWN0aW9uLiIiIgogICAgZW5kc193aXRoX25ld2xpbmUgPSBjb250ZW50LmVuZHN3aXRoKCdcbicpCiAgICBjbGVhbl9jb250ZW50ID0gY2xlYW5fdW5pY29kZV9zdHJpbmcoY29udGVudCkKICAgIGlmIGVuZHNfd2l0aF9uZXdsaW5lIGFuZCAobm90IGNsZWFuX2NvbnRlbnQuZW5kc3dpdGgoJ1xuJykpOgogICAgICAgIGNsZWFuX2NvbnRlbnQgKz0gJ1xuJwogICAgd2l0aCBvcGVuKGZpbGVfcGF0aCwgJ3cnLCBlbmNvZGluZz0ndXRmLTgnKSBhcyBmaWxlOgogICAgICAgIGZpbGUud3JpdGUoY2xlYW5fY29udGVudCkKCmRlZiBfbWFrZV9maWxlKGZpbGVfcGF0aDogc3RyKSAtPiBzdHI6CiAgICAiIiIKICAgIENyZWF0ZSBhIGZpbGUgYW5kIGl0cyBwYXJlbnQgZGlyZWN0b3JpZXMgaWYgdGhleSBkb24ndCBleGlzdC4KCiAgICBQYXJhbWV0ZXJzOgogICAgLS0tLS0tLS0tLS0KICAgIGZpbGVfcGF0aCA6IHN0cgogICAgICAgIFBhdGggdG8gdGhlIGZpbGUgdG8gY3JlYXRlCgogICAgUmV0dXJuczoKICAgIC0tLS0tLS0tCiAgICBzdHIKICAgICAgICBBYnNvbHV0ZSBwYXRoIHRvIHRoZSBjcmVhdGVkL2V4aXN0aW5nIGZpbGUKCiAgICBSYWlzZXM6CiAgICAtLS0tLS0tCiAgICBWYWx1ZUVycm9yCiAgICAgICAgSWYgdGhlcmUncyBhbiBlcnJvciBjcmVhdGluZyB0aGUgZmlsZSBvciBkaXJlY3RvcmllcwogICAgIiIiCiAgICBpZiBub3QgZmlsZV9wYXRoOgogICAgICAgIHJhaXNlIFZhbHVlRXJyb3IoJ0ZpbGUgcGF0aCBjYW5ub3QgYmUgZW1wdHknKQogICAgYWJzX3BhdGggPSBvcy5wYXRoLmFic3BhdGgoZmlsZV9wYXRoKQogICAgZGlyX3BhdGggPSBvcy5wYXRoLmRpcm5hbWUoYWJzX3BhdGgpCiAgICBpZiBkaXJfcGF0aDoKICAgICAgICB0cnk6CiAgICAgICAgICAgIG9zLm1ha2VkaXJzKGRpcl9wYXRoLCBleGlzdF9vaz1UcnVlKQogICAgICAgIGV4Y2VwdCBFeGNlcHRpb24gYXMgZToKICAgICAgICAgICAgcmFpc2UgVmFsdWVFcnJvcihmJ0Vycm9yIGNyZWF0aW5nIGRpcmVjdG9yaWVzIHtkaXJfcGF0aH06IHtzdHIoZSl9JykKICAgIGlmIG5vdCBvcy5wYXRoLmV4aXN0cyhhYnNfcGF0aCk6CiAgICAgICAgdHJ5OgogICAgICAgICAgICB3aXRoIG9wZW4oYWJzX3BhdGgsICd3JywgZW5jb2Rpbmc9J3V0Zi04JykgYXMgZjoKICAgICAgICAgICAgICAgIGYud3JpdGUoJycpCiAgICAgICAgZXhjZXB0IEV4Y2VwdGlvbiBhcyBlOgogICAgICAgICAgICByYWlzZSBWYWx1ZUVycm9yKGYnRXJyb3IgY3JlYXRpbmcgZmlsZSB7YWJzX3BhdGh9OiB7c3RyKGUpfScpCiAgICByZXR1cm4gYWJzX3BhdGgKCmRlZiBfY3JlYXRlX3N0YXRlbWVudF93aXRoX2NvbW1lbnQoY29tbWVudF90ZXh0OiBzdHIsIGluZGVudF9sZXZlbDogaW50PTApIC0+IGNzdC5TaW1wbGVTdGF0ZW1lbnRMaW5lOgogICAgIiIiCiAgICBDcmVhdGUgYSBzdGF0ZW1lbnQgdGhhdCBjb250YWlucyBqdXN0IGEgY29tbWVudC4KICAgIFNpbmNlIExpYkNTVCByZXF1aXJlcyBzdGF0ZW1lbnRzIHRvIGhhdmUgYWN0dWFsIGNvZGUsIHdlIGNyZWF0ZSBhIHBhc3Mgc3RhdGVtZW50CiAgICB3aXRoIGEgdHJhaWxpbmcgY29tbWVudC4KICAgICIiIgogICAgbGluZXMgPSBjb21tZW50X3RleHQuc3RyaXAoKS5zcGxpdCgnXG4nKQogICAgaWYgbGVuKGxpbmVzKSA+IDE6CiAgICAgICAgY29tbWVudF90ZXh0ID0gbGluZXNbMF0KICAgIGNvbW1lbnRfdGV4dCA9IGNvbW1lbnRfdGV4dC5zdHJpcCgpCiAgICBpZiBjb21tZW50X3RleHQuc3RhcnRzd2l0aCgnIycpOgogICAgICAgIGNvbW1lbnRfdGV4dCA9IGNvbW1lbnRfdGV4dFsxOl0uc3RyaXAoKQogICAgY29tbWVudCA9IGNzdC5Db21tZW50KGYnIyB7Y29tbWVudF90ZXh0fScpCiAgICByZXR1cm4gY3N0LlNpbXBsZVN0YXRlbWVudExpbmUoYm9keT1bY3N0LlBhc3MoKV0sIHRyYWlsaW5nX3doaXRlc3BhY2U9Y3N0LlRyYWlsaW5nV2hpdGVzcGFjZSh3aGl0ZXNwYWNlPWNzdC5TaW1wbGVXaGl0ZXNwYWNlKCcgICcpLCBjb21tZW50PWNvbW1lbnQpKQoKZGVmIF9oYW5kbGVfZmlyc3RfZGVmaW5pdGlvbihhYnNfcGF0aDogc3RyLCB0cmVlOiBjc3QuTW9kdWxlLCBuZXdfbW9kdWxlOiBjc3QuTW9kdWxlLCBjb3Njb3BlX3dpdGg6IHN0cj1Ob25lKSAtPiBzdHI6CiAgICAiIiJIYW5kbGUgZWRpdGluZyB0aGUgZmlyc3QgdG9wLWxldmVsIGRlZmluaXRpb24gaW4gYSBmaWxlLiIiIgogICAgaWYgbm90IHRyZWUuYm9keToKICAgICAgICByZXR1cm4gX3Byb2Nlc3NfZXJyb3IoVmFsdWVFcnJvcignRmlsZSBoYXMgbm8gdG9wLWxldmVsIGRlZmluaXRpb25zIHRvIGVkaXQnKSkKICAgIGZpcnN0X2RlZl9pbmRleCA9IE5vbmUKICAgIGZvciBpLCBzdG10IGluIGVudW1lcmF0ZSh0cmVlLmJvZHkpOgogICAgICAgIGlmIGlzaW5zdGFuY2Uoc3RtdCwgKGNzdC5GdW5jdGlvbkRlZiwgY3N0LkNsYXNzRGVmKSk6CiAgICAgICAgICAgIGZpcnN0X2RlZl9pbmRleCA9IGkKICAgICAgICAgICAgYnJlYWsKICAgIGlmIGZpcnN0X2RlZl9pbmRleCBpcyBOb25lOgogICAgICAgIHJldHVybiBfcHJvY2Vzc19lcnJvcihWYWx1ZUVycm9yKCdObyBmdW5jdGlvbiBvciBjbGFzcyBkZWZpbml0aW9uIGZvdW5kIGluIGZpbGUnKSkKICAgIGlmIGNvc2NvcGVfd2l0aDoKICAgICAgICBuZXdfYm9keSA9IGxpc3QodHJlZS5ib2R5WzpmaXJzdF9kZWZfaW5kZXggKyAxXSkgKyBsaXN0KG5ld19tb2R1bGUuYm9keSkgKyBsaXN0KHRyZWUuYm9keVtmaXJzdF9kZWZfaW5kZXggKyAxOl0pCiAgICAgICAgbW9kaWZpZWRfdHJlZSA9IHRyZWUud2l0aF9jaGFuZ2VzKGJvZHk9bmV3X2JvZHkpCiAgICAgICAgX3dyaXRlX2ZpbGVfYm9tX3NhZmUoYWJzX3BhdGgsIG1vZGlmaWVkX3RyZWUuY29kZSkKICAgICAgICByZXR1cm4gZiJDb2RlIGluc2VydGVkIGFmdGVyIGZpcnN0IGRlZmluaXRpb24gaW4gJ3thYnNfcGF0aH0nLiIKICAgIGVsc2U6CiAgICAgICAgbmV3X2JvZHkgPSBsaXN0KHRyZWUuYm9keVs6Zmlyc3RfZGVmX2luZGV4XSkgKyBsaXN0KG5ld19tb2R1bGUuYm9keSkgKyBsaXN0KHRyZWUuYm9keVtmaXJzdF9kZWZfaW5kZXggKyAxOl0pCiAgICAgICAgbW9kaWZpZWRfdHJlZSA9IHRyZWUud2l0aF9jaGFuZ2VzKGJvZHk9bmV3X2JvZHkpCiAgICAgICAgX3dyaXRlX2ZpbGVfYm9tX3NhZmUoYWJzX3BhdGgsIG1vZGlmaWVkX3RyZWUuY29kZSkKICAgICAgICByZXR1cm4gZiJGaXJzdCBkZWZpbml0aW9uIHJlcGxhY2VkIGluICd7YWJzX3BhdGh9Jy4ilGh9jCJkeW5hbWljX21vZHVsZV8zMjMyNDIwMTI4OTQzODA0ODYzlIwJbmFtZXNwYWNllGgAjA5faW1wb3J0X21vZHVsZZSTlIwtX19ydW50aW1lX18uZHluYW1pY19tb2R1bGVfMjUwOTA2NjE2NzI2NjU0OTkwlIWUUpR9lChoLGgtaJVOjAtfX3BhY2thZ2VfX5ROjAhfX3NwZWNfX5ROjAhfX2ZpbGVfX5RorGgPjBNib3RzLmRldi5kZWNvcmF0b3JzlGgPk5RoEGi3aBCTlGgTaLdoE5OUjANhc3SUaK9ou4WUUpSMCGRhdGV0aW1llGivaL6FlFKUjAlmdW5jdG9vbHOUaK9owYWUUpSMB2luc3BlY3SUaK9oxIWUUpSMB2xvZ2dpbmeUaK9ox4WUUpSMAm9zlGivaMqFlFKUjANzeXOUaK+MA3N5c5SFlFKUaGdor2hnhZRSlIwJdHJhY2ViYWNrlGivaNOFlFKUjAV3cmFwc5RowWjWk5SMA0FueZSMBnR5cGluZ5Ro2JOUjAhDYWxsYWJsZZRo2Wjbk5SMCE9wdGlvbmFslGjZaN2TlIwEVHlwZZRo2Wjfk5SMEnJlbW92ZV9jb2RlX2Jsb2Nrc5RoEmjhk5SMBmxvZ2dlcpRox4wJZ2V0TG9nZ2VylJOUaLeFlFKUjAxOb0hUVFBGaWx0ZXKUaLdo6JOUjAdsYXp5X2ZulGi3aOqTlIwKbGF6eV9jbGFzc5Rot2jsk5SMDF9nZXRfY29udGV4dJRot2juk5SMEV9nZXRfcHlfaW50ZXJmYWNllGi3aPCTlIwEbGF6eZRot2jyk5SMDmRlYnVnX29uX2Vycm9ylGi3aPSTlIwKbG9nX2Vycm9yc5Rot2j2k5SMB3Rvb2xpZnmUaAIoaAQoQwQEFgo2lEsBSwBLAEsCSwJLA0MShwCXAIgAZgFkAYQIfQF8AVMAlFiIAgAACiAgICBDb252ZXJ0IGFueSBmdW5jdGlvbiBpbnRvIGEgYm90IHRvb2wgd2l0aCBzdHJpbmctaW4sIHN0cmluZy1vdXQgaW50ZXJmYWNlLgoKICAgIC0gQ29udmVydHMgc3RyaW5nIGlucHV0cyB0byBwcm9wZXIgdHlwZXMgdXNpbmcgdHlwZSBoaW50cwogICAgLSBFbnN1cmVzIHN0cmluZyBvdXRwdXQgKEpTT04gZm9yIGNvbXBsZXggdHlwZXMpCiAgICAtIFdyYXBzIGluIGVycm9yIGhhbmRsaW5nIChyZXR1cm5zIGVycm9yIHN0cmluZ3MsIG5ldmVyIHJhaXNlcykKICAgIC0gRW5oYW5jZXMgZG9jc3RyaW5nIGlmIGRlc2NyaXB0aW9uIHByb3ZpZGVkCgogICAg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aOBo4WjiaONo52joaOlo6mjraOxo7WjuaO9o8GjxaPJo82j0aPVo9mj3aPhqFgEAAGobAQAAahwBAABqHQEAAGoeAQAAah8BAABqIAEAAGohAQAAaiIBAABoZWolAQAAaAdqJgEAAGonAQAAaigBAABqKQEAAGorAQAAaGJqSgEAAGhjal8BAABoampzAQAAaHRqiAEAAGqQAQAAapIBAABocGq2AQAAasgBAABqyQEAAGrKAQAAassBAABqzAEAAGrNAQAAaqABAABqzgEAAGh1as8BAABq0AEAAGrRAQAAaC5oNWhyauIBAABob2r6AQAAaGxqGgIAAGohAgAAaiICAABqIwIAAGokAgAAaiUCAABqJgIAAGonAgAAaigCAABqKQIAAGoqAgAAaHFqSwIAAGhzaosCAABoaWqkAgAAapkCAABqqwIAAIwMX19idWlsdGluc19flGNidWlsdGlucwpfX2RpY3RfXwp1MGqJAgAAKGgsaC1olU5otE5qsAIAAE5otU5otmisaA9ouGgQaLloE2i6aLtovWi+aMBowWjDaMRoxmjHaMloymjMaM1o0GhnaNJo02jVaNZo12jYaNpo22jcaN1o3mjfaOBo4WjiaONo52joaOlo6mjraOxo7WjuaO9o8GjxaPJo82j0aPVo9mj3aPhqFgEAAGobAQAAahwBAABqHQEAAGoeAQAAah8BAABqIAEAAGohAQAAaiIBAABoZWolAQAAaAdqJgEAAGonAQAAaigBAABqKQEAAGorAQAAaGJqSgEAAGhjal8BAABoampzAQAAaHRqiAEAAGqQAQAAapIBAABocGq2AQAAasgBAABqyQEAAGrKAQAAassBAABqzAEAAGrNAQAAaqABAABqzgEAAGh1as8BAABq0AEAAGrRAQAAaC5oNWhyauIBAABob2r6AQAAaGxqGgIAAGohAgAAaiICAABqIwIAAGokAgAAaiUCAABqJgIAAGonAgAAaigCAABqKQIAAGoqAgAAaHFqSwIAAGhzaosCAABoaWqkAgAAapkCAABqqwIAAGqxAgAAY2J1aWx0aW5zCl9fZGljdF9fCnUwakkCAAAoaCxoLWiVTmi0TmqwAgAATmi1Tmi2aKxoD2i4aBBouWgTaLpou2i9aL5owGjBaMNoxGjGaMdoyWjKaMxozWjQaGdo0mjTaNVo1mjXaNho2mjbaNxo3WjeaN9o4GjhaOJo42jnaOho6WjqaOto7GjtaO5o72jwaPFo8mjzaPRo9Wj2aPdo+GoWAQAAahsBAABqHAEAAGodAQAAah4BAABqHwEAAGogAQAAaiEBAABqIgEAAGhlaiUBAABoB2omAQAAaicBAABqKAEAAGopAQAAaisBAABoYmpKAQAAaGNqXwEAAGhqanMBAABodGqIAQAAapABAABqkgEAAGhwarYBAABqyAEAAGrJAQAAasoBAABqywEAAGrMAQAAas0BAABqoAEAAGrOAQAAaHVqzwEAAGrQAQAAatEBAABoLmg1aHJq4gEAAGhvavoBAABobGoaAgAAaiECAABqIgIAAGojAgAAaiQCAABqJQIAAGomAgAAaicCAABqKAIAAGopAgAAaioCAABocWpLAgAAaHNqiwIAAGhpaqQCAABqmQIAAGqrAgAAarECAABjYnVpbHRpbnMKX19kaWN0X18KdTBqFwIAAChoLGgtaJVOaLROarACAABOaLVOaLZorGgPaLhoEGi5aBNoumi7aL1ovmjAaMFow2jEaMZox2jJaMpozGjNaNBoZ2jSaNNo1WjWaNdo2GjaaNto3GjdaN5o32jgaOFo4mjjaOdo6GjpaOpo62jsaO1o7mjvaPBo8WjyaPNo9Gj1aPZo92j4ahYBAABqGwEAAGocAQAAah0BAABqHgEAAGofAQAAaiABAABqIQEAAGoiAQAAaGVqJQEAAGgHaiYBAABqJwEAAGooAQAAaikBAABqKwEAAGhiakoBAABoY2pfAQAAaGpqcwEAAGh0aogBAABqkAEAAGqSAQAAaHBqtgEAAGrIAQAAaskBAABqygEAAGrLAQAAaswBAABqzQEAAGqgAQAAas4BAABodWrPAQAAatABAABq0QEAAGguaDVocmriAQAAaG9q+gEAAGhsahoCAABqIQIAAGoiAgAAaiMCAABqJAIAAGolAgAAaiYCAABqJwIAAGooAgAAaikCAABqKgIAAGhxaksCAABoc2qLAgAAaGlqpAIAAGqZAgAAaqsCAABqsQIAAGNidWlsdGlucwpfX2RpY3RfXwp1MGr4AQAAKGgsaC1olU5otE5qsAIAAE5otU5otmisaA9ouGgQaLloE2i6aLtovWi+aMBowWjDaMRoxmjHaMloymjMaM1o0GhnaNJo02jVaNZo12jYaNpo22jcaN1o3mjfaOBo4WjiaONo52joaOlo6mjraOxo7WjuaO9o8GjxaPJo82j0aPVo9mj3aPhqFgEAAGobAQAAahwBAABqHQEAAGoeAQAAah8BAABqIAEAAGohAQAAaiIBAABoZWolAQAAaAdqJgEAAGonAQAAaigBAABqKQEAAGorAQAAaGJqSgEAAGhjal8BAABoampzAQAAaHRqiAEAAGqQAQAAapIBAABocGq2AQAAasgBAABqyQEAAGrKAQAAassBAABqzAEAAGrNAQAAaqABAABqzgEAAGh1as8BAABq0AEAAGrRAQAAaC5oNWhyauIBAABob2r6AQAAaGxqGgIAAGohAgAAaiICAABqIwIAAGokAgAAaiUCAABqJgIAAGonAgAAaigCAABqKQIAAGoqAgAAaHFqSwIAAGhzaosCAABoaWqkAgAAapkCAABqqwIAAGqxAgAAY2J1aWx0aW5zCl9fZGljdF9fCnUwauABAAAoaCxoLWiVTmi0TmqwAgAATmi1Tmi2aKxoD2i4aBBouWgTaLpou2i9aL5owGjBaMNoxGjGaMdoyWjKaMxozWjQaGdo0mjTaNVo1mjXaNho2mjbaNxo3WjeaN9o4GjhaOJo42jnaOho6WjqaOto7GjtaO5o72jwaPFo8mjzaPRo9Wj2aPdo+GoWAQAAahsBAABqHAEAAGodAQAAah4BAABqHwEAAGogAQAAaiEBAABqIgEAAGhlaiUBAABoB2omAQAAaicBAABqKAEAAGopAQAAaisBAABoYmpKAQAAaGNqXwEAAGhqanMBAABodGqIAQAAapABAABqkgEAAGhwarYBAABqyAEAAGrJAQAAasoBAABqywEAAGrMAQAAas0BAABqoAEAAGrOAQAAaHVqzwEAAGrQAQAAatEBAABoLmg1aHJq4gEAAGhvavoBAABobGoaAgAAaiECAABqIgIAAGojAgAAaiQCAABqJQIAAGomAgAAaicCAABqKAIAAGopAgAAaioCAABocWpLAgAAaHNqiwIAAGhpaqQCAABqmQIAAGqrAgAAarECAABjYnVpbHRpbnMKX19kaWN0X18KdTBqtAEAAChoLGgtaJVOaLROarACAABOaLVOaLZorGgPaLhoEGi5aBNoumi7aL1ovmjAaMFow2jEaMZox2jJaMpozGjNaNBoZ2jSaNNo1WjWaNdo2GjaaNto3GjdaN5o32jgaOFo4mjjaOdo6GjpaOpo62jsaO1o7mjvaPBo8WjyaPNo9Gj1aPZo92j4ahYBAABqGwEAAGocAQAAah0BAABqHgEAAGofAQAAaiABAABqIQEAAGoiAQAAaGVqJQEAAGgHaiYBAABqJwEAAGooAQAAaikBAABqKwEAAGhiakoBAABoY2pfAQAAaGpqcwEAAGh0aogBAABqkAEAAGqSAQAAaHBqtgEAAGrIAQAAaskBAABqygEAAGrLAQAAaswBAABqzQEAAGqgAQAAas4BAABodWrPAQAAatABAABq0QEAAGguaDVocmriAQAAaG9q+gEAAGhsahoCAABqIQIAAGoiAgAAaiMCAABqJAIAAGolAgAAaiYCAABqJwIAAGooAgAAaikCAABqKgIAAGhxaksCAABoc2qLAgAAaGlqpAIAAGqZAgAAaqsCAABqsQIAAGNidWlsdGlucwpfX2RpY3RfXwp1MGqGAQAAKGgsaC1olU5otE5qsAIAAE5otU5otmisaA9ouGgQaLloE2i6aLtovWi+aMBowWjDaMRoxmjHaMloymjMaM1o0GhnaNJo02jVaNZo12jYaNpo22jcaN1o3mjfaOBo4WjiaONo52joaOlo6mjraOxo7WjuaO9o8GjxaPJo82j0aPVo9mj3aPhqFgEAAGobAQAAahwBAABqHQEAAGoeAQAAah8BAABqIAEAAGohAQAAaiIBAABoZWolAQAAaAdqJgEAAGonAQAAaigBAABqKQEAAGorAQAAaGJqSgEAAGhjal8BAABoampzAQAAaHRqiAEAAGqQAQAAapIBAABocGq2AQAAasgBAABqyQEAAGrKAQAAassBAABqzAEAAGrNAQAAaqABAABqzgEAAGh1as8BAABq0AEAAGrRAQAAaC5oNWhyauIBAABob2r6AQAAaGxqGgIAAGohAgAAaiICAABqIwIAAGokAgAAaiUCAABqJgIAAGonAgAAaigCAABqKQIAAGoqAgAAaHFqSwIAAGhzaosCAABoaWqkAgAAapkCAABqqwIAAGqxAgAAY2J1aWx0aW5zCl9fZGljdF9fCnUwanEBAAAoaCxoLWiVTmi0TmqwAgAATmi1Tmi2aKxoD2i4aBBouWgTaLpou2i9aL5owGjBaMNoxGjGaMdoyWjKaMxozWjQaGdo0mjTaNVo1mjXaNho2mjbaNxo3WjeaN9o4GjhaOJo42jnaOho6WjqaOto7GjtaO5o72jwaPFo8mjzaPRo9Wj2aPdo+GoWAQAAahsBAABqHAEAAGodAQAAah4BAABqHwEAAGogAQAAaiEBAABqIgEAAGhlaiUBAABoB2omAQAAaicBAABqKAEAAGopAQAAaisBAABoYmpKAQAAaGNqXwEAAGhqanMBAABodGqIAQAAapABAABqkgEAAGhwarYBAABqyAEAAGrJAQAAasoBAABqywEAAGrMAQAAas0BAABqoAEAAGrOAQAAaHVqzwEAAGrQAQAAatEBAABoLmg1aHJq4gEAAGhvavoBAABobGoaAgAAaiECAABqIgIAAGojAgAAaiQCAABqJQIAAGomAgAAaicCAABqKAIAAGopAgAAaioCAABocWpLAgAAaHNqiwIAAGhpaqQCAABqmQIAAGqrAgAAarECAABjYnVpbHRpbnMKX19kaWN0X18KdTBqXQEAAChoLGgtaJVOaLROarACAABOaLVOaLZorGgPaLhoEGi5aBNoumi7aL1ovmjAaMFow2jEaMZox2jJaMpozGjNaNBoZ2jSaNNo1WjWaNdo2GjaaNto3GjdaN5o32jgaOFo4mjjaOdo6GjpaOpo62jsaO1o7mjvaPBo8WjyaPNo9Gj1aPZo92j4ahYBAABqGwEAAGocAQAAah0BAABqHgEAAGofAQAAaiABAABqIQEAAGoiAQAAaGVqJQEAAGgHaiYBAABqJwEAAGooAQAAaikBAABqKwEAAGhiakoBAABoY2pfAQAAaGpqcwEAAGh0aogBAABqkAEAAGqSAQAAaHBqtgEAAGrIAQAAaskBAABqygEAAGrLAQAAaswBAABqzQEAAGqgAQAAas4BAABodWrPAQAAatABAABq0QEAAGguaDVocmriAQAAaG9q+gEAAGhsahoCAABqIQIAAGoiAgAAaiMCAABqJAIAAGolAgAAaiYCAABqJwIAAGooAgAAaikCAABqKgIAAGhxaksCAABoc2qLAgAAaGlqpAIAAGqZAgAAaqsCAABqsQIAAGNidWlsdGlucwpfX2RpY3RfXwp1MGpIAQAAKGgsaC1olU5otE5qsAIAAE5otU5otmisaA9ouGgQaLloE2i6aLtovWi+aMBowWjDaMRoxmjHaMloymjMaM1o0GhnaNJo02jVaNZo12jYaNpo22jcaN1o3mjfaOBo4WjiaONo52joaOlo6mjraOxo7WjuaO9o8GjxaPJo82j0aPVo9mj3aPhqFgEAAGobAQAAahwBAABqHQEAAGoeAQAAah8BAABqIAEAAGohAQAAaiIBAABoZWolAQAAaAdqJgEAAGonAQAAaigBAABqKQEAAGorAQAAaGJqSgEAAGhjal8BAABoampzAQAAaHRqiAEAAGqQAQAAapIBAABocGq2AQAAasgBAABqyQEAAGrKAQAAassBAABqzAEAAGrNAQAAaqABAABqzgEAAGh1as8BAABq0AEAAGrRAQAAaC5oNWhyauIBAABob2r6AQAAaGxqGgIAAGohAgAAaiICAABqIwIAAGokAgAAaiUCAABqJgIAAGonAgAAaigCAABqKQIAAGoqAgAAaHFqSwIAAGhzaosCAABoaWqkAgAAapkCAABqqwIAAGqxAgAAY2J1aWx0aW5zCl9fZGljdF9fCnUwahMBAAAoaCxoLWiVTmi0TmqwAgAATmi1Tmi2aKxoD2i4aBBouWgTaLpou2i9aL5owGjBaMNoxGjGaMdoyWjKaMxozWjQaGdo0mjTaNVo1mjXaNho2mjbaNxo3WjeaN9o4GjhaOJo42jnaOho6WjqaOto7GjtaO5o72jwaPFo8mjzaPRo9Wj2aPdo+GoWAQAAahsBAABqHAEAAGodAQAAah4BAABqHwEAAGogAQAAaiEBAABqIgEAAGhlaiUBAABoB2omAQAAaicBAABqKAEAAGopAQAAaisBAABoYmpKAQAAaGNqXwEAAGhqanMBAABodGqIAQAAapABAABqkgEAAGhwarYBAABqyAEAAGrJAQAAasoBAABqywEAAGrMAQAAas0BAABqoAEAAGrOAQAAaHVqzwEAAGrQAQAAatEBAABoLmg1aHJq4gEAAGhvavoBAABobGoaAgAAaiECAABqIgIAAGojAgAAaiQCAABqJQIAAGomAgAAaicCAABqKAIAAGopAgAAaioCAABocWpLAgAAaHNqiwIAAGhpaqQCAABqmQIAAGqrAgAAarECAABjYnVpbHRpbnMKX19kaWN0X18KdTBokChoLGgtaJVOaLROarACAABOaLVOaLZorGgPaLhoEGi5aBNoumi7aL1ovmjAaMFow2jEaMZox2jJaMpozGjNaNBoZ2jSaNNo1WjWaNdo2GjaaNto3GjdaN5o32jgaOFo4mjjaOdo6GjpaOpo62jsaO1o7mjvaPBo8WjyaPNo9Gj1aPZo92j4ahYBAABqGwEAAGocAQAAah0BAABqHgEAAGofAQAAaiABAABqIQEAAGoiAQAAaGVqJQEAAGgHaiYBAABqJwEAAGooAQAAaikBAABqKwEAAGhiakoBAABoY2pfAQAAaGpqcwEAAGh0aogBAABqkAEAAGqSAQAAaHBqtgEAAGrIAQAAaskBAABqygEAAGrLAQAAaswBAABqzQEAAGqgAQAAas4BAABodWrPAQAAatABAABq0QEAAGguaDVocmriAQAAaG9q+gEAAGhsahoCAABqIQIAAGoiAgAAaiMCAABqJAIAAGolAgAAaiYCAABqJwIAAGooAgAAaikCAABqKgIAAGhxaksCAABoc2qLAgAAaGlqpAIAAGqZAgAAaqsCAABqsQIAAGNidWlsdGlucwpfX2RpY3RfXwp1MIwIYnVpbHRpbnOUjAdnZXRhdHRylJOUjARkaWxslIwFX2RpbGyUk5SMCF9zZXRhdHRylGqyAgAAjAdzZXRhdHRylJOUh5RSlGgyjA1jZWxsX2NvbnRlbnRzlGiSh5RSMGgrKGgsaC1olU5otE5qsAIAAE5otU5otmisaA9ouGgQaLloE2i6aLtovWi+aMBowWjDaMRoxmjHaMloymjMaM1o0GhnaNJo02jVaNZo12jYaNpo22jcaN1o3mjfaOBo4WjiaONo52joaOlo6mjraOxo7WjuaO9o8GjxaPJo82j0aPVo9mj3aPhqFgEAAGobAQAAahwBAABqHQEAAGoeAQAAah8BAABqIAEAAGohAQAAaiIBAABoZWolAQAAaAdqJgEAAGonAQAAaigBAABqKQEAAGorAQAAaGJqSgEAAGhjal8BAABoampzAQAAaHRqiAEAAGqQAQAAapIBAABocGq2AQAAasgBAABqyQEAAGrKAQAAassBAABqzAEAAGrNAQAAaqABAABqzgEAAGh1as8BAABq0AEAAGrRAQAAaC5oNWhyauIBAABob2r6AQAAaGxqGgIAAGohAgAAaiICAABqIwIAAGokAgAAaiUCAABqJgIAAGonAgAAaigCAABqKQIAAGoqAgAAaHFqSwIAAGhzaosCAABoaWqkAgAAapkCAABqqwIAAGqxAgAAY2J1aWx0aW5zCl9fZGljdF9fCnUwLg==",
      "name": "python_edit",
      "hash": "bbe95f67995652d702b1c0219bf10f9746a0c7dd62898bcc3f159bc2ae79df68",
      "provenance": {
       "module": "dynamic_module_250906616726654990",
       "qualname": "python_edit"
      }
     },
     "_apply_scope_aware_truncation": {
      "__helper_func__": true,
      "pickled": "gASVPAAAAAAAAACMFmJvdHMudG9vbHMucHl0aG9uX2VkaXSUjB1fYXBwbHlfc2NvcGVfYXdhcmVfdHJ1bmNhdGlvbpSTlC4=",
      "name": "_apply_scope_aware_truncation",
      "hash": "35a507aa1f8ea745421a3bbacd5fb81516561564ed86842004bf34793edd480a",
      "provenance": {
       "module": "bots.tools.python_edit",
       "qualname": "_apply_scope_aware_truncation"
      }
     },
     "_create_signature_outline": {
      "__helper_func__": true,
      "pickled": "gASVOAAAAAAAAACMFmJvdHMudG9vbHMucHl0aG9uX2VkaXSUjBlfY3JlYXRlX3NpZ25hdHVyZV9vdXRsaW5llJOULg==",
      "name": "_create_signature_outline",
      "hash": "73cf1e4a4eb078fcae58b84f436b653a8e45f1be1bd987ac7958ecfad1ecd930",
      "provenance": {
       "module": "bots.tools.python_edit",
       "qualname": "_create_signature_outline"
      }
     },
     "_get_module_name": {
      "__helper_func__": true,
      "pickled": "gASVLwAAAAAAAACMFmJvdHMudG9vbHMucHl0aG9uX2VkaXSUjBBfZ2V0X21vZHVsZV9uYW1llJOULg==",
      "name": "_get_module_name",
      "hash": "30805f5c244780f1466652f5f126fa0b79de16e5b7acda9775eb4044ec1e5f6a",
      "provenance": {
       "module": "bots.tools.python_edit",
       "qualname": "_get_module_name"
      }
     },
     "_collect_scope_entries": {
      "__helper_func__": true,
      "pickled": "gASVNQAAAAAAAACMFmJvdHMudG9vbHMucHl0aG9uX2VkaXSUjBZfY29sbGVjdF9zY29wZV9lbnRyaWVzlJOULg==",
      "name": "_collect_scope_entries",
      "hash": "e9ce6f3a1146633cfc54be3623da8d3084e5b4f8e6cb27eebd616b1dd0ba509e",
      "provenance": {
       "module": "bots.tools.python_edit",
       "qualname": "_collect_scope_entries"
      }
     },
     "_create_outline_view": {
      "__helper_func__": true,
      "pickled": "gASVMwAAAAAAAACMFmJvdHMudG9vbHMucHl0aG9uX2VkaXSUjBRfY3JlYXRlX291dGxpbmVfdmlld5STlC4=",
      "name": "_create_outline_view",
      "hash": "5603f55056e2cd9e4430dd855b431bd668b6b10a5c672070e618302459afbe78",
      "provenance": {
       "module": "bots.tools.python_edit",
       "qualname": "_create_outline_view"
      }
     },
     "ScopeDeleter": {
      "__imported_callable__": true,
      "pickled": "gASVKwAAAAAAAACMFmJvdHMudG9vbHMucHl0aG9uX2VkaXSUjAxTY29wZURlbGV0ZXKUk5Qu",
      "name": "ScopeDeleter",
      "hash": "2e1797a54f6a4c4a737cf4b4afdd26d0427eae05984c9621a292238566decc39",
      "provenance": {
       "module": "bots.tools.python_edit",
       "qualname": "ScopeDeleter"
      }
     }
    }
   }
  },
  "function_paths": {
   "view": "dynamic_module_-7082991387547001233",
   "view_dir": "dynamic_module_2207060386889269295",
   "python_view": "dynamic_module_-3217427946027585444",
   "execute_powershell": "dynamic_module_3472951775955387811",
   "execute_python": "dynamic_module_-1285900034110763988",
   "branch_self": "dynamic_module_3913901117500357081",
   "remove_context": "dynamic_module_8141535594493942321",
   "list_context": "dynamic_module_-2907077857284453818",
   "web_search": "dynamic_module_7773849607267627855",
   "python_edit": "dynamic_module_3232420128943804863"
  }
 },
 "autosave": true,
 "filename": null,
 "bot_class": "AnthropicBot",
 "enable_tracing": true
}