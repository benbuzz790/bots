"""Development decorators for enhancing bot functionality and debugging.

This module provides decorators and utilities for:
- Lazy implementation using LLMs (@lazy)
- Lazy function implementation using LLMs (@lazy_fn)
- Lazy class implementation using LLMs (@lazy_class)
- Post-mortem debugging on exceptions (@debug_on_error)
- Error logging to file (@log_errors)
- HTTP logging filters for cleaner output

The primary features are:
- @lazy_impl: Smart decorator that chooses between lazy and lazy_class based on the type
- @lazy: Generates function implementations at runtime using LLM
- @lazy_class: Generates class implementations at runtime using LLM
- @debug_on_error: Launches pdb debugger on exceptions
- @log_errors: Logs exceptions and error messages to a file
    from bots.dev.decorators import lazy_impl, lazy, lazy_class, debug_on_error, log_errors

Example:
    from bots.dev.decorators import lazy_impl, lazy, lazy_class, debug_on_error

    # Smart decorator that works with both functions and classes
    @lazy("Implement a quicksort algorithm")
    def sort_list(items: list) -> list:
        pass  # Implementation will be generated by LLM

    @lazy("Implement a persistent key-value store with TTL")
    class KeyValueStore:
        pass  # Implementation will be generated by LLM

    # Also can use specific decorators
    @lazy_fn("Implement a merge sort algorithm")
    def merge_sort(items: list) -> list:
        pass

    @lazy_class("Implement a cache with LRU policy")
    class LRUCache:
        pass

    @debug_on_error
    def risky_operation():
        # Will launch debugger if this raises an exception
        process_data()

    @log_errors
    def might_error():
        # Will log any exceptions or "Error" messages to error_log.txt
        return "Error: Something went wrong"
"""

import ast
import datetime
import inspect
import logging
import os
import sys
import textwrap
import traceback
from functools import wraps
from typing import Any, Callable, Optional, Type

from bots.utils.helpers import remove_code_blocks

# from bots.foundation.base import Bot  # Commented to fix circular import
# from bots import AnthropicBot  # Commented to fix circular import
logging.basicConfig(level=logging.WARNING, format="%(asctime)s - %(name)s - %(levelname)s - %(message)s")
logger = logging.getLogger(__name__)
logger.setLevel(logging.DEBUG)


class NoHTTPFilter(logging.Filter):
    """Filters out logging records containing 'response' in the logger name.

    Use when you need to reduce noise from HTTP-related logging in the application.
    This filter helps prevent logging output from being flooded with HTTP response
    logs while still maintaining other important log messages.

    Inherits from:
        logging.Filter: Base class for logging filters

    Attributes:
        name (str): The name of the filter (inherited from logging.Filter)

    Example:
        logger = logging.getLogger(__name__)
        http_filter = NoHTTPFilter()
        logger.addFilter(http_filter)
    """

    def filter(self, record: logging.LogRecord) -> bool:
        """Check if the log record should be filtered.

        Parameters:
            record (logging.LogRecord): The log record to be checked

        Returns:
            bool: True if the record should be kept (doesn't contain 'response'),
                 False if it should be filtered out
        """
        return "response" not in record.name.lower()


logger.addFilter(NoHTTPFilter())


def lazy_fn(prompt: Optional[str] = None, bot: Optional[Any] = None, context: Optional[str] = None) -> Callable:
    """Decorator that lazily implements a function using an LLM at runtime.

    Use when you need to generate function implementations dynamically using an LLM.
    The implementation will be generated on first call and persisted to the source file.

    Parameters:
        prompt (Optional[str]): Additional instructions for the LLM about how to implement
            the function. Defaults to empty string.
        bot (Optional[Bot]): The bot instance to use for implementation. Defaults to
            a new AnthropicBot instance.
        context (Optional[str]): Level of context to provide to the LLM. Options are:
            - 'None': No additional context
            - 'low': Only the containing class
            - 'medium': The entire current file
            - 'high': Current file and interfaces of other files in directory
            - 'very high': All Python files in directory
            Defaults to 'None'.

    Returns:
        Callable: A decorator function that wraps the target function

    Example:
        @lazy("Sort using a funny algorithm. Name variables as though you're a clown.")
        def sort(arr: list[int]) -> list[int]:
            pass
    """

    def decorator(func: Callable) -> Callable:
        """Inner decorator function that sets up the lazy implementation.

        This decorator initializes the lazy implementation environment by:
        1. Setting up default bot if none provided
        2. Setting up default prompt if none provided
        3. Setting up default context level if none provided

        Parameters:
            func (Callable): The function to be lazily implemented

        Returns:
            Callable: A wrapped version of the function that will be implemented on first call

        Note:
            The actual implementation is generated in the wrapper function on first call.
        """
        nonlocal bot, prompt, context
        if bot is None:
            from bots import AnthropicBot

            bot = AnthropicBot(name="Claude")
        if prompt is None:
            prompt = ""
        if context is None:
            context = "None"

        def wrapper(*args: Any, **kwargs: Any) -> Any:
            """Wrapper function that handles lazy function implementation.

            This wrapper checks if the function has been implemented. If not, it:
            1. Gets appropriate context based on context_level
            2. Generates implementation using the LLM
            3. Updates the source file with the new implementation
            4. Executes the new implementation

            Parameters:
                *args (Any): Positional arguments to pass to the implemented function
                **kwargs (Any): Keyword arguments to pass to the implemented function

            Returns:
                Any: The result of the implemented function
            """
            nonlocal func
            if not hasattr(wrapper, "initialized") or not wrapper.initialized:
                function_name: str = func.__name__
                logger.debug(f"Initializing lazy function: {function_name}")
                context_content = _get_context(func, context)
                instructions: str = textwrap.dedent(
                    """Please fill out the following
                    function definition according to the following requirements.
                    Respond only with the code in a single code block. Include all
                    import statements inside the function definition. Remove the lazy
                    decorator. Respond only with the function definition, including
                    any new decorators and docstring. Include 'gen by @lazy' in the
                    docstring. Use PEP8 convention with type hints for all variables."""
                )
                complete_prompt: str = textwrap.dedent(
                    f"""
                    {instructions}

                    {prompt}

                    {context_content}

                    {function_name}{str(inspect.signature(func))}"""
                )
                response: str = bot.respond(complete_prompt)
                function_code, _ = remove_code_blocks(response)
                function_code = function_code[0]
                logger.debug(f"Generated function code:\n{function_code}")
                source_file: str = inspect.getfile(func)
                logger.debug(f"Source file: {source_file}")
                with open(source_file, "r", encoding="utf-8") as file:
                    source_lines: str = file.read()
                logger.debug(f"Original source file content:\n{source_lines}")
                source_tree: ast.AST = ast.parse(source_lines)

                class FunctionReplacer(ast.NodeTransformer):
                    """AST transformer that replaces a function definition with new code.

                    This transformer walks the AST and replaces a specific function's
                    definition with new code while preserving the rest of the module.

                    Attributes:
                        function_name (str): Name of the function to be replaced
                        new_code (str): New implementation code to replace the function with
                    """

                    def __init__(self, function_name: str, new_code: str):
                        self.function_name = function_name
                        self.new_code = new_code

                    def visit_FunctionDef(self, node: ast.FunctionDef) -> ast.AST:
                        if node.name == self.function_name:
                            logger.debug(f"Replacing function: {self.function_name}")
                            new_node: ast.AST = ast.parse(self.new_code).body[0]
                            return new_node
                        return node

                function_replacer = FunctionReplacer(function_name, function_code)
                new_tree: ast.AST = function_replacer.visit(source_tree)
                ast.fix_missing_locations(new_tree)
                new_source_lines: str = ast.unparse(new_tree)
                logger.debug(f"New source file content:\n{new_source_lines}")
                with open(source_file, "w", encoding="utf-8") as file:
                    file.write(new_source_lines)
                logger.debug("Updated source file written")
                exec(function_code, globals())
                func = globals()[function_name]
                wrapper.initialized = True
                logger.debug(f"Lazy function {function_name} initialized")
            return func(*args, **kwargs)

        wrapper.initialized = False
        return wrapper

    return decorator


def lazy_class(prompt: Optional[str] = None, bot: Optional[Any] = None, context: Optional[str] = None) -> Callable:
    """Decorator that lazily implements a class using an LLM at runtime.

    Use when you need to generate class implementations dynamically using an LLM.
    The implementation will be generated on first instantiation and persisted to the source file.

    Parameters:
        prompt (Optional[str]): Additional instructions for the LLM about how to implement
            the class. Defaults to empty string.
        bot (Optional[Bot]): The bot instance to use for implementation. Defaults to
            a new AnthropicBot instance.
        context (Optional[str]): Level of context to provide to the LLM. Options are:
            - 'None': No additional context
            - 'low': Only the containing module's imports and global variables
            - 'medium': The entire current file
            - 'high': Current file and interfaces of other files in directory
            - 'very high': All Python files in directory
            Defaults to 'None'.

    Returns:
        Callable: A decorator function that wraps the target class

    Example:
        @lazy_class("Implement a key-value store with Redis-like functionality")
        class DataStore:
            pass  # Will be implemented by LLM
    """

    def decorator(cls: Type) -> Type:
        """Inner decorator function that sets up the lazy class implementation.

        Parameters:
            cls (Type): The class to be lazily implemented

        Returns:
            Type: A wrapped version of the class that will be implemented on first instantiation
        """
        nonlocal bot, prompt, context
        if bot is None:
            from bots import AnthropicBot

            bot = AnthropicBot(name="Claude")
        if prompt is None:
            prompt = ""
        if context is None:
            context = "None"

        # Store the original __new__ method
        original_new = cls.__new__

        @wraps(original_new)
        def new_new(cls_self, *args, **kwargs):
            """Replacement for __new__ that handles lazy class implementation.

            This method checks if the class has been implemented. If not, it:
            1. Gets appropriate context based on context_level
            2. Generates implementation using the LLM
            3. Updates the source file with the new implementation
            4. Recreates the class with the new implementation

            Parameters:
                cls_self (Type): The class being instantiated
                *args (Any): Positional arguments to pass to the original __new__
                **kwargs (Any): Keyword arguments to pass to the original __new__

            Returns:
                Any: A new instance of the implemented class
            """
            if not hasattr(cls, "_lazy_initialized") or not cls._lazy_initialized:
                class_name: str = cls.__name__
                logger.debug(f"Initializing lazy class: {class_name}")

                # Get context for the class
                context_content = _get_context(cls, context)

                # Create prompt for LLM
                instructions: str = textwrap.dedent(
                    """Please implement the following class according to these requirements.
                    Respond only with the code in a single code block. Include all
                    import statements inside the class definition. Remove the lazy_class
                    decorator. Respond only with the class definition, including
                    any new decorators and docstring. Include 'gen by @lazy' in the
                    docstring. Use PEP8 convention with type hints."""
                )

                # Get the original class source code
                try:
                    original_class_code = inspect.getsource(cls)
                except (TypeError, OSError):
                    # Fall back to a basic class definition if source can't be retrieved
                    original_class_code = f"class {class_name}:\n    pass"

                complete_prompt: str = textwrap.dedent(
                    f"""
                    {instructions}

                    {prompt}

                    {context_content}

                    {original_class_code}"""
                )

                # Get implementation from LLM
                response: str = bot.respond(complete_prompt)
                class_code, _ = remove_code_blocks(response)
                class_code = class_code[0]
                logger.debug(f"Generated class code:\n{class_code}")

                # Update source file with new implementation
                source_file: str = inspect.getfile(cls)
                logger.debug(f"Source file: {source_file}")

                with open(source_file, "r", encoding="utf-8") as file:
                    source_lines: str = file.read()
                logger.debug(f"Original source file content:\n{source_lines}")

                source_tree: ast.AST = ast.parse(source_lines)

                class ClassReplacer(ast.NodeTransformer):
                    """AST transformer that replaces a class definition with new code.

                    This transformer walks the AST and replaces a specific class's
                    definition with new code while preserving the rest of the module.

                    Attributes:
                        class_name (str): Name of the class to be replaced
                        new_code (str): New implementation code to replace the class with
                    """

                    def __init__(self, class_name: str, new_code: str):
                        self.class_name = class_name
                        self.new_code = new_code

                    def visit_ClassDef(self, node: ast.ClassDef) -> ast.AST:
                        if node.name == self.class_name:
                            logger.debug(f"Replacing class: {self.class_name}")
                            new_node: ast.AST = ast.parse(self.new_code).body[0]
                            return new_node
                        return node

                class_replacer = ClassReplacer(class_name, class_code)
                new_tree: ast.AST = class_replacer.visit(source_tree)
                ast.fix_missing_locations(new_tree)

                new_source_lines: str = ast.unparse(new_tree)
                logger.debug(f"New source file content:\n{new_source_lines}")

                with open(source_file, "w", encoding="utf-8") as file:
                    file.write(new_source_lines)
                logger.debug("Updated source file written")

                # Execute the new class code
                module_globals = dict(globals())
                module_locals = {}
                exec(class_code, module_globals, module_locals)

                # Replace the current class with the new implementation
                new_cls = module_locals[class_name]

                # Copy all attributes from new_cls to cls
                for attr_name, attr_value in new_cls.__dict__.items():
                    if attr_name != "__dict__":
                        setattr(cls, attr_name, attr_value)

                # Mark as initialized
                cls._lazy_initialized = True
                logger.debug(f"Lazy class {class_name} initialized")

            # Call the original __new__ (which may have been replaced by the implementation)
            if hasattr(cls, "__new__") and cls.__new__ is not new_new:
                return cls.__new__(cls, *args, **kwargs)
            else:
                # Create a new instance with just the class
                instance = original_new(cls)
                # Then initialize it with the arguments
                if hasattr(instance, "__init__"):
                    instance.__init__(*args, **kwargs)
                return instance

        # Replace __new__ with our custom version
        cls.__new__ = new_new

        # Mark as not initialized
        cls._lazy_initialized = False

        return cls

    return decorator


def _get_context(obj: Any, context_level: str) -> str:
    """Retrieves contextual code based on the specified context level.

    Use when you need to gather source code context for an LLM to understand
    the environment of a function or class.

    Parameters:
        obj (Any): The function or class to get context for
        context_level (str): Level of context to retrieve:
            - 'None': Returns empty string
            - 'low': Returns class/module level context depending on object type
            - 'medium': Returns entire current file
            - 'high': Returns current file and interfaces of other files
            - 'very high': Returns all Python files in directory

    Returns:
        str: The requested context as a string

    Raises:
        ValueError: If context_level is not one of the valid options
    """
    if context_level == "None":
        return ""

    try:
        source_file = inspect.getfile(obj)
    except (TypeError, OSError):
        return ""

    source_dir = os.path.dirname(source_file)

    # Check if we're dealing with a function or class
    is_class = isinstance(obj, type)

    if context_level == "low":
        source_code = inspect.getsource(inspect.getmodule(obj))
        tree = ast.parse(source_code)

        if is_class:
            # For classes, return module imports and global variables
            imports_and_globals = []
            for node in tree.body:
                if isinstance(node, (ast.Import, ast.ImportFrom, ast.Assign)):
                    imports_and_globals.append(ast.unparse(node))
            return "\n".join(imports_and_globals)
        else:
            # For functions, return the containing class if applicable
            for node in ast.walk(tree):
                if isinstance(node, ast.ClassDef):
                    for sub_node in node.body:
                        if isinstance(sub_node, ast.FunctionDef) and sub_node.name == obj.__name__:
                            return ast.unparse(node)
            return ""

    elif context_level == "medium":
        with open(source_file, "r", encoding="utf-8") as file:
            return file.read()

    elif context_level == "high":
        context = ""
        with open(source_file, "r", encoding="utf-8") as file:
            context += f"Current file ({os.path.basename(source_file)}):\n{file.read()}\n\n"
        for filename in os.listdir(source_dir):
            if filename.endswith(".py") and filename != os.path.basename(source_file):
                file_path = os.path.join(source_dir, filename)
                context += f"Interface of {filename}:\n{_get_py_interface(file_path)}\n\n"
        return context

    elif context_level == "very high":
        context = ""
        for filename in os.listdir(source_dir):
            if filename.endswith(".py"):
                file_path = os.path.join(source_dir, filename)
                with open(file_path, "r", encoding="utf-8") as file:
                    context += f"File: {filename}\n{file.read()}\n\n"
        return context

    else:
        raise ValueError(f"Invalid context level: {context_level}")


def _get_py_interface(file_path: str) -> str:
    """Extracts the public interface (classes and functions) from a Python file.

    Use when you need to get a high-level overview of a Python module's structure
    without including implementation details.

    Parameters:
        file_path (str): Path to the Python file to analyze

    Returns:
        str: A string containing the module's interface, including class and function
            signatures with their docstrings
    """

    def get_docstring(node: ast.AST) -> str:
        """Extract docstring from an AST node.

        Parameters:
            node (ast.AST): The AST node to extract docstring from

        Returns:
            str: The node's docstring or empty string if none exists
        """
        return ast.get_docstring(node) or ""

    def format_function(node: ast.FunctionDef) -> str:
        """Format a function definition with its signature and docstring.

        Parameters:
            node (ast.FunctionDef): The function definition node to format

        Returns:
            str: Formatted string containing the function signature and docstring
        """
        return f'def {node.name}{ast.unparse(node.args)}:\n    """{get_docstring(node)}"""\n'

    def format_class(node: ast.ClassDef) -> str:
        """Format a class definition with its signature, docstring, and method interfaces.

        Parameters:
            node (ast.ClassDef): The class definition node to format

        Returns:
            str: Formatted string containing the class definition, including base classes,
                docstring, and method signatures
        """
        class_str = f"class {node.name}"
        if node.bases:
            class_str += f"({', '.join((ast.unparse(base) for base in node.bases))})"
        class_str += f':\n    """{get_docstring(node)}"""\n'
        for item in node.body:
            if isinstance(item, ast.FunctionDef):
                class_str += f"    {format_function(item)}\n"
        return class_str

    with open(file_path, "r", encoding="utf-8") as file:
        tree = ast.parse(file.read())
    interface = ""
    for node in tree.body:
        if isinstance(node, ast.ClassDef):
            interface += format_class(node) + "\n"
        elif isinstance(node, ast.FunctionDef):
            interface += format_function(node) + "\n"
    return interface.strip()


def lazy(prompt: Optional[str] = None, bot: Optional[Any] = None, context: Optional[str] = None) -> Callable:
    """Smart decorator that implements a function or class using an LLM at runtime.

    This is a convenience decorator that automatically chooses between @lazy and
    @lazy_class based on the type of the decorated object. It provides a unified
    interface for lazy implementation of both functions and classes.

    Parameters:
        prompt (Optional[str]): Additional instructions for the LLM about how to implement
            the function or class. Defaults to empty string.
        bot (Optional[Bot]): The bot instance to use for implementation. Defaults to
            a new AnthropicBot instance.
        context (Optional[str]): Level of context to provide to the LLM. Options are:
            - 'None': No additional context
            - 'low': Type-appropriate lowest level context
            - 'medium': The entire current file
            - 'high': Current file and interfaces of other files in directory
            - 'very high': All Python files in directory
            Defaults to 'None'.

    Returns:
        Callable: A decorator that applies either lazy or lazy_class based on the decorated object type

    Example:
        @lazy("Implement a sorting algorithm")
        def quicksort(items: list) -> list:
            pass  # Will be implemented by LLM

        @lazy("Implement a key-value store with TTL")
        class Cache:
            pass  # Will be implemented by LLM
    """

    def decorator(obj: Any) -> Any:
        """Inner decorator that dispatches to either lazy or lazy_class.

        Parameters:
            obj (Any): The function or class to be lazily implemented

        Returns:
            Any: The decorated function or class
        """
        if isinstance(obj, type):
            # If obj is a class, use lazy_class
            logger.debug(f"lazy_impl: Detected class {obj.__name__}, using lazy_class")
            return lazy_class(prompt, bot, context)(obj)
        else:
            # Otherwise assume it's a function and use lazy
            logger.debug(f"lazy_impl: Detected function {obj.__name__}, using lazy")
            return lazy_fn(prompt, bot, context)(obj)

    return decorator


def debug_on_error(func: Callable) -> Callable:
    """Decorator that launches post-mortem debugging on exception.

    Use when you need to automatically start a debugging session when a function
    raises an unhandled exception. This is particularly useful during development
    and troubleshooting.

    Parameters:
        func (Callable): The function to wrap with debugging capabilities

    Returns:
        Callable: A wrapped version of the function that will launch pdb on error

    Example:
        @debug_on_error
        def might_fail():
            # If this raises an exception, you'll get a pdb prompt
            risky_operation()
    """

    @wraps(func)
    def wrapper(*args: Any, **kwargs: Any) -> Any:
        try:
            return func(*args, **kwargs)
        except Exception:
            type, value, tb = sys.exc_info()
            traceback.print_exception(type, value, tb)
            print("\n--- Entering post-mortem debugging ---")
            import pdb

            pdb.post_mortem(tb)

    return wrapper


def log_errors(func: Callable) -> Callable:
    """Decorator that logs errors to a file when a function raises an exception or returns an error message.

    This decorator captures both exceptions and return values that contain "Error" in the first few words,
    logging them to 'error_log.txt' in the same directory as this decorators file.

    Parameters:
        func (Callable): The function to wrap with error logging capabilities

    Returns:
        Callable: A wrapped version of the function that logs errors

    Example:
        @log_errors
        def risky_function():
            # Any exceptions or "Error" messages will be logged
            return "Error: Something went wrong"
    """

    @wraps(func)
    def wrapper(*args: Any, **kwargs: Any) -> Any:
        try:
            result = func(*args, **kwargs)

            # Check if result is a string that starts with "Tool Failed:" (the specific format from handle_errors)
            if isinstance(result, str) and result.startswith("Tool Failed:"):
                _log_error_to_file(func.__name__, f"Function returned error message: {result}", args, kwargs)

            return result

        except Exception as e:
            # Log the exception
            error_msg = f"Exception in {func.__name__}: {str(e)}\nTraceback:\n{traceback.format_exc()}"
            _log_error_to_file(func.__name__, error_msg, args, kwargs)
            # Re-raise the exception
            raise

    return wrapper


def _log_error_to_file(function_name: str, error_message: str, args: tuple = None, kwargs: dict = None) -> None:
    """Helper function to log errors to the error log file.

    Parameters:
        function_name (str): Name of the function that had the error
        error_message (str): The error message to log
        args (tuple, optional): Positional arguments passed to the function
        kwargs (dict, optional): Keyword arguments passed to the function
    """
    # Get the directory where this decorators file is located
    decorators_dir = os.path.dirname(os.path.abspath(__file__))
    log_file_path = os.path.join(decorators_dir, "error_log.txt")

    # Create timestamp
    timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")

    args_parts = []
    if args:
        args_parts.append(f"args={args}")
    if kwargs:
        args_parts.append(f"kwargs={kwargs}")
    if args_parts:
        args_str = f"\nArguments: {', '.join(args_parts)}"

    # Format the log entry
    log_entry = f"[{timestamp}] Function: {function_name}{args_str}\n{error_message}\n{'-' * 80}\n\n"

    # Append to the log file
    try:
        with open(log_file_path, "a", encoding="utf-8") as log_file:
            log_file.write(log_entry)
    except Exception as e:
        # If we can't write to the log file, at least print to stderr
        print(f"Failed to write to error log: {e}", file=sys.stderr)
        print(f"Original error: {log_entry}", file=sys.stderr)


def handle_errors(func: Callable) -> Callable:
    """Decorator that catches exceptions and returns formatted error strings instead of raising.
    Use when you want a function to return error messages as strings rather than raising
    exceptions. This is useful for tools and APIs that need to handle errors gracefully
    and return error information to callers.
    The decorator uses the _process_error helper function to format exceptions into
    detailed error messages including tracebacks.
    Parameters:
        func (Callable): The function to wrap with error handling
    Returns:
        Callable: A wrapped version of the function that returns error strings instead of raising
    Example:
        @handle_errors
        def risky_operation(data):
            # If this raises an exception, it will be caught and returned as a string
            return process_data(data)
        result = risky_operation(bad_data)
        if result.startswith("Tool Failed:"):
            print(f"Operation failed: {result}")
    """
    from bots.utils.helpers import _process_error

    @wraps(func)
    def wrapper(*args: Any, **kwargs: Any) -> Any:
        try:
            return func(*args, **kwargs)
        except Exception as e:
            return _process_error(e)

    return wrapper
